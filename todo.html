<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classArmISA_1_1TableWalker.html#a6a5556160487c183ab7c8e3c0fea95e4">ArmISA::TableWalker::doL1Descriptor</a>  ()</dt>
<dd>: check sctlr.ha (bit[17]) if Hardware Access Flag is enabled if set, do l1.Desc.setAp0() instead of generating AccessFlag0  </dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classArmISA_1_1TableWalker.html#aa10ffa418815a92e2a26e9a8bfea2251">ArmISA::TableWalker::doL2Descriptor</a>  ()</dt>
<dd>: check sctlr.ha (bit[17]) if Hardware Access Flag is enabled if set, do l2.Desc.setAp0() instead of generating AccessFlag0  </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classArmISA_1_1TableWalker.html#ac4137cf4bb56dd2e1271b6fa72531719">ArmISA::TableWalker::walk</a>  (const RequestPtr &amp;req, <a class="el" href="classThreadContext.html" title="ThreadContext is the external interface to all thread state for anything outside of the CPU...">ThreadContext</a> *tc, uint16_t asid, uint8_t _vmid, bool _isHyp, <a class="el" href="classBaseTLB.html#a26b67ef35b9f92e337acf48571c7585e">TLB::Mode</a> mode, TLB::Translation *_trans, bool timing, bool functional, bool secure, <a class="el" href="classArmISA_1_1TLB.html#a8aaaf238d2bfe38a64a59fa71b2c4094">TLB::ArmTranslationType</a> tranType, bool _stage2Req)</dt>
<dd>These should be cached or grabbed from cached copies in the <a class="el" href="classArmISA_1_1TLB.html">TLB</a>, all these miscreg reads are expensive  </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classBaseCPU.html#a1e3fa77b4ef4cf21fbfb193ec94e9154">BaseCPU::instCnt</a>  </dt>
<dd>unify this with the counters that cpus individually keep  </dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="classBaseDynInst.html#afd5a603ab953f075866e3586cdcf7a4f">BaseDynInst&lt; Impl &gt;::_readySrcRegIdx</a>  </dt>
<dd>: Not sure this should be here vs the derived class.  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classBaseDynInst.html#a47f19df85729fed56c10a6f5bb605c6e">BaseDynInst&lt; Impl &gt;::doneTargCalc</a>  ()</dt>
<dd>: Actually use this instruction.  </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="classBaseDynInst.html#a242906c402116e1f822f687a628f2e8d">BaseDynInst&lt; Impl &gt;::renameSrcReg</a>  (int idx, PhysRegIdPtr renamed_src)</dt>
<dd>: add in whether or not the source register is ready.  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="classBaseO3DynInst.html#a83053b6be9a4074dce97213f32d57618">BaseO3DynInst&lt; Impl &gt;::setIntRegOperand</a>  (const <a class="el" href="classStaticInst.html" title="Base, ISA-independent static instruction class. ">StaticInst</a> *si, int idx, RegVal val) override</dt>
<dd>: Make results into arrays so they can handle multiple dest registers. </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="structBaseTags_1_1BaseTagStats.html#afd1b64a1d2ce67801b515772c2b1f4a1">BaseTags::BaseTagStats::avgRefs</a>  </dt>
<dd>This should change to an average stat once we have them.  </dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classBPredUnit.html#ab5a07626c161c358a59f3c576fe031a9">BPredUnit::update</a>  (ThreadID tid, Addr instPC, bool taken, void *bp_history, bool squashed, const StaticInstPtr &amp;inst=<a class="el" href="classStaticInst.html#a72613b9d07ecd43566ff4fac109ac689" title="Pointer to a statically allocated &quot;null&quot; instruction object. ">StaticInst::nullStaticInstPtr</a>, Addr corrTarget=MaxAddr)=0</dt>
<dd>Make this update flexible enough to handle a global predictor.  </dd>
<dt><a class="anchor" id="_todo000046"></a>Member <a class="el" href="classEventQueue.html#a74bcdad13d45b55c9d44711e89f66e68">EventQueue::serviceEvents</a>  (Tick when)</dt>
<dd>this assert is a good bug catcher. I need to make it true again.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classFullO3CPU.html#ae81d627566e0d36a8cb0fc1fb6866b72">FullO3CPU&lt; Impl &gt;::syscall</a>  (int64_t callnum, ThreadID tid, Fault *fault)</dt>
<dd>: Determine if this needs to be virtual.  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classGicV2.html#a00975098e1a7172c2ce12b5046122e69">GicV2::readDistributor</a>  (ContextID ctx, Addr daddr, size_t resp_sz)</dt>
<dd>software generated interrupts and PPIs can't be configured in some ways  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classIdeDisk.html#af711fdd8150c8623e461bade7fd72f83">IdeDisk::doDmaDataRead</a>  ()</dt>
<dd>we need to figure out what the delay actually will be  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classIdeDisk.html#a6abe13bc348e45ae7b558295a72cd1b0">IdeDisk::doDmaDataWrite</a>  ()</dt>
<dd>we need to figure out what the delay actually will be  </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="classIdeDisk.html#a60a085c8756c235cd99a548eaa1cc535">IdeDisk::serialize</a>  (CheckpointOut &amp;cp) const override</dt>
<dd>need to serialized chunk generator stuff!!  </dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classIdeDisk.html#aa0afc6c1b1a81cc1c6af156d0b5bd6bf">IdeDisk::startCommand</a>  ()</dt>
<dd>make this a scheduled event to simulate disk delay  </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="classIdeDisk.html#ab5948677f542cdbb2ef588b3f7585b53">IdeDisk::unserialize</a>  (<a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;cp) override</dt>
<dd>need to serialized chunk generator stuff!!  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="classIdeDisk.html#a065b7c8d6188d4bb96ec9aa3993ef3e8">IdeDisk::updateState</a>  (DevAction_t action)</dt>
<dd><p class="startdd">change this to a scheduled event to simulate disk delay </p>
<p class="enddd">change this to a scheduled event to simulate disk delay  </p>
</dd>
<dt><a class="anchor" id="_todo000006"></a>File <a class="el" href="inifile_8hh.html">inifile.hh</a>  </dt>
<dd>Change comments to match documentation style.  </dd>
<dt><a class="anchor" id="_todo000019"></a>Class <a class="el" href="classInstructionQueue.html">InstructionQueue&lt; Impl &gt;</a>  </dt>
<dd>: Make IQ able to handle multiple FU pools.  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="classInstructionQueue.html#aef6f5624fc57f3ba6c9da58fae657e1c">InstructionQueue&lt; Impl &gt;::commitToIEWDelay</a>  </dt>
<dd>: Make there be a distinction between the delays within IEW.  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="classInstructionQueue.html#a1457a5c88204b676b8648d343012826c">InstructionQueue&lt; Impl &gt;::listOrder</a>  </dt>
<dd>: Might be better to just move these entries around instead of creating new ones every time the position changes due to an instruction issuing. Not sure <a class="el" href="classstd_1_1list.html" title="STL list class. ">std::list</a> supports this.  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classInstructionQueue.html#a124912debf5250a350c01f55754bfd8c">InstructionQueue&lt; Impl &gt;::numIssuedDist</a>  </dt>
<dd>: Need to create struct to track the entry time for each instruction.  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="classInstructionQueue.html#a8a1306b0035d6377322817f4524b50d0">InstructionQueue&lt; Impl &gt;::statFuBusy</a>  </dt>
<dd>: Need to create struct to track the ready time for each instruction.  </dd>
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classLinuxAlphaSystem.html#a5e0e1b2232d67d030baeaa8a81e26eaf">LinuxAlphaSystem::initState</a>  ()</dt>
<dd>At some point we should change <a class="el" href="ev5_8hh.html">ev5.hh</a> and the palcode to support 255 ASNs.  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="classLSQUnit.html#a88c26f9302688cbd47f16c45e4c9a665">LSQUnit&lt; Impl &gt;::checkViolations</a>  (typename LoadQueue::iterator &amp;loadIt, const DynInstPtr &amp;inst)</dt>
<dd>in theory you only need to check an instruction that has executed however, there isn't a good way in the pipeline at the moment to check all instructions that will execute before the store writes back. Thus, like the implementation that came before it, we're overly conservative.  </dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="classNSGigE.html#a16a963d4924b7c2e82d338d693abe4af">NSGigE::cpuIntrPost</a>  (Tick when)</dt>
<dd>this warning should be removed and the intrTick code should be fixed.  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classNSGigE.html#aec2097dcddfbd9263ce8cfd2fd11c474">NSGigE::rxKick</a>  ()</dt>
<dd><p class="startdd">in reality, we should be able to start processing the packet as it arrives, and not have to wait for the full packet ot be in the receive fifo. </p>
<p class="enddd">do we want to schedule a future kick?  </p>
</dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classNSGigE.html#ac37bda95e09a290e343ef80fc3fc9e2b">NSGigE::txKick</a>  ()</dt>
<dd>do we want to schedule a future kick?  </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="classO3ThreadContext.html#ab2896e8ce7fd033de6c34bdee3e25e2a">O3ThreadContext&lt; Impl &gt;::dumpFuncProfile</a>  () override</dt>
<dd>: Implement.  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="classObjectMatch.html#ab8d7ae1a1ffed478facd3951a842f576">ObjectMatch::domatch</a>  (const std::string &amp;name) const</dt>
<dd>this should probably be changed to just use regular expression code  </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classRefCounted.html#a5e65f84e3e6cc1c2c633b97a19d49246">RefCounted::~RefCounted</a>  ()</dt>
<dd>Even if this were true, does it matter? Shouldn't the derived class indicate this? This only matters if we would ever choose to delete a "RefCounted *" which I doubt we'd ever do. We don't ever delete a "void *".  </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classSinic_1_1Base.html#a5484497c60d25dfdcb6cc59f8a96e907">Sinic::Base::cpuIntrPost</a>  (Tick when)</dt>
<dd>this warning should be removed and the intrTick code should be fixed.  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classSinic_1_1Device.html#a3c0694b7d39175c4c4604601e4d6c87d">Sinic::Device::rxKick</a>  ()</dt>
<dd>do we want to schedule a future kick?  </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classSinic_1_1Device.html#a328928a054fb0ac8251fbaf6187e8dd6">Sinic::Device::txKick</a>  ()</dt>
<dd>do we want to schedule a future kick?  </dd>
<dt><a class="anchor" id="_todo000029"></a>Class <a class="el" href="classSystemCounter.html">SystemCounter</a>  </dt>
<dd>: implement memory-mapped controls  </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="classTrace_1_1InstPBTrace.html#a76cdf11356afb176da9e161f2a919630">Trace::InstPBTrace::traceInst</a>  (<a class="el" href="classThreadContext.html" title="ThreadContext is the external interface to all thread state for anything outside of the CPU...">ThreadContext</a> *tc, StaticInstPtr si, TheISA::PCState pc)</dt>
<dd>if we are running multi-threaded I assume we'd need a lock here  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classTsunamiPChip.html#aa6caa548e1dc7483d2130d131741f300">TsunamiPChip::dmaAddr</a>  (const <a class="el" href="structPciBusAddr.html">PciBusAddr</a> &amp;addr, Addr pci_addr) const override</dt>
<dd><p class="startdd">Andrew says this needs to be fixed. What's wrong with it? </p>
<p class="enddd">This currently is faked by just doing a direct read from memory, however, to be realistic, this needs to actually do a bus transaction. The process is explained in the tsunami documentation on page 10-12 and basically munges the address to look up a PTE from a table in memory and then uses that mapping to create an address for the SG page  </p>
</dd>
<dt><a class="anchor" id="_todo000018"></a>Class <a class="el" href="classUnifiedFreeList.html">UnifiedFreeList</a>  </dt>
<dd>: Give a better name to the base FP dependency.  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="classVncServer.html#a5f88128dc2185a16b86d7e5476cab793">VncServer::sendFrameBufferUpdate</a>  ()</dt>
<dd>this doesn't do anything smart and just sends the entire image  </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="namespaceX86ISA.html#ae6679b41ceb610a77f04670463cbe737">X86ISA::convX87XTagsToTags</a>  (uint8_t ftwx)</dt>
<dd>Reconstruct the correct state of stack positions instead of just valid/invalid.</dd>
</dl>
</div></div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:13 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
