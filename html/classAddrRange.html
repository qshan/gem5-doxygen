<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: AddrRange Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAddrRange-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AddrRange Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classAddrRange.html" title="The AddrRange class encapsulates an address range, and supports a number of tests to check if two ran...">AddrRange</a> class encapsulates an address range, and supports a number of tests to check if two ranges intersect, if a range contains a specific address etc.  
 <a href="classAddrRange.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad372696271d6544850b2f3fa11d1d42f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#ad372696271d6544850b2f3fa11d1d42f">AddrRange</a> ()</td></tr>
<tr class="separator:ad372696271d6544850b2f3fa11d1d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35290e06e9eca605fcd8c8517faa1b53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a35290e06e9eca605fcd8c8517faa1b53">AddrRange</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a70d7492915570f1ef85c694c74419c3c">_start</a>, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a5578423da8b8279073c64bd448b0635d">_end</a>, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &gt; &amp;_masks, uint8_t _intlv_match)</td></tr>
<tr class="memdesc:a35290e06e9eca605fcd8c8517faa1b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an address range.  <a href="#a35290e06e9eca605fcd8c8517faa1b53">More...</a><br /></td></tr>
<tr class="separator:a35290e06e9eca605fcd8c8517faa1b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7113e7b46c40483d7c2800f1e31114"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a1a7113e7b46c40483d7c2800f1e31114">AddrRange</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a70d7492915570f1ef85c694c74419c3c">_start</a>, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a5578423da8b8279073c64bd448b0635d">_end</a>, uint8_t _intlv_high_bit, uint8_t _xor_high_bit, uint8_t _intlv_bits, uint8_t _intlv_match)</td></tr>
<tr class="memdesc:a1a7113e7b46c40483d7c2800f1e31114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy constructor of <a class="el" href="classAddrRange.html" title="The AddrRange class encapsulates an address range, and supports a number of tests to check if two ran...">AddrRange</a>.  <a href="#a1a7113e7b46c40483d7c2800f1e31114">More...</a><br /></td></tr>
<tr class="separator:a1a7113e7b46c40483d7c2800f1e31114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84c848bd49e618e07c4738e12a18336"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#ae84c848bd49e618e07c4738e12a18336">AddrRange</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a70d7492915570f1ef85c694c74419c3c">_start</a>, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a5578423da8b8279073c64bd448b0635d">_end</a>)</td></tr>
<tr class="separator:ae84c848bd49e618e07c4738e12a18336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2bb673335fc89a784522cf66fa495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a54f2bb673335fc89a784522cf66fa495">AddrRange</a> (const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAddrRange.html">AddrRange</a> &gt; &amp;ranges)</td></tr>
<tr class="memdesc:a54f2bb673335fc89a784522cf66fa495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an address range by merging a collection of interleaved ranges.  <a href="#a54f2bb673335fc89a784522cf66fa495">More...</a><br /></td></tr>
<tr class="separator:a54f2bb673335fc89a784522cf66fa495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17cc11f25132b98646ec45bc782ac79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#ab17cc11f25132b98646ec45bc782ac79">interleaved</a> () const</td></tr>
<tr class="memdesc:ab17cc11f25132b98646ec45bc782ac79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the range is interleaved or not.  <a href="#ab17cc11f25132b98646ec45bc782ac79">More...</a><br /></td></tr>
<tr class="separator:ab17cc11f25132b98646ec45bc782ac79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca1f726dd151069e354a5e58c257067"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a2ca1f726dd151069e354a5e58c257067">granularity</a> () const</td></tr>
<tr class="memdesc:a2ca1f726dd151069e354a5e58c257067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determing the interleaving granularity of the range.  <a href="#a2ca1f726dd151069e354a5e58c257067">More...</a><br /></td></tr>
<tr class="separator:a2ca1f726dd151069e354a5e58c257067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a6881ab65288dd1b58bac4f7093068"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a20a6881ab65288dd1b58bac4f7093068">stripes</a> () const</td></tr>
<tr class="memdesc:a20a6881ab65288dd1b58bac4f7093068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of interleaved address stripes this range is part of.  <a href="#a20a6881ab65288dd1b58bac4f7093068">More...</a><br /></td></tr>
<tr class="separator:a20a6881ab65288dd1b58bac4f7093068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8767320afd5f208677adc1d4087985ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a8767320afd5f208677adc1d4087985ce">size</a> () const</td></tr>
<tr class="memdesc:a8767320afd5f208677adc1d4087985ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the address range.  <a href="#a8767320afd5f208677adc1d4087985ce">More...</a><br /></td></tr>
<tr class="separator:a8767320afd5f208677adc1d4087985ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74737639783ffb916bff83049b9f1067"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a74737639783ffb916bff83049b9f1067">valid</a> () const</td></tr>
<tr class="memdesc:a74737639783ffb916bff83049b9f1067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the range is valid.  <a href="#a74737639783ffb916bff83049b9f1067">More...</a><br /></td></tr>
<tr class="separator:a74737639783ffb916bff83049b9f1067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc15c252cfd1299669febb874b9c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a2fbc15c252cfd1299669febb874b9c5e">start</a> () const</td></tr>
<tr class="memdesc:a2fbc15c252cfd1299669febb874b9c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start address of the range.  <a href="#a2fbc15c252cfd1299669febb874b9c5e">More...</a><br /></td></tr>
<tr class="separator:a2fbc15c252cfd1299669febb874b9c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cece22cba00e263de3805a066b7e484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a6cece22cba00e263de3805a066b7e484">end</a> () const</td></tr>
<tr class="memdesc:a6cece22cba00e263de3805a066b7e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end address of the range.  <a href="#a6cece22cba00e263de3805a066b7e484">More...</a><br /></td></tr>
<tr class="separator:a6cece22cba00e263de3805a066b7e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed4842b0a3d3878bf2cc481fae0446"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a84ed4842b0a3d3878bf2cc481fae0446">to_string</a> () const</td></tr>
<tr class="memdesc:a84ed4842b0a3d3878bf2cc481fae0446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of the range.  <a href="#a84ed4842b0a3d3878bf2cc481fae0446">More...</a><br /></td></tr>
<tr class="separator:a84ed4842b0a3d3878bf2cc481fae0446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156c29b86dd467a5f5feb6d864126f5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a156c29b86dd467a5f5feb6d864126f5b">mergesWith</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const</td></tr>
<tr class="memdesc:a156c29b86dd467a5f5feb6d864126f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if another range merges with the current one, i.e.  <a href="#a156c29b86dd467a5f5feb6d864126f5b">More...</a><br /></td></tr>
<tr class="separator:a156c29b86dd467a5f5feb6d864126f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0198d5a42763b54c292f0f71e2d518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a3b0198d5a42763b54c292f0f71e2d518">intersects</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const</td></tr>
<tr class="memdesc:a3b0198d5a42763b54c292f0f71e2d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if another range intersects this one, i.e.  <a href="#a3b0198d5a42763b54c292f0f71e2d518">More...</a><br /></td></tr>
<tr class="separator:a3b0198d5a42763b54c292f0f71e2d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d0308cc22362862da6e41088a28da6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a20d0308cc22362862da6e41088a28da6">isSubset</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const</td></tr>
<tr class="memdesc:a20d0308cc22362862da6e41088a28da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this range is a subset of another range, i.e.  <a href="#a20d0308cc22362862da6e41088a28da6">More...</a><br /></td></tr>
<tr class="separator:a20d0308cc22362862da6e41088a28da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615f684c623955389a18abc857dc885d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a615f684c623955389a18abc857dc885d">contains</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &amp;<a class="el" href="fiber_8test_8cc.html#a7ebe9f480adf0a119babe1c0ea50d96a">a</a>) const</td></tr>
<tr class="memdesc:a615f684c623955389a18abc857dc885d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the range contains an address.  <a href="#a615f684c623955389a18abc857dc885d">More...</a><br /></td></tr>
<tr class="separator:a615f684c623955389a18abc857dc885d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68af80f95fbcf8e0b0c539ddca8fa281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a68af80f95fbcf8e0b0c539ddca8fa281">removeIntlvBits</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="fiber_8test_8cc.html#a7ebe9f480adf0a119babe1c0ea50d96a">a</a>) const</td></tr>
<tr class="memdesc:a68af80f95fbcf8e0b0c539ddca8fa281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the interleaving bits from an input address.  <a href="#a68af80f95fbcf8e0b0c539ddca8fa281">More...</a><br /></td></tr>
<tr class="separator:a68af80f95fbcf8e0b0c539ddca8fa281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0137bf24c123f9653990267c94474ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a0137bf24c123f9653990267c94474ae2">addIntlvBits</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="fiber_8test_8cc.html#a7ebe9f480adf0a119babe1c0ea50d96a">a</a>) const</td></tr>
<tr class="memdesc:a0137bf24c123f9653990267c94474ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds the interleaving bits removed by removeIntlvBits.  <a href="#a0137bf24c123f9653990267c94474ae2">More...</a><br /></td></tr>
<tr class="separator:a0137bf24c123f9653990267c94474ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c198976af92db164edf679e35796f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a690c198976af92db164edf679e35796f">getOffset</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &amp;<a class="el" href="fiber_8test_8cc.html#a7ebe9f480adf0a119babe1c0ea50d96a">a</a>) const</td></tr>
<tr class="memdesc:a690c198976af92db164edf679e35796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the offset of an address within the range.  <a href="#a690c198976af92db164edf679e35796f">More...</a><br /></td></tr>
<tr class="separator:a690c198976af92db164edf679e35796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d5d7e1369257272736687a003fd078"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#ac9d5d7e1369257272736687a003fd078">operator&lt;</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const</td></tr>
<tr class="memdesc:ac9d5d7e1369257272736687a003fd078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator used to turn an STL map into a binary search tree of non-overlapping address ranges.  <a href="#ac9d5d7e1369257272736687a003fd078">More...</a><br /></td></tr>
<tr class="separator:ac9d5d7e1369257272736687a003fd078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc5630188e3aceb5588a0944405a86a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a6cc5630188e3aceb5588a0944405a86a">operator==</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const</td></tr>
<tr class="separator:a6cc5630188e3aceb5588a0944405a86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a123905c608eb34fa0a53cd983e7bd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a0a123905c608eb34fa0a53cd983e7bd8">operator!=</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const</td></tr>
<tr class="separator:a0a123905c608eb34fa0a53cd983e7bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a70d7492915570f1ef85c694c74419c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a70d7492915570f1ef85c694c74419c3c">_start</a></td></tr>
<tr class="memdesc:a70d7492915570f1ef85c694c74419c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private fields for the start and end of the range _start is the beginning of the range (inclusive).  <a href="#a70d7492915570f1ef85c694c74419c3c">More...</a><br /></td></tr>
<tr class="separator:a70d7492915570f1ef85c694c74419c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5578423da8b8279073c64bd448b0635d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a5578423da8b8279073c64bd448b0635d">_end</a></td></tr>
<tr class="separator:a5578423da8b8279073c64bd448b0635d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76045af8c3d4fdf9ecaeb4ab0ba2b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#af76045af8c3d4fdf9ecaeb4ab0ba2b79">masks</a></td></tr>
<tr class="memdesc:af76045af8c3d4fdf9ecaeb4ab0ba2b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each mask determines the bits we need to xor to get one bit of sel.  <a href="#af76045af8c3d4fdf9ecaeb4ab0ba2b79">More...</a><br /></td></tr>
<tr class="separator:af76045af8c3d4fdf9ecaeb4ab0ba2b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73137889a4d61ca40bd9224e73f840c2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a73137889a4d61ca40bd9224e73f840c2">intlvMatch</a></td></tr>
<tr class="memdesc:a73137889a4d61ca40bd9224e73f840c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value to compare sel with.  <a href="#a73137889a4d61ca40bd9224e73f840c2">More...</a><br /></td></tr>
<tr class="separator:a73137889a4d61ca40bd9224e73f840c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classAddrRange.html" title="The AddrRange class encapsulates an address range, and supports a number of tests to check if two ran...">AddrRange</a> class encapsulates an address range, and supports a number of tests to check if two ranges intersect, if a range contains a specific address etc. </p>
<p>Besides a basic range, the <a class="el" href="classAddrRange.html" title="The AddrRange class encapsulates an address range, and supports a number of tests to check if two ran...">AddrRange</a> also support interleaved ranges, to stripe across cache banks, or memory controllers. The interleaving is implemented by allowing a number of bits of the address, at an arbitrary bit position, to be used as interleaving bits with an associated matching value. In addition, to prevent uniformly strided address patterns from a very biased interleaving, we also allow XOR-based hashing by specifying a set of bits to XOR with before matching.</p>
<p>The <a class="el" href="classAddrRange.html" title="The AddrRange class encapsulates an address range, and supports a number of tests to check if two ran...">AddrRange</a> is also able to coalesce a number of interleaved ranges to a contiguous range. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00072">72</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad372696271d6544850b2f3fa11d1d42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad372696271d6544850b2f3fa11d1d42f">&#9670;&nbsp;</a></span>AddrRange() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddrRange::AddrRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00095">95</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00576">RangeEx()</a>, <a class="el" href="addr__range_8hh_source.html#l00580">RangeIn()</a>, and <a class="el" href="addr__range_8hh_source.html#l00584">RangeSize()</a>.</p>

</div>
</div>
<a id="a35290e06e9eca605fcd8c8517faa1b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35290e06e9eca605fcd8c8517faa1b53">&#9670;&nbsp;</a></span>AddrRange() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddrRange::AddrRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_masks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_intlv_match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an address range. </p>
<p>If the user provides a non empty vector of masks then the address range is interleaved. Each mask determines a set of bits that are xored to determine one bit of the sel value, starting from the least significant bit (i.e., masks[0] determines the least significant bit of sel, ...). If sel matches the provided _intlv_match then the address a is in the range.</p>
<p>For example if the input mask is _masks = { 1 &lt;&lt; 8 | 1 &lt;&lt; 11 | 1 &lt;&lt; 13, 1 &lt;&lt; 15 | 1 &lt;&lt; 17 | 1 &lt;&lt; 19}</p>
<p>Then a belongs to the address range if _start &lt;= a &lt; _end and sel == _intlv_match where sel[0] = a[8] ^ a[11] ^ a[13] sel[1] = a[15] ^ a[17] ^ a[19]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>The start address of this range </td></tr>
    <tr><td class="paramname">_end</td><td>The end address of this range (not included in the range) </td></tr>
    <tr><td class="paramname">_masks</td><td>The input vector of masks </td></tr>
    <tr><td class="paramname">intlv_match</td><td>The matching value of the xor operations </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00127">127</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="logging_8hh_source.html#l00203">fatal_if</a>, and <a class="el" href="base_2types_8hh_source.html#l00050">ULL</a>.</p>

</div>
</div>
<a id="a1a7113e7b46c40483d7c2800f1e31114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7113e7b46c40483d7c2800f1e31114">&#9670;&nbsp;</a></span>AddrRange() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddrRange::AddrRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_intlv_high_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_xor_high_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_intlv_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_intlv_match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Legacy constructor of <a class="el" href="classAddrRange.html" title="The AddrRange class encapsulates an address range, and supports a number of tests to check if two ran...">AddrRange</a>. </p>
<p>If the user provides a non-zero value in _intlv_high_bit the address range is interleaved.</p>
<p>An address a belongs to the address range if _start &lt;= a &lt; _end and sel == _intlv_match where sel = sel1 ^ sel2 sel1 = a[_intlv_low_bit:_intlv_high_bit] sel2 = a[_xor_low_bit:_xor_high_bit] _intlv_low_bit = _intlv_high_bit - intv_bits _xor_low_bit = _xor_high_bit - intv_bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>The start address of this range </td></tr>
    <tr><td class="paramname">_end</td><td>The end address of this range (not included in the range) </td></tr>
    <tr><td class="paramname">_intlv_high_bit</td><td>The MSB of the intlv bits (disabled if 0) </td></tr>
    <tr><td class="paramname">_xor_high_bit</td><td>The MSB of the xor bit (disabled if 0) </td></tr>
    <tr><td class="paramname">_intlv_bits</td><td>the size, in bits, of the intlv and xor bits </td></tr>
    <tr><td class="paramname">intlv_match</td><td>The matching value of the xor operations </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00162">162</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="logging_8hh_source.html#l00175">fatal</a>, <a class="el" href="logging_8hh_source.html#l00203">fatal_if</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="arch_2arm_2types_8hh_source.html#l00064">ArmISA::mask</a>, and <a class="el" href="base_2types_8hh_source.html#l00050">ULL</a>.</p>

</div>
</div>
<a id="ae84c848bd49e618e07c4738e12a18336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84c848bd49e618e07c4738e12a18336">&#9670;&nbsp;</a></span>AddrRange() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddrRange::AddrRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00200">200</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

</div>
</div>
<a id="a54f2bb673335fc89a784522cf66fa495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2bb673335fc89a784522cf66fa495">&#9670;&nbsp;</a></span>AddrRange() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddrRange::AddrRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAddrRange.html">AddrRange</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an address range by merging a collection of interleaved ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>Interleaved ranges to be merged </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00210">210</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="logging_8hh_source.html#l00175">fatal</a>, <a class="el" href="addr__range_8hh_source.html#l00337">mergesWith()</a>, <a class="el" href="mips_2pra__constants_8hh_source.html#l00097">MipsISA::r</a>, <a class="el" href="addr__range_8hh_source.html#l00309">to_string()</a>, and <a class="el" href="base_2types_8hh_source.html#l00050">ULL</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0137bf24c123f9653990267c94474ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0137bf24c123f9653990267c94474ae2">&#9670;&nbsp;</a></span>addIntlvBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::addIntlvBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds the interleaving bits removed by removeIntlvBits. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00479">479</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00065">ArmISA::a</a>, <a class="el" href="bitfield_8hh_source.html#l00072">bits()</a>, <a class="el" href="bitfield_8hh_source.html#l00309">ctz64()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="bitfield_8hh_source.html#l00132">insertBits()</a>, and <a class="el" href="bitfield_8hh_source.html#l00249">popCount()</a>.</p>

<p class="reference">Referenced by <a class="el" href="channel__addr_8hh_source.html#l00074">ChannelAddr::getPA()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00298">TEST()</a>.</p>

</div>
</div>
<a id="a615f684c623955389a18abc857dc885d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615f684c623955389a18abc857dc885d">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the range contains an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Address to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the address is in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00406">406</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="addr__range_8hh_source.html#l00091">intlvMatch</a>, <a class="el" href="bitfield_8hh_source.html#l00249">popCount()</a>, and <a class="el" href="miscregs__types_8hh_source.html#l00620">ArmISA::sel</a>.</p>

<p class="reference">Referenced by <a class="el" href="sim_2system_8cc_source.html#l00404">System::allocPhysPages()</a>, <a class="el" href="x86_2tlb_8cc_source.html#l00227">X86ISA::TLB::finalizePhysical()</a>, <a class="el" href="arm_2tlb_8cc_source.html#l00136">ArmISA::TLB::finalizePhysical()</a>, <a class="el" href="gic__v3_8cc_source.html#l00238">Gicv3::getRedistributorByAddr()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00072">TsunamiPChip::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00819">Gicv3Its::read()</a>, <a class="el" href="gic__v3__redistributor_8cc_source.html#l00090">Gicv3Redistributor::read()</a>, <a class="el" href="gic__v3__distributor_8cc_source.html#l00138">Gicv3Distributor::read()</a>, <a class="el" href="generic__timer_8cc_source.html#l00569">GenericTimerMem::read()</a>, <a class="el" href="gic__v2_8cc_source.html#l00113">GicV2::read()</a>, <a class="el" href="gic__v2_8cc_source.html#l00169">GicV2::readDistributor()</a>, <a class="el" href="tarmac__parser_8cc_source.html#l01185">Trace::TarmacParserRecord::readMemNoEffect()</a>, <a class="el" href="smmu__v3__ports_8cc_source.html#l00118">SMMUControlPort::recvAtomic()</a>, <a class="el" href="addr__range_8test_8cc_source.html#l00264">TEST()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00156">TsunamiPChip::write()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00893">Gicv3Its::write()</a>, <a class="el" href="gic__v3__redistributor_8cc_source.html#l00385">Gicv3Redistributor::write()</a>, <a class="el" href="gic__v3__distributor_8cc_source.html#l00507">Gicv3Distributor::write()</a>, <a class="el" href="generic__timer_8cc_source.html#l00598">GenericTimerMem::write()</a>, <a class="el" href="gic__v2_8cc_source.html#l00127">GicV2::write()</a>, and <a class="el" href="gic__v2_8cc_source.html#l00424">GicV2::writeDistributor()</a>.</p>

</div>
</div>
<a id="a6cece22cba00e263de3805a066b7e484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cece22cba00e263de3805a066b7e484">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the end address of the range. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00302">302</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>.</p>

<p class="reference">Referenced by <a class="el" href="tlm__to__gem5_8cc_source.html#l00329">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::get_direct_mem_ptr()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>.</p>

</div>
</div>
<a id="a690c198976af92db164edf679e35796f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690c198976af92db164edf679e35796f">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::getOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the offset of an address within the range. </p>
<p>This function returns the offset of the given address from the starting address discarding any bits that are used for interleaving. This way we can convert the input address to a new unique address in a continuous range that starts from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>input address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flat offset in the address range </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00524">524</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>, <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>, <a class="el" href="addr__range_8hh_source.html#l00250">interleaved()</a>, <a class="el" href="base_2types_8hh_source.html#l00166">MaxAddr</a>, and <a class="el" href="addr__range_8hh_source.html#l00449">removeIntlvBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="dram__ctrl_8hh_source.html#l00830">DRAMCtrl::getCtrlAddr()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00311">TEST()</a>.</p>

</div>
</div>
<a id="a2ca1f726dd151069e354a5e58c257067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca1f726dd151069e354a5e58c257067">&#9670;&nbsp;</a></span>granularity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t AddrRange::granularity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determing the interleaving granularity of the range. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the regions created by the interleaving bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00257">257</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="bitfield_8hh_source.html#l00309">ctz64()</a>, <a class="el" href="addr__range_8hh_source.html#l00250">interleaved()</a>, <a class="el" href="arch_2arm_2types_8hh_source.html#l00064">ArmISA::mask</a>, <a class="el" href="addr__range_8hh_source.html#l00284">size()</a>, and <a class="el" href="base_2types_8hh_source.html#l00050">ULL</a>.</p>

<p class="reference">Referenced by <a class="el" href="dram__ctrl_8cc_source.html#l00062">DRAMCtrl::DRAMCtrl()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00191">DRAMCtrl::init()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>.</p>

</div>
</div>
<a id="ab17cc11f25132b98646ec45bc782ac79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17cc11f25132b98646ec45bc782ac79">&#9670;&nbsp;</a></span>interleaved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::interleaved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the range is interleaved or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if interleaved </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00250">250</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="channel__addr_8cc_source.html#l00051">ChannelAddrRange::ChannelAddrRange()</a>, <a class="el" href="physical_8cc_source.html#l00185">PhysicalMemory::createBackingStore()</a>, <a class="el" href="vm_8cc_source.html#l00344">KvmVM::delayedStartup()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00062">DRAMCtrl::DRAMCtrl()</a>, <a class="el" href="addr__range_8hh_source.html#l00524">getOffset()</a>, <a class="el" href="addr__range_8hh_source.html#l00257">granularity()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00191">DRAMCtrl::init()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00080">AbstractMemory::setBackingStore()</a>, <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>, and <a class="el" href="addr__range_8hh_source.html#l00309">to_string()</a>.</p>

</div>
</div>
<a id="a3b0198d5a42763b54c292f0f71e2d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0198d5a42763b54c292f0f71e2d518">&#9670;&nbsp;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if another range intersects this one, i.e. </p>
<p>if there is an address that is both in this range and the other range. No check is made to ensure either range is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range to intersect with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the intersection of the two ranges is not empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00351">351</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>, <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>, <a class="el" href="addr__range_8hh_source.html#l00406">contains()</a>, <a class="el" href="addr__range_8hh_source.html#l00250">interleaved()</a>, <a class="el" href="addr__range_8hh_source.html#l00091">intlvMatch</a>, <a class="el" href="addr__range_8hh_source.html#l00337">mergesWith()</a>, <a class="el" href="logging_8hh_source.html#l00167">panic</a>, <a class="el" href="addr__range_8hh_source.html#l00284">size()</a>, <a class="el" href="addr__range_8hh_source.html#l00297">start()</a>, and <a class="el" href="addr__range_8hh_source.html#l00309">to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00124">AddrRangeMap&lt; AbstractMemory *, 1 &gt;::intersects()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00179">TEST()</a>.</p>

</div>
</div>
<a id="a20d0308cc22362862da6e41088a28da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d0308cc22362862da6e41088a28da6">&#9670;&nbsp;</a></span>isSubset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::isSubset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if this range is a subset of another range, i.e. </p>
<p>if every address in this range is also in the other range. No check is made to ensure either range is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the this range is a subset of the other one </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00383">383</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>, <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>, <a class="el" href="addr__range_8hh_source.html#l00406">contains()</a>, <a class="el" href="addr__range_8hh_source.html#l00257">granularity()</a>, <a class="el" href="addr__range_8hh_source.html#l00250">interleaved()</a>, <a class="el" href="logging_8hh_source.html#l00167">panic</a>, <a class="el" href="addr__range_8hh_source.html#l00284">size()</a>, and <a class="el" href="addr__range_8hh_source.html#l00309">to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00082">AddrRangeMap&lt; AbstractMemory *, 1 &gt;::contains()</a>, <a class="el" href="xbar_8cc_source.html#l00329">BaseXBar::findPort()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00228">TEST()</a>.</p>

</div>
</div>
<a id="a156c29b86dd467a5f5feb6d864126f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156c29b86dd467a5f5feb6d864126f5b">&#9670;&nbsp;</a></span>mergesWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::mergesWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if another range merges with the current one, i.e. </p>
<p>if they are part of the same contigous range and have the same interleaving bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range to evaluate merging with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two ranges would merge </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00337">337</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>, <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>, and <a class="el" href="addr__range_8hh_source.html#l00088">masks</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00210">AddrRange()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00157">TEST()</a>.</p>

</div>
</div>
<a id="a0a123905c608eb34fa0a53cd983e7bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a123905c608eb34fa0a53cd983e7bd8">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00564">564</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="mips_2pra__constants_8hh_source.html#l00097">MipsISA::r</a>.</p>

</div>
</div>
<a id="ac9d5d7e1369257272736687a003fd078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d5d7e1369257272736687a003fd078">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator used to turn an STL map into a binary search tree of non-overlapping address ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the start address is less than that of the other range </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00544">544</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>, and <a class="el" href="addr__range_8hh_source.html#l00091">intlvMatch</a>.</p>

</div>
</div>
<a id="a6cc5630188e3aceb5588a0944405a86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc5630188e3aceb5588a0944405a86a">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00554">554</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>, <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>, <a class="el" href="addr__range_8hh_source.html#l00091">intlvMatch</a>, and <a class="el" href="addr__range_8hh_source.html#l00088">masks</a>.</p>

</div>
</div>
<a id="a68af80f95fbcf8e0b0c539ddca8fa281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68af80f95fbcf8e0b0c539ddca8fa281">&#9670;&nbsp;</a></span>removeIntlvBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::removeIntlvBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the interleaving bits from an input address. </p>
<p>This function returns a new address in a continous range [ start, start + size / intlv_bits). We can achieve this by discarding the LSB in each mask.</p>
<h2>e.g., if the input address is of the form: </h2>
<h2>| a_high | x1 | a_mid | x0 | a_low | </h2>
<p>where x0 is the LSB set in masks[0] and x1 is the LSB set in masks[1]</p>
<h2>this function will return: </h2>
<h2>| 0 | a_high | a_mid | a_low | </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the input address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new address </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00449">449</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00065">ArmISA::a</a>, <a class="el" href="bitfield_8hh_source.html#l00309">ctz64()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, and <a class="el" href="bitfield_8hh_source.html#l00132">insertBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00524">getOffset()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00285">TEST()</a>.</p>

</div>
</div>
<a id="a8767320afd5f208677adc1d4087985ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8767320afd5f208677adc1d4087985ce">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the address range. </p>
<p>For a case where interleaving is used we make the simplifying assumption that the size is a divisible by the size of the interleaving slice. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00284">284</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="vm_8cc_source.html#l00458">KvmVM::coalesceMMIO()</a>, <a class="el" href="physical_8cc_source.html#l00185">PhysicalMemory::createBackingStore()</a>, <a class="el" href="vm_8cc_source.html#l00344">KvmVM::delayedStartup()</a>, <a class="el" href="addr__range_8hh_source.html#l00257">granularity()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, <a class="el" href="physical_8cc_source.html#l00326">PhysicalMemory::serializeStore()</a>, <a class="el" href="abstract__mem_8hh_source.html#l00278">AbstractMemory::size()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00056">SMMUv3::SMMUv3()</a>, <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>, and <a class="el" href="physical_8cc_source.html#l00397">PhysicalMemory::unserializeStore()</a>.</p>

</div>
</div>
<a id="a2fbc15c252cfd1299669febb874b9c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc15c252cfd1299669febb874b9c5e">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the start address of the range. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00297">297</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00080">_start</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="vm_8cc_source.html#l00458">KvmVM::coalesceMMIO()</a>, <a class="el" href="kvm_2gic_8cc_source.html#l00339">MuxingKvmGic::copyGicState()</a>, <a class="el" href="vm_8cc_source.html#l00344">KvmVM::delayedStartup()</a>, <a class="el" href="x86_2tlb_8cc_source.html#l00227">X86ISA::TLB::finalizePhysical()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00329">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::get_direct_mem_ptr()</a>, <a class="el" href="gic__v3_8cc_source.html#l00238">Gicv3::getRedistributorByAddr()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00072">TsunamiPChip::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00819">Gicv3Its::read()</a>, <a class="el" href="gic__v3__redistributor_8cc_source.html#l00090">Gicv3Redistributor::read()</a>, <a class="el" href="gic__v3__distributor_8cc_source.html#l00138">Gicv3Distributor::read()</a>, <a class="el" href="generic__timer_8cc_source.html#l00569">GenericTimerMem::read()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00582">SMMUv3::readControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00291">GicV2::readCpu()</a>, <a class="el" href="gic__v2_8cc_source.html#l00169">GicV2::readDistributor()</a>, <a class="el" href="abstract__mem_8hh_source.html#l00285">AbstractMemory::start()</a>, <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00156">TsunamiPChip::write()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00893">Gicv3Its::write()</a>, <a class="el" href="gic__v3__redistributor_8cc_source.html#l00385">Gicv3Redistributor::write()</a>, <a class="el" href="gic__v3__distributor_8cc_source.html#l00507">Gicv3Distributor::write()</a>, <a class="el" href="generic__timer_8cc_source.html#l00598">GenericTimerMem::write()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00615">SMMUv3::writeControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00558">GicV2::writeCpu()</a>, and <a class="el" href="gic__v2_8cc_source.html#l00424">GicV2::writeDistributor()</a>.</p>

</div>
</div>
<a id="a20a6881ab65288dd1b58bac4f7093068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a6881ab65288dd1b58bac4f7093068">&#9670;&nbsp;</a></span>stripes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t AddrRange::stripes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of interleaved address stripes this range is part of. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of stripes spanned by the interleaving bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00277">277</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="base_2types_8hh_source.html#l00050">ULL</a>.</p>

<p class="reference">Referenced by <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>.</p>

</div>
</div>
<a id="a84ed4842b0a3d3878bf2cc481fae0446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ed4842b0a3d3878bf2cc481fae0446">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AddrRange::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string representation of the range. </p>
<p>This could alternatively be implemented as a operator&lt;&lt;, but at the moment that seems like overkill. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00309">309</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="bitfield_8hh_source.html#l00072">bits()</a>, <a class="el" href="cprintf_8hh_source.html#l00162">csprintf()</a>, <a class="el" href="bitfield_8hh_source.html#l00309">ctz64()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="addr__range_8hh_source.html#l00250">interleaved()</a>, <a class="el" href="arch_2arm_2types_8hh_source.html#l00064">ArmISA::mask</a>, and <a class="el" href="base_2types_8hh_source.html#l00050">ULL</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00210">AddrRange()</a>, <a class="el" href="physical_8cc_source.html#l00185">PhysicalMemory::createBackingStore()</a>, <a class="el" href="xbar_8cc_source.html#l00329">BaseXBar::findPort()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00061">TEST()</a>.</p>

</div>
</div>
<a id="a74737639783ffb916bff83049b9f1067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74737639783ffb916bff83049b9f1067">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrRange::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the range is valid. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00292">292</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">References <a class="el" href="addr__range_8hh_source.html#l00081">_end</a>.</p>

<p class="reference">Referenced by <a class="el" href="channel__addr_8cc_source.html#l00044">ChannelAddrRange::ChannelAddrRange()</a>, <a class="el" href="python_2pybind11_2core_8cc_source.html#l00145">init_range()</a>, and <a class="el" href="addr__range_8test_8cc_source.html#l00049">TEST()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5578423da8b8279073c64bd448b0635d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5578423da8b8279073c64bd448b0635d">&#9670;&nbsp;</a></span>_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00081">81</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00406">contains()</a>, <a class="el" href="addr__range_8hh_source.html#l00302">end()</a>, <a class="el" href="addr__range_8hh_source.html#l00524">getOffset()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, <a class="el" href="addr__range_8hh_source.html#l00337">mergesWith()</a>, <a class="el" href="addr__range_8hh_source.html#l00554">operator==()</a>, and <a class="el" href="addr__range_8hh_source.html#l00292">valid()</a>.</p>

</div>
</div>
<a id="a70d7492915570f1ef85c694c74419c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d7492915570f1ef85c694c74419c3c">&#9670;&nbsp;</a></span>_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> AddrRange::_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private fields for the start and end of the range _start is the beginning of the range (inclusive). </p>
<p>_end is not part of the range. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00080">80</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00524">getOffset()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00383">isSubset()</a>, <a class="el" href="addr__range_8hh_source.html#l00337">mergesWith()</a>, <a class="el" href="addr__range_8hh_source.html#l00544">operator&lt;()</a>, <a class="el" href="addr__range_8hh_source.html#l00554">operator==()</a>, and <a class="el" href="addr__range_8hh_source.html#l00297">start()</a>.</p>

</div>
</div>
<a id="a73137889a4d61ca40bd9224e73f840c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73137889a4d61ca40bd9224e73f840c2">&#9670;&nbsp;</a></span>intlvMatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t AddrRange::intlvMatch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The value to compare sel with. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00091">91</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00406">contains()</a>, <a class="el" href="addr__range_8hh_source.html#l00351">intersects()</a>, <a class="el" href="addr__range_8hh_source.html#l00544">operator&lt;()</a>, and <a class="el" href="addr__range_8hh_source.html#l00554">operator==()</a>.</p>

</div>
</div>
<a id="af76045af8c3d4fdf9ecaeb4ab0ba2b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76045af8c3d4fdf9ecaeb4ab0ba2b79">&#9670;&nbsp;</a></span>masks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&gt; AddrRange::masks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each mask determines the bits we need to xor to get one bit of sel. </p>
<p>The first (0) mask is used to get the LSB and the last for the MSB of sel. </p>

<p class="definition">Definition at line <a class="el" href="addr__range_8hh_source.html#l00088">88</a> of file <a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="addr__range_8hh_source.html#l00337">mergesWith()</a>, and <a class="el" href="addr__range_8hh_source.html#l00554">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>base/<a class="el" href="addr__range_8hh_source.html">addr_range.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:13 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
