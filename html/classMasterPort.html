<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: MasterPort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMasterPort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MasterPort Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classMasterPort.html" title="A MasterPort is a specialisation of a BaseMasterPort, which implements the default protocol for the t...">MasterPort</a> is a specialisation of a BaseMasterPort, which implements the default protocol for the three different level of transport functions.  
 <a href="classMasterPort.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mem_2port_8hh_source.html">port.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MasterPort:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMasterPort.png" usemap="#MasterPort_map" alt=""/>
  <map id="MasterPort_map" name="MasterPort_map">
<area href="classPort.html" title="Ports are used to interface objects to each other. " alt="Port" shape="rect" coords="0,0,356,24"/>
<area href="classAtomicRequestProtocol.html" alt="AtomicRequestProtocol" shape="rect" coords="366,0,722,24"/>
<area href="classTimingRequestProtocol.html" alt="TimingRequestProtocol" shape="rect" coords="732,0,1088,24"/>
<area href="classFunctionalRequestProtocol.html" alt="FunctionalRequestProtocol" shape="rect" coords="1098,0,1454,24"/>
<area href="classAddrMapper_1_1MapperMasterPort.html" alt="AddrMapper::MapperMasterPort" shape="rect" coords="915,112,1271,136"/>
<area href="classAtomicSimpleCPU_1_1AtomicCPUPort.html" title="An AtomicCPUPort overrides the default behaviour of the recvAtomicSnoop and ignores the packet instea..." alt="AtomicSimpleCPU::AtomicCPUPort" shape="rect" coords="915,168,1271,192"/>
<area href="classBaseKvmCPU_1_1KVMCpuPort.html" title="KVM memory port. " alt="BaseKvmCPU::KVMCpuPort" shape="rect" coords="915,224,1271,248"/>
<area href="classBaseTrafficGen_1_1TrafficGenPort.html" title="Master port specialisation for the traffic generator. " alt="BaseTrafficGen::TrafficGenPort" shape="rect" coords="915,280,1271,304"/>
<area href="classBridge_1_1BridgeMasterPort.html" title="Port on the side that forwards requests and receives responses. " alt="Bridge::BridgeMasterPort" shape="rect" coords="915,336,1271,360"/>
<area href="classCoherentXBar_1_1CoherentXBarMasterPort.html" title="Declaration of the coherent crossbar master port type, one will be instantiated for each of the slave..." alt="CoherentXBar::CoherentXBarMasterPort" shape="rect" coords="915,392,1271,416"/>
<area href="classCoherentXBar_1_1SnoopRespPort.html" title="Internal class to bridge between an incoming snoop response from a slave port and forwarding it throu..." alt="CoherentXBar::SnoopRespPort" shape="rect" coords="915,448,1271,472"/>
<area href="classCommMonitor_1_1MonitorMasterPort.html" title="This is the master port of the communication monitor. " alt="CommMonitor::MonitorMasterPort" shape="rect" coords="915,504,1271,528"/>
<area href="classComputeUnit_1_1DataPort.html" title="Data access Port. " alt="ComputeUnit::DataPort" shape="rect" coords="915,560,1271,584"/>
<area href="classComputeUnit_1_1DTLBPort.html" title="Data TLB port. " alt="ComputeUnit::DTLBPort" shape="rect" coords="915,616,1271,640"/>
<area href="classComputeUnit_1_1ITLBPort.html" alt="ComputeUnit::ITLBPort" shape="rect" coords="915,672,1271,696"/>
<area href="classComputeUnit_1_1LDSPort.html" title="the port intended to communicate between the CU and its LDS " alt="ComputeUnit::LDSPort" shape="rect" coords="915,728,1271,752"/>
<area href="classComputeUnit_1_1SQCPort.html" alt="ComputeUnit::SQCPort" shape="rect" coords="915,784,1271,808"/>
<area href="classDefaultFetch_1_1IcachePort.html" title="IcachePort class for instruction fetch. " alt="DefaultFetch&lt; Impl &gt;::IcachePort" shape="rect" coords="915,840,1271,864"/>
<area href="classDmaPort.html" alt="DmaPort" shape="rect" coords="915,896,1271,920"/>
<area href="classExternalMaster_1_1ExternalPort.html" title="Derive from this class to create an external port interface. " alt="ExternalMaster::ExternalPort" shape="rect" coords="915,952,1271,976"/>
<area href="classGarnetSyntheticTraffic_1_1CpuPort.html" alt="GarnetSyntheticTraffic::CpuPort" shape="rect" coords="915,1008,1271,1032"/>
<area href="classGicv3Its_1_1DataPort.html" alt="Gicv3Its::DataPort" shape="rect" coords="915,1064,1271,1088"/>
<area href="classGpuDispatcher_1_1TLBPort.html" alt="GpuDispatcher::TLBPort" shape="rect" coords="915,1120,1271,1144"/>
<area href="classLSQ_1_1DcachePort.html" title="DcachePort class for the load/store queue. " alt="LSQ&lt; Impl &gt;::DcachePort" shape="rect" coords="915,1176,1271,1200"/>
<area href="classMemCheckerMonitor_1_1MonitorMasterPort.html" title="This is the master port of the communication monitor. " alt="MemCheckerMonitor::MonitorMasterPort" shape="rect" coords="915,1232,1271,1256"/>
<area href="classMemTest_1_1CpuPort.html" alt="MemTest::CpuPort" shape="rect" coords="915,1288,1271,1312"/>
<area href="classMinorCPU_1_1MinorCPUPort.html" title="Provide a non-protected base class for Minor&#39;s Ports as derived classes are created by Fetch1 and Exe..." alt="MinorCPU::MinorCPUPort" shape="rect" coords="915,1344,1271,1368"/>
<area href="classNoncoherentXBar_1_1NoncoherentXBarMasterPort.html" title="Declaration of the crossbar master port type, one will be instantiated for each of the slave ports co..." alt="NoncoherentXBar::NoncoherentXBarMasterPort" shape="rect" coords="915,1400,1271,1424"/>
<area href="classQueuedMasterPort.html" title="The QueuedMasterPort combines two queues, a request queue and a snoop response queue, that both share the same port. " alt="QueuedMasterPort" shape="rect" coords="915,1456,1271,1480"/>
<area href="classRubyDirectedTester_1_1CpuPort.html" alt="RubyDirectedTester::CpuPort" shape="rect" coords="915,1512,1271,1536"/>
<area href="classRubyTester_1_1CpuPort.html" alt="RubyTester::CpuPort" shape="rect" coords="915,1568,1271,1592"/>
<area href="classsc__gem5_1_1TlmToGem5Bridge_1_1BridgeMasterPort.html" alt="sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::BridgeMasterPort" shape="rect" coords="915,1624,1271,1648"/>
<area href="classSerialLink_1_1SerialLinkMasterPort.html" title="Port on the side that forwards requests and receives responses. " alt="SerialLink::SerialLinkMasterPort" shape="rect" coords="915,1680,1271,1704"/>
<area href="classSimpleCache_1_1MemSidePort.html" title="Port on the memory-side that receives responses. " alt="SimpleCache::MemSidePort" shape="rect" coords="915,1736,1271,1760"/>
<area href="classSimpleMemobj_1_1MemSidePort.html" title="Port on the memory-side that receives responses. " alt="SimpleMemobj::MemSidePort" shape="rect" coords="915,1792,1271,1816"/>
<area href="classSMMUMasterPort.html" alt="SMMUMasterPort" shape="rect" coords="915,1848,1271,1872"/>
<area href="classSMMUMasterTableWalkPort.html" alt="SMMUMasterTableWalkPort" shape="rect" coords="915,1904,1271,1928"/>
<area href="classSystem_1_1SystemPort.html" title="Private class for the system port which is only used as a master for debug access and for non-structu..." alt="System::SystemPort" shape="rect" coords="915,1960,1271,1984"/>
<area href="classTimingSimpleCPU_1_1TimingCPUPort.html" title="A TimingCPUPort overrides the default behaviour of the recvTiming and recvRetry and implements events..." alt="TimingSimpleCPU::TimingCPUPort" shape="rect" coords="915,2016,1271,2040"/>
<area href="classTLBCoalescer_1_1MemSidePort.html" alt="TLBCoalescer::MemSidePort" shape="rect" coords="915,2072,1271,2096"/>
<area href="classTraceCPU_1_1DcachePort.html" title="DcachePort class that interfaces with L1 Data Cache. " alt="TraceCPU::DcachePort" shape="rect" coords="915,2128,1271,2152"/>
<area href="classTraceCPU_1_1IcachePort.html" title="IcachePort class that interfaces with L1 Instruction Cache. " alt="TraceCPU::IcachePort" shape="rect" coords="915,2184,1271,2208"/>
<area href="classX86ISA_1_1GpuTLB_1_1MemSidePort.html" title="MemSidePort is the TLB Port closer to the memory side If this is a last level TLB then this port will..." alt="X86ISA::GpuTLB::MemSidePort" shape="rect" coords="915,2240,1271,2264"/>
<area href="classX86ISA_1_1Walker_1_1WalkerPort.html" alt="X86ISA::Walker::WalkerPort" shape="rect" coords="915,2296,1271,2320"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa77a3c536d8758e8c7a87df4edbc911d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#aa77a3c536d8758e8c7a87df4edbc911d">MasterPort</a> (const std::string &amp;<a class="el" href="classPort.html#a18a1938a97583fef5c9cb8433df30ceb">name</a>, <a class="el" href="classSimObject.html">SimObject</a> *_owner, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> <a class="el" href="classPort.html#a7c82cc7e44dc334a23940c81c75ea793">id</a>=<a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a>)</td></tr>
<tr class="memdesc:aa77a3c536d8758e8c7a87df4edbc911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master port.  <a href="#aa77a3c536d8758e8c7a87df4edbc911d">More...</a><br /></td></tr>
<tr class="separator:aa77a3c536d8758e8c7a87df4edbc911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c1b23aa0881cc8c6ebbc18b5e2a5f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a8c7c1b23aa0881cc8c6ebbc18b5e2a5f">~MasterPort</a> ()</td></tr>
<tr class="separator:a8c7c1b23aa0881cc8c6ebbc18b5e2a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ec9bb470cf9d1079c5a2a5a675022f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a89ec9bb470cf9d1079c5a2a5a675022f">bind</a> (<a class="el" href="classPort.html">Port</a> &amp;peer) override</td></tr>
<tr class="memdesc:a89ec9bb470cf9d1079c5a2a5a675022f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind this master port to a slave port.  <a href="#a89ec9bb470cf9d1079c5a2a5a675022f">More...</a><br /></td></tr>
<tr class="separator:a89ec9bb470cf9d1079c5a2a5a675022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3220e6f2fc9ddc8fb765cdb240ae97ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a3220e6f2fc9ddc8fb765cdb240ae97ff">unbind</a> () override</td></tr>
<tr class="memdesc:a3220e6f2fc9ddc8fb765cdb240ae97ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind this master port and the associated slave port.  <a href="#a3220e6f2fc9ddc8fb765cdb240ae97ff">More...</a><br /></td></tr>
<tr class="separator:a3220e6f2fc9ddc8fb765cdb240ae97ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0295ae8b58f763c91ab9a21a24c14081"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a0295ae8b58f763c91ab9a21a24c14081">isSnooping</a> () const</td></tr>
<tr class="memdesc:a0295ae8b58f763c91ab9a21a24c14081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this master port is snooping or not.  <a href="#a0295ae8b58f763c91ab9a21a24c14081">More...</a><br /></td></tr>
<tr class="separator:a0295ae8b58f763c91ab9a21a24c14081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd7795faacd9a15a08ea7f71c831931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="addr__range_8hh.html#a8f73751754cd29dbff43400e751325c0">AddrRangeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#affd7795faacd9a15a08ea7f71c831931">getAddrRanges</a> () const</td></tr>
<tr class="memdesc:affd7795faacd9a15a08ea7f71c831931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address ranges of the connected slave port.  <a href="#affd7795faacd9a15a08ea7f71c831931">More...</a><br /></td></tr>
<tr class="separator:affd7795faacd9a15a08ea7f71c831931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2391066114d659ce6e6b79b05692552f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a2391066114d659ce6e6b79b05692552f">printAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="fiber_8test_8cc.html#a7ebe9f480adf0a119babe1c0ea50d96a">a</a>)</td></tr>
<tr class="memdesc:a2391066114d659ce6e6b79b05692552f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a PrintReq for the given address to print the state of that address throughout the memory system.  <a href="#a2391066114d659ce6e6b79b05692552f">More...</a><br /></td></tr>
<tr class="separator:a2391066114d659ce6e6b79b05692552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444096e9902c823aa36ce5b3fa847fe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a444096e9902c823aa36ce5b3fa847fe5">sendAtomic</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a444096e9902c823aa36ce5b3fa847fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an atomic request packet, where the data is moved and the state is updated in zero time, without interleaving with other memory accesses.  <a href="#a444096e9902c823aa36ce5b3fa847fe5">More...</a><br /></td></tr>
<tr class="separator:a444096e9902c823aa36ce5b3fa847fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b67ff731653d9b58b556a89792e51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a75b67ff731653d9b58b556a89792e51d">sendAtomicBackdoor</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt, <a class="el" href="mem_2backdoor_8hh.html#a658934db0b23ac4ef1b8978c03afc0fb">MemBackdoorPtr</a> &amp;backdoor)</td></tr>
<tr class="memdesc:a75b67ff731653d9b58b556a89792e51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an atomic request packet like above, but also request a backdoor to the data being accessed.  <a href="#a75b67ff731653d9b58b556a89792e51d">More...</a><br /></td></tr>
<tr class="separator:a75b67ff731653d9b58b556a89792e51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84190aa477270de3be5e87506f7103eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a84190aa477270de3be5e87506f7103eb">sendFunctional</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) const</td></tr>
<tr class="memdesc:a84190aa477270de3be5e87506f7103eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a functional request packet, where the data is instantly updated everywhere in the memory system, without affecting the current state of any block or moving the block.  <a href="#a84190aa477270de3be5e87506f7103eb">More...</a><br /></td></tr>
<tr class="separator:a84190aa477270de3be5e87506f7103eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba350c337376f074a37507d6018bec3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#acba350c337376f074a37507d6018bec3">sendTimingReq</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:acba350c337376f074a37507d6018bec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to send a timing request to the slave port by calling its corresponding receive function.  <a href="#acba350c337376f074a37507d6018bec3">More...</a><br /></td></tr>
<tr class="separator:acba350c337376f074a37507d6018bec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987c8bce748766ffaab64bf9a7c3d98b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a987c8bce748766ffaab64bf9a7c3d98b">tryTiming</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) const</td></tr>
<tr class="memdesc:a987c8bce748766ffaab64bf9a7c3d98b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if the slave can handle a timing request.  <a href="#a987c8bce748766ffaab64bf9a7c3d98b">More...</a><br /></td></tr>
<tr class="separator:a987c8bce748766ffaab64bf9a7c3d98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fd4c4633f60b489f024288ecce4248"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a86fd4c4633f60b489f024288ecce4248">sendTimingSnoopResp</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a86fd4c4633f60b489f024288ecce4248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to send a timing snoop response packet to the slave port by calling its corresponding receive function.  <a href="#a86fd4c4633f60b489f024288ecce4248">More...</a><br /></td></tr>
<tr class="separator:a86fd4c4633f60b489f024288ecce4248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b0f70300a96e61ac88bc186ed6f1d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a66b0f70300a96e61ac88bc186ed6f1d2">sendRetryResp</a> ()</td></tr>
<tr class="memdesc:a66b0f70300a96e61ac88bc186ed6f1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a retry to the slave port that previously attempted a sendTimingResp to this master port and failed.  <a href="#a66b0f70300a96e61ac88bc186ed6f1d2">More...</a><br /></td></tr>
<tr class="separator:a66b0f70300a96e61ac88bc186ed6f1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPort"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPort')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPort.html">Port</a></td></tr>
<tr class="memitem:a9cd77776b50963679fbd3a6c4ec793ea inherit pub_methods_classPort"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPort.html">Port</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#a9cd77776b50963679fbd3a6c4ec793ea">getPeer</a> ()</td></tr>
<tr class="memdesc:a9cd77776b50963679fbd3a6c4ec793ea inherit pub_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this port's peer.  <a href="classPort.html#a9cd77776b50963679fbd3a6c4ec793ea">More...</a><br /></td></tr>
<tr class="separator:a9cd77776b50963679fbd3a6c4ec793ea inherit pub_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a1938a97583fef5c9cb8433df30ceb inherit pub_methods_classPort"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#a18a1938a97583fef5c9cb8433df30ceb">name</a> () const</td></tr>
<tr class="memdesc:a18a1938a97583fef5c9cb8433df30ceb inherit pub_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return port name (for DPRINTF).  <a href="classPort.html#a18a1938a97583fef5c9cb8433df30ceb">More...</a><br /></td></tr>
<tr class="separator:a18a1938a97583fef5c9cb8433df30ceb inherit pub_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea0ad30739559956a718616afa21613 inherit pub_methods_classPort"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#abea0ad30739559956a718616afa21613">getId</a> () const</td></tr>
<tr class="memdesc:abea0ad30739559956a718616afa21613 inherit pub_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the port id.  <a href="classPort.html#abea0ad30739559956a718616afa21613">More...</a><br /></td></tr>
<tr class="separator:abea0ad30739559956a718616afa21613 inherit pub_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6e9cd272a3a45c147cae34067f5e77 inherit pub_methods_classPort"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#a7a6e9cd272a3a45c147cae34067f5e77">isConnected</a> () const</td></tr>
<tr class="memdesc:a7a6e9cd272a3a45c147cae34067f5e77 inherit pub_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this port currently connected to a peer?  <a href="classPort.html#a7a6e9cd272a3a45c147cae34067f5e77">More...</a><br /></td></tr>
<tr class="separator:a7a6e9cd272a3a45c147cae34067f5e77 inherit pub_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c94a47998c9e7d2fab75f79682ffc16 inherit pub_methods_classPort"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#a8c94a47998c9e7d2fab75f79682ffc16">takeOverFrom</a> (<a class="el" href="classPort.html">Port</a> *old)</td></tr>
<tr class="memdesc:a8c94a47998c9e7d2fab75f79682ffc16 inherit pub_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to make it easier to swap out ports.  <a href="classPort.html#a8c94a47998c9e7d2fab75f79682ffc16">More...</a><br /></td></tr>
<tr class="separator:a8c94a47998c9e7d2fab75f79682ffc16 inherit pub_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a94ac09de72403a87c559ca5e7f8745b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a94ac09de72403a87c559ca5e7f8745b9">recvRangeChange</a> ()</td></tr>
<tr class="memdesc:a94ac09de72403a87c559ca5e7f8745b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to receive an address range change from the peer slave port.  <a href="#a94ac09de72403a87c559ca5e7f8745b9">More...</a><br /></td></tr>
<tr class="separator:a94ac09de72403a87c559ca5e7f8745b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af19d618fc96fe49a99f5f948502bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#ae9af19d618fc96fe49a99f5f948502bf">recvAtomicSnoop</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) override</td></tr>
<tr class="memdesc:ae9af19d618fc96fe49a99f5f948502bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementations.  <a href="#ae9af19d618fc96fe49a99f5f948502bf">More...</a><br /></td></tr>
<tr class="separator:ae9af19d618fc96fe49a99f5f948502bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8048eb710c0780a769ebc674976439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a8a8048eb710c0780a769ebc674976439">recvFunctionalSnoop</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) override</td></tr>
<tr class="memdesc:a8a8048eb710c0780a769ebc674976439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a functional snoop request packet from the peer.  <a href="#a8a8048eb710c0780a769ebc674976439">More...</a><br /></td></tr>
<tr class="separator:a8a8048eb710c0780a769ebc674976439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325b01a8c364e966a16623fdb9bdcfc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a325b01a8c364e966a16623fdb9bdcfc7">recvTimingSnoopReq</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) override</td></tr>
<tr class="memdesc:a325b01a8c364e966a16623fdb9bdcfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a timing snoop request from the peer.  <a href="#a325b01a8c364e966a16623fdb9bdcfc7">More...</a><br /></td></tr>
<tr class="separator:a325b01a8c364e966a16623fdb9bdcfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff72389488ee1c2ca924afc07f21933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a2ff72389488ee1c2ca924afc07f21933">recvRetrySnoopResp</a> () override</td></tr>
<tr class="memdesc:a2ff72389488ee1c2ca924afc07f21933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the peer if sendTimingSnoopResp was called on this protocol (causing recvTimingSnoopResp to be called on the peer) and was unsuccessful.  <a href="#a2ff72389488ee1c2ca924afc07f21933">More...</a><br /></td></tr>
<tr class="separator:a2ff72389488ee1c2ca924afc07f21933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPort"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPort')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPort.html">Port</a></td></tr>
<tr class="memitem:a363c67535d5fd17e37c23ec2554f0a8f inherit pro_methods_classPort"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#a363c67535d5fd17e37c23ec2554f0a8f">Port</a> (const std::string &amp;_name, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> _id)</td></tr>
<tr class="memdesc:a363c67535d5fd17e37c23ec2554f0a8f inherit pro_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for ports.  <a href="classPort.html#a363c67535d5fd17e37c23ec2554f0a8f">More...</a><br /></td></tr>
<tr class="separator:a363c67535d5fd17e37c23ec2554f0a8f inherit pro_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe166c2a6b10ad34d47472a150366bc1 inherit pro_methods_classPort"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#afe166c2a6b10ad34d47472a150366bc1">~Port</a> ()</td></tr>
<tr class="memdesc:afe166c2a6b10ad34d47472a150366bc1 inherit pro_methods_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor due to inheritance.  <a href="classPort.html#afe166c2a6b10ad34d47472a150366bc1">More...</a><br /></td></tr>
<tr class="separator:afe166c2a6b10ad34d47472a150366bc1 inherit pro_methods_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classAtomicRequestProtocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classAtomicRequestProtocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classAtomicRequestProtocol.html">AtomicRequestProtocol</a></td></tr>
<tr class="memitem:a14d03a50c4ad6322e10822f4f3042fb1 inherit pro_methods_classAtomicRequestProtocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicRequestProtocol.html#a14d03a50c4ad6322e10822f4f3042fb1">send</a> (<a class="el" href="classAtomicResponseProtocol.html">AtomicResponseProtocol</a> *peer, <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a14d03a50c4ad6322e10822f4f3042fb1 inherit pro_methods_classAtomicRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an atomic request packet, where the data is moved and the state is updated in zero time, without interleaving with other memory accesses.  <a href="classAtomicRequestProtocol.html#a14d03a50c4ad6322e10822f4f3042fb1">More...</a><br /></td></tr>
<tr class="separator:a14d03a50c4ad6322e10822f4f3042fb1 inherit pro_methods_classAtomicRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f9728215408e5824a12a4274b24027 inherit pro_methods_classAtomicRequestProtocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicRequestProtocol.html#a18f9728215408e5824a12a4274b24027">sendBackdoor</a> (<a class="el" href="classAtomicResponseProtocol.html">AtomicResponseProtocol</a> *peer, <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt, <a class="el" href="mem_2backdoor_8hh.html#a658934db0b23ac4ef1b8978c03afc0fb">MemBackdoorPtr</a> &amp;backdoor)</td></tr>
<tr class="memdesc:a18f9728215408e5824a12a4274b24027 inherit pro_methods_classAtomicRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an atomic request packet like above, but also request a backdoor to the data being accessed.  <a href="classAtomicRequestProtocol.html#a18f9728215408e5824a12a4274b24027">More...</a><br /></td></tr>
<tr class="separator:a18f9728215408e5824a12a4274b24027 inherit pro_methods_classAtomicRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classTimingRequestProtocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classTimingRequestProtocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classTimingRequestProtocol.html">TimingRequestProtocol</a></td></tr>
<tr class="memitem:ac7657f7a68b41b8e2fcfe283f7b11c28 inherit pro_methods_classTimingRequestProtocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimingRequestProtocol.html#ac7657f7a68b41b8e2fcfe283f7b11c28">sendReq</a> (<a class="el" href="classTimingResponseProtocol.html">TimingResponseProtocol</a> *peer, <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:ac7657f7a68b41b8e2fcfe283f7b11c28 inherit pro_methods_classTimingRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to send a timing request to the peer by calling its corresponding receive function.  <a href="classTimingRequestProtocol.html#ac7657f7a68b41b8e2fcfe283f7b11c28">More...</a><br /></td></tr>
<tr class="separator:ac7657f7a68b41b8e2fcfe283f7b11c28 inherit pro_methods_classTimingRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3075ce50f385823a9c30067dbf5068d inherit pro_methods_classTimingRequestProtocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimingRequestProtocol.html#ac3075ce50f385823a9c30067dbf5068d">trySend</a> (<a class="el" href="classTimingResponseProtocol.html">TimingResponseProtocol</a> *peer, <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) const</td></tr>
<tr class="memdesc:ac3075ce50f385823a9c30067dbf5068d inherit pro_methods_classTimingRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if the peer can handle a timing request.  <a href="classTimingRequestProtocol.html#ac3075ce50f385823a9c30067dbf5068d">More...</a><br /></td></tr>
<tr class="separator:ac3075ce50f385823a9c30067dbf5068d inherit pro_methods_classTimingRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aecb5f677025a399439ba44f5ea4ccd inherit pro_methods_classTimingRequestProtocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimingRequestProtocol.html#a3aecb5f677025a399439ba44f5ea4ccd">sendSnoopResp</a> (<a class="el" href="classTimingResponseProtocol.html">TimingResponseProtocol</a> *peer, <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a3aecb5f677025a399439ba44f5ea4ccd inherit pro_methods_classTimingRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to send a timing snoop response packet to it's peer by calling its corresponding receive function.  <a href="classTimingRequestProtocol.html#a3aecb5f677025a399439ba44f5ea4ccd">More...</a><br /></td></tr>
<tr class="separator:a3aecb5f677025a399439ba44f5ea4ccd inherit pro_methods_classTimingRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bca0b3c3671ffa9a84fd26799f5bd00 inherit pro_methods_classTimingRequestProtocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimingRequestProtocol.html#a7bca0b3c3671ffa9a84fd26799f5bd00">sendRetryResp</a> (<a class="el" href="classTimingResponseProtocol.html">TimingResponseProtocol</a> *peer)</td></tr>
<tr class="memdesc:a7bca0b3c3671ffa9a84fd26799f5bd00 inherit pro_methods_classTimingRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a retry to the peer that previously attempted a sendTimingResp to this protocol and failed.  <a href="classTimingRequestProtocol.html#a7bca0b3c3671ffa9a84fd26799f5bd00">More...</a><br /></td></tr>
<tr class="separator:a7bca0b3c3671ffa9a84fd26799f5bd00 inherit pro_methods_classTimingRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881d776b75086df75315e605298f2d04 inherit pro_methods_classTimingRequestProtocol"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimingRequestProtocol.html#a881d776b75086df75315e605298f2d04">recvTimingResp</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)=0</td></tr>
<tr class="memdesc:a881d776b75086df75315e605298f2d04 inherit pro_methods_classTimingRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a timing response from the peer.  <a href="classTimingRequestProtocol.html#a881d776b75086df75315e605298f2d04">More...</a><br /></td></tr>
<tr class="separator:a881d776b75086df75315e605298f2d04 inherit pro_methods_classTimingRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacee288dae92018b738bb82c57410be7 inherit pro_methods_classTimingRequestProtocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimingRequestProtocol.html#aacee288dae92018b738bb82c57410be7">recvReqRetry</a> ()=0</td></tr>
<tr class="memdesc:aacee288dae92018b738bb82c57410be7 inherit pro_methods_classTimingRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the peer if sendTimingReq was called on this peer (causing recvTimingReq to be called on the peer) and was unsuccessful.  <a href="classTimingRequestProtocol.html#aacee288dae92018b738bb82c57410be7">More...</a><br /></td></tr>
<tr class="separator:aacee288dae92018b738bb82c57410be7 inherit pro_methods_classTimingRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classFunctionalRequestProtocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFunctionalRequestProtocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFunctionalRequestProtocol.html">FunctionalRequestProtocol</a></td></tr>
<tr class="memitem:a3fe3ef70cc35cf63fb7399ce9f3d227f inherit pro_methods_classFunctionalRequestProtocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionalRequestProtocol.html#a3fe3ef70cc35cf63fb7399ce9f3d227f">send</a> (<a class="el" href="classFunctionalResponseProtocol.html">FunctionalResponseProtocol</a> *peer, <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) const</td></tr>
<tr class="memdesc:a3fe3ef70cc35cf63fb7399ce9f3d227f inherit pro_methods_classFunctionalRequestProtocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a functional request packet, where the data is instantly updated everywhere in the memory system, without affecting the current state of any block or moving the block.  <a href="classFunctionalRequestProtocol.html#a3fe3ef70cc35cf63fb7399ce9f3d227f">More...</a><br /></td></tr>
<tr class="separator:a3fe3ef70cc35cf63fb7399ce9f3d227f inherit pro_methods_classFunctionalRequestProtocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a94fa49941f41ad161da6144b5eae0135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimObject.html">SimObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a94fa49941f41ad161da6144b5eae0135">owner</a></td></tr>
<tr class="separator:a94fa49941f41ad161da6144b5eae0135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classPort"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classPort')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classPort.html">Port</a></td></tr>
<tr class="memitem:a7c82cc7e44dc334a23940c81c75ea793 inherit pro_attribs_classPort"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#a7c82cc7e44dc334a23940c81c75ea793">id</a></td></tr>
<tr class="memdesc:a7c82cc7e44dc334a23940c81c75ea793 inherit pro_attribs_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">A numeric identifier to distinguish ports in a vector, and set to InvalidPortID in case this port is not part of a vector.  <a href="classPort.html#a7c82cc7e44dc334a23940c81c75ea793">More...</a><br /></td></tr>
<tr class="separator:a7c82cc7e44dc334a23940c81c75ea793 inherit pro_attribs_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ee58de07bbc4cc531f79ee00ee7804 inherit pro_attribs_classPort"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPort.html">Port</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#ad5ee58de07bbc4cc531f79ee00ee7804">_peer</a></td></tr>
<tr class="memdesc:ad5ee58de07bbc4cc531f79ee00ee7804 inherit pro_attribs_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to this port's peer.  <a href="classPort.html#ad5ee58de07bbc4cc531f79ee00ee7804">More...</a><br /></td></tr>
<tr class="separator:ad5ee58de07bbc4cc531f79ee00ee7804 inherit pro_attribs_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5efcb781af12a3252b5b79bdcb55a1c inherit pro_attribs_classPort"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPort.html#ab5efcb781af12a3252b5b79bdcb55a1c">_connected</a></td></tr>
<tr class="memdesc:ab5efcb781af12a3252b5b79bdcb55a1c inherit pro_attribs_classPort"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this port is currently connected to a peer port.  <a href="classPort.html#ab5efcb781af12a3252b5b79bdcb55a1c">More...</a><br /></td></tr>
<tr class="separator:ab5efcb781af12a3252b5b79bdcb55a1c inherit pro_attribs_classPort"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a805c6d3c90bef6de1c35b72d21ab578c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSlavePort.html">SlavePort</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a805c6d3c90bef6de1c35b72d21ab578c">_slavePort</a></td></tr>
<tr class="separator:a805c6d3c90bef6de1c35b72d21ab578c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5344d902f61e69b03cd4d737c6375ce3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a5344d902f61e69b03cd4d737c6375ce3">SlavePort</a></td></tr>
<tr class="separator:a5344d902f61e69b03cd4d737c6375ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classMasterPort.html" title="A MasterPort is a specialisation of a BaseMasterPort, which implements the default protocol for the t...">MasterPort</a> is a specialisation of a BaseMasterPort, which implements the default protocol for the three different level of transport functions. </p>
<p>In addition to the basic functionality of sending packets, it also has functions to receive range changes or determine if the port is snooping or not.</p>
<p>The three protocols are atomic, timing, and functional, each with its own header file. </p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00075">75</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa77a3c536d8758e8c7a87df4edbc911d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77a3c536d8758e8c7a87df4edbc911d">&#9670;&nbsp;</a></span>MasterPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MasterPort::MasterPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimObject.html">SimObject</a> *&#160;</td>
          <td class="paramname"><em>_owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code><a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master port. </p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8cc_source.html#l00057">57</a> of file <a class="el" href="mem_2port_8cc_source.html">port.cc</a>.</p>

</div>
</div>
<a id="a8c7c1b23aa0881cc8c6ebbc18b5e2a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7c1b23aa0881cc8c6ebbc18b5e2a5f">&#9670;&nbsp;</a></span>~MasterPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MasterPort::~MasterPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mem_2port_8cc_source.html#l00062">62</a> of file <a class="el" href="mem_2port_8cc_source.html">port.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a89ec9bb470cf9d1079c5a2a5a675022f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ec9bb470cf9d1079c5a2a5a675022f">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPort.html">Port</a> &amp;&#160;</td>
          <td class="paramname"><em>peer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind this master port to a slave port. </p>
<p>This also does the mirror action and binds the slave port to the master port. </p>

<p>Reimplemented from <a class="el" href="classPort.html#a82776a5f2223d95dd3b0d08a3a17f391">Port</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8cc_source.html#l00067">67</a> of file <a class="el" href="mem_2port_8cc_source.html">port.cc</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, <a class="el" href="sim_2port_8hh_source.html#l00113">Port::bind()</a>, <a class="el" href="logging_8hh_source.html#l00175">fatal</a>, and <a class="el" href="sim_2port_8hh_source.html#l00106">Port::name()</a>.</p>

</div>
</div>
<a id="affd7795faacd9a15a08ea7f71c831931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd7795faacd9a15a08ea7f71c831931">&#9670;&nbsp;</a></span>getAddrRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="addr__range_8hh.html#a8f73751754cd29dbff43400e751325c0">AddrRangeList</a> MasterPort::getAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address ranges of the connected slave port. </p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8cc_source.html#l00093">93</a> of file <a class="el" href="mem_2port_8cc_source.html">port.cc</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="classSlavePort.html#a386ca95075ecafda88eaccaf8e0e3d81">SlavePort::getAddrRanges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem__delay_8hh_source.html#l00113">MemDelay::SlavePort::getAddrRanges()</a>, <a class="el" href="simple__memobj_8cc_source.html#l00219">SimpleMemobj::getAddrRanges()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00342">MemCheckerMonitor::getAddrRanges()</a>, <a class="el" href="simple__cache_8cc_source.html#l00411">SimpleCache::getAddrRanges()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00487">CommMonitor::getAddrRanges()</a>, <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="RubyPort_8hh_source.html#l00132">RubyPort::PioSlavePort::recvFunctional()</a>, and <a class="el" href="mem_2port_8hh_source.html#l00286">SlavePort::sendRangeChange()</a>.</p>

</div>
</div>
<a id="a0295ae8b58f763c91ab9a21a24c14081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0295ae8b58f763c91ab9a21a24c14081">&#9670;&nbsp;</a></span>isSnooping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MasterPort::isSnooping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if this master port is snooping or not. </p>
<p>The default implementation returns false and thus tells the neighbour we are not snooping. Any master port that wants to receive snoop requests (e.g. a cache connected to a bus) has to override this function.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the port should be considered a snooper </dd></dl>

<p>Reimplemented in <a class="el" href="classTraceCPU_1_1DcachePort.html#a2b81d6d9d0d51a550288b963ffac156c">TraceCPU::DcachePort</a>, <a class="el" href="classTimingSimpleCPU_1_1DcachePort.html#aeaa85bb4249aed84ede3aaa84167c770">TimingSimpleCPU::DcachePort</a>, <a class="el" href="classCoherentXBar_1_1CoherentXBarMasterPort.html#a874b74e77926d215c69e8a6fcc80e94f">CoherentXBar::CoherentXBarMasterPort</a>, <a class="el" href="classLSQ_1_1DcachePort.html#abebf3f0eaeb3874cc318cad2b812140e">LSQ&lt; Impl &gt;::DcachePort</a>, <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a05fef9a0aac4a7adb5b1b688d9cbbc80">CommMonitor::MonitorMasterPort</a>, <a class="el" href="classBaseCache_1_1CacheMasterPort.html#a33f15107180b0c87ab085217ad15a01b">BaseCache::CacheMasterPort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html#a9d55cb227ad4efd4dbf6e75d2eaa574f">AtomicSimpleCPU::AtomicCPUDPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#ac1f7d5571193225597631b0bad1d5289">AddrMapper::MapperMasterPort</a>, <a class="el" href="classMemCheckerMonitor_1_1MonitorMasterPort.html#a6e803ed4853422cb3248025920390a9c">MemCheckerMonitor::MonitorMasterPort</a>, <a class="el" href="classMinor_1_1LSQ_1_1DcachePort.html#a7420e2c0073f61574fff59b3c925199f">Minor::LSQ::DcachePort</a>, and <a class="el" href="classMemDelay_1_1MasterPort.html#a08987ab79816994da585f519aa693f10">MemDelay::MasterPort</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00111">111</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00065">ArmISA::a</a>, <a class="el" href="mem_2port_8cc_source.html#l00093">getAddrRanges()</a>, <a class="el" href="mem_2port_8cc_source.html#l00099">printAddr()</a>, <a class="el" href="mem_2port_8hh_source.html#l00427">sendAtomic()</a>, <a class="el" href="mem_2port_8hh_source.html#l00433">sendAtomicBackdoor()</a>, <a class="el" href="mem_2port_8hh_source.html#l00439">sendFunctional()</a>, <a class="el" href="mem_2port_8hh_source.html#l00463">sendRetryResp()</a>, <a class="el" href="mem_2port_8hh_source.html#l00445">sendTimingReq()</a>, <a class="el" href="mem_2port_8hh_source.html#l00457">sendTimingSnoopResp()</a>, and <a class="el" href="mem_2port_8hh_source.html#l00451">tryTiming()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8hh_source.html#l00280">SlavePort::isSnooping()</a>.</p>

</div>
</div>
<a id="a2391066114d659ce6e6b79b05692552f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2391066114d659ce6e6b79b05692552f">&#9670;&nbsp;</a></span>printAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::printAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject a PrintReq for the given address to print the state of that address throughout the memory system. </p>
<p>For debugging. </p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8cc_source.html#l00099">99</a> of file <a class="el" href="mem_2port_8cc_source.html">port.cc</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00065">ArmISA::a</a>, <a class="el" href="request_8hh_source.html#l00217">Request::funcMasterId</a>, <a class="el" href="packet_8hh_source.html#l00133">MemCmd::PrintReq</a>, and <a class="el" href="mem_2port_8hh_source.html#l00439">sendFunctional()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2atomic_8hh_source.html#l00180">AtomicSimpleCPU::getInstPort()</a>, <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="GarnetSyntheticTraffic_8cc_source.html#l00347">GarnetSyntheticTraffic::printAddr()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00781">AtomicSimpleCPU::printAddr()</a>, and <a class="el" href="cpu_2simple_2timing_8cc_source.html#l01068">TimingSimpleCPU::printAddr()</a>.</p>

</div>
</div>
<a id="ae9af19d618fc96fe49a99f5f948502bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9af19d618fc96fe49a99f5f948502bf">&#9670;&nbsp;</a></span>recvAtomicSnoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> MasterPort::recvAtomicSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementations. </p>

<p>Implements <a class="el" href="classAtomicRequestProtocol.html#a06f8c3da1464bc9ddb4065733626d16a">AtomicRequestProtocol</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00224">224</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="sim_2port_8hh_source.html#l00106">Port::name()</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8hh_source.html#l00408">BaseCache::allocOnFill()</a>.</p>

</div>
</div>
<a id="a8a8048eb710c0780a769ebc674976439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8048eb710c0780a769ebc674976439">&#9670;&nbsp;</a></span>recvFunctionalSnoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::recvFunctionalSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a functional snoop request packet from the peer. </p>

<p>Implements <a class="el" href="classFunctionalRequestProtocol.html#a9a8c6e95eabedf842f83bda35e1bebe7">FunctionalRequestProtocol</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00231">231</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="sim_2port_8hh_source.html#l00106">Port::name()</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

</div>
</div>
<a id="a94ac09de72403a87c559ca5e7f8745b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ac09de72403a87c559ca5e7f8745b9">&#9670;&nbsp;</a></span>recvRangeChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MasterPort::recvRangeChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called to receive an address range change from the peer slave port. </p>
<p>The default implementation ignores the change and does nothing. Override this function in a derived class if the owner needs to be aware of the address ranges, e.g. in an interconnect component like a bus. </p>

<p>Reimplemented in <a class="el" href="classComputeUnit_1_1LDSPort.html#a04726be0c8ca6649f87b0a87966c0cdb">ComputeUnit::LDSPort</a>, <a class="el" href="classComputeUnit_1_1ITLBPort.html#af87fcf6ca28d90379311a9c74ee3001e">ComputeUnit::ITLBPort</a>, <a class="el" href="classComputeUnit_1_1DTLBPort.html#a0ed4e66595b1f7f867371da1367f7aae">ComputeUnit::DTLBPort</a>, <a class="el" href="classComputeUnit_1_1SQCPort.html#a87573f89a4378b25057dee79448089e3">ComputeUnit::SQCPort</a>, <a class="el" href="classComputeUnit_1_1DataPort.html#a7f50a73a58c1cc55b77eb71b4b705754">ComputeUnit::DataPort</a>, <a class="el" href="classX86ISA_1_1GpuTLB_1_1MemSidePort.html#ae4cb4b0cfa0f5c69096347133475f18b">X86ISA::GpuTLB::MemSidePort</a>, <a class="el" href="classCoherentXBar_1_1CoherentXBarMasterPort.html#aaa3e79a20aa7f32279728dfaccd3a94c">CoherentXBar::CoherentXBarMasterPort</a>, <a class="el" href="classTLBCoalescer_1_1MemSidePort.html#a54762f290b94e7042b14f82f43dfe88f">TLBCoalescer::MemSidePort</a>, <a class="el" href="classSimpleCache_1_1MemSidePort.html#abfe26c61d94a6f242332b2c18a3a0bb3">SimpleCache::MemSidePort</a>, <a class="el" href="classSimpleMemobj_1_1MemSidePort.html#a27790b9c33b7a17b31f05e486c401838">SimpleMemobj::MemSidePort</a>, <a class="el" href="classNoncoherentXBar_1_1NoncoherentXBarMasterPort.html#a6f476033a89024a158baba445bf77188">NoncoherentXBar::NoncoherentXBarMasterPort</a>, <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a882452edf8ac70a824766d54f54ba204">CommMonitor::MonitorMasterPort</a>, <a class="el" href="classGpuDispatcher_1_1TLBPort.html#a9ddd8c6cacf62349aac3b53b4575407b">GpuDispatcher::TLBPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#a25f53beed28c50cbe9c54a8965a94d35">AddrMapper::MapperMasterPort</a>, <a class="el" href="classMemCheckerMonitor_1_1MonitorMasterPort.html#ab98c2a016289b40f510d134f9ca2bd76">MemCheckerMonitor::MonitorMasterPort</a>, <a class="el" href="classRubyPort_1_1PioMasterPort.html#a1173a003b8122c866386d6b24303a392">RubyPort::PioMasterPort</a>, <a class="el" href="classsc__gem5_1_1TlmToGem5Bridge_1_1BridgeMasterPort.html#a5296aef3ee12e00469640ace55812594">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::BridgeMasterPort</a>, <a class="el" href="classMemDelay_1_1MasterPort.html#afd81d3200c66bf02e9acb0a96a61b941">MemDelay::MasterPort</a>, and <a class="el" href="classRubyPort_1_1MemMasterPort.html#a5996f74108189b2ccadaccc4c0076c52">RubyPort::MemMasterPort</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00218">218</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8hh_source.html#l00286">SlavePort::sendRangeChange()</a>.</p>

</div>
</div>
<a id="a2ff72389488ee1c2ca924afc07f21933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff72389488ee1c2ca924afc07f21933">&#9670;&nbsp;</a></span>recvRetrySnoopResp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::recvRetrySnoopResp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the peer if sendTimingSnoopResp was called on this protocol (causing recvTimingSnoopResp to be called on the peer) and was unsuccessful. </p>

<p>Implements <a class="el" href="classTimingRequestProtocol.html#a6de2482b96f498e8c3cbe6cbb9f1c8ff">TimingRequestProtocol</a>.</p>

<p>Reimplemented in <a class="el" href="classQueuedMasterPort.html#a4246dd99270ff519e5d1192280a9a2e4">QueuedMasterPort</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00243">243</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="sim_2port_8hh_source.html#l00106">Port::name()</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

</div>
</div>
<a id="a325b01a8c364e966a16623fdb9bdcfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325b01a8c364e966a16623fdb9bdcfc7">&#9670;&nbsp;</a></span>recvTimingSnoopReq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::recvTimingSnoopReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a timing snoop request from the peer. </p>

<p>Implements <a class="el" href="classTimingRequestProtocol.html#a3a1ea5c795cf872c07be609c399ea453">TimingRequestProtocol</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00237">237</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="sim_2port_8hh_source.html#l00106">Port::name()</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8hh_source.html#l00408">BaseCache::allocOnFill()</a>.</p>

</div>
</div>
<a id="a444096e9902c823aa36ce5b3fa847fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444096e9902c823aa36ce5b3fa847fe5">&#9670;&nbsp;</a></span>sendAtomic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> MasterPort::sendAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send an atomic request packet, where the data is moved and the state is updated in zero time, without interleaving with other memory accesses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated latency of access. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00427">427</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="mem_2protocol_2atomic_8cc_source.html#l00052">AtomicRequestProtocol::send()</a>.</p>

<p class="reference">Referenced by <a class="el" href="noncoherent__cache_8cc_source.html#l00111">NoncoherentCache::doWritebacksAtomic()</a>, <a class="el" href="cache_8cc_source.html#l00235">Cache::doWritebacksAtomic()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="stage2__mmu_8cc_source.html#l00064">ArmISA::Stage2MMU::readDataUntimed()</a>, <a class="el" href="RubyPort_8cc_source.html#l00304">RubyPort::MemSlavePort::recvAtomic()</a>, <a class="el" href="mem__delay_8cc_source.html#l00131">MemDelay::SlavePort::recvAtomic()</a>, <a class="el" href="cache_8cc_source.html#l00658">Cache::recvAtomic()</a>, <a class="el" href="AbstractController_8cc_source.html#l00360">AbstractController::recvAtomic()</a>, <a class="el" href="serial__link_8cc_source.html#l00376">SerialLink::SerialLinkSlavePort::recvAtomic()</a>, <a class="el" href="bridge_8cc_source.html#l00341">Bridge::BridgeSlavePort::recvAtomic()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00087">AddrMapper::recvAtomic()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00345">CommMonitor::recvAtomic()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l02359">BaseCache::CpuSidePort::recvAtomic()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00233">SMMUv3::runProcessAtomic()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01191">Gicv3Its::runProcessAtomic()</a>, <a class="el" href="noncaching_8cc_source.html#l00057">NonCachingSimpleCPU::sendPacket()</a>, and <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00278">AtomicSimpleCPU::sendPacket()</a>.</p>

</div>
</div>
<a id="a75b67ff731653d9b58b556a89792e51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b67ff731653d9b58b556a89792e51d">&#9670;&nbsp;</a></span>sendAtomicBackdoor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> MasterPort::sendAtomicBackdoor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem_2backdoor_8hh.html#a658934db0b23ac4ef1b8978c03afc0fb">MemBackdoorPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>backdoor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send an atomic request packet like above, but also request a backdoor to the data being accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> to send. </td></tr>
    <tr><td class="paramname">backdoor</td><td>Can be set to a back door pointer by the target to let caller have direct access to the requested data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated latency of access. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00433">433</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="mem_2protocol_2atomic_8cc_source.html#l00059">AtomicRequestProtocol::sendBackdoor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>.</p>

</div>
</div>
<a id="a84190aa477270de3be5e87506f7103eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84190aa477270de3be5e87506f7103eb">&#9670;&nbsp;</a></span>sendFunctional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::sendFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a functional request packet, where the data is instantly updated everywhere in the memory system, without affecting the current state of any block or moving the block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> to send. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00439">439</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="functional_8cc_source.html#l00050">FunctionalRequestProtocol::send()</a>.</p>

<p class="reference">Referenced by <a class="el" href="fetch__unit_8cc_source.html#l00208">FetchUnit::fetch()</a>, <a class="el" href="table__walker_8cc_source.html#l02005">ArmISA::TableWalker::fetchDescriptor()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="AbstractController_8cc_source.html#l00307">AbstractController::functionalMemoryRead()</a>, <a class="el" href="AbstractController_8cc_source.html#l00313">AbstractController::functionalMemoryWrite()</a>, <a class="el" href="shader_8cc_source.html#l00384">Shader::functionalTLBAccess()</a>, <a class="el" href="simple__memobj_8cc_source.html#l00212">SimpleMemobj::handleFunctional()</a>, <a class="el" href="simple__cache_8cc_source.html#l00272">SimpleCache::handleFunctional()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00116">FetchUnit::initiateFetch()</a>, <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="port__proxy_8hh_source.html#l00105">PortProxy::PortProxy()</a>, <a class="el" href="mem_2port_8cc_source.html#l00099">printAddr()</a>, <a class="el" href="AbstractController_8cc_source.html#l00240">AbstractController::queueMemoryRead()</a>, <a class="el" href="AbstractController_8cc_source.html#l00264">AbstractController::queueMemoryWrite()</a>, <a class="el" href="stage2__mmu_8cc_source.html#l00064">ArmISA::Stage2MMU::readDataUntimed()</a>, <a class="el" href="cpu_2checker_2cpu_8cc_source.html#l00177">CheckerCPU::readMem()</a>, <a class="el" href="mem__delay_8cc_source.html#l00149">MemDelay::SlavePort::recvFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00382">SerialLink::SerialLinkSlavePort::recvFunctional()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00089">MemCheckerMonitor::recvFunctional()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00069">AddrMapper::recvFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00350">Bridge::BridgeSlavePort::recvFunctional()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00099">CommMonitor::recvFunctional()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l02370">BaseCache::CpuSidePort::recvFunctional()</a>, <a class="el" href="memtest_8cc_source.html#l00218">MemTest::tick()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01629">BaseCache::writebackVisitor()</a>.</p>

</div>
</div>
<a id="a66b0f70300a96e61ac88bc186ed6f1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b0f70300a96e61ac88bc186ed6f1d2">&#9670;&nbsp;</a></span>sendRetryResp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::sendRetryResp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a retry to the slave port that previously attempted a sendTimingResp to this master port and failed. </p>
<p>Note that this is virtual so that the "fake" snoop response port in the coherent crossbar can override the behaviour. </p>

<p>Reimplemented in <a class="el" href="classCoherentXBar_1_1SnoopRespPort.html#a5af7e428fef9aba2058709610189afe2">CoherentXBar::SnoopRespPort</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00463">463</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00073">TimingRequestProtocol::sendRetryResp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00355">MemCheckerMonitor::recvRespRetry()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00194">AddrMapper::recvRespRetry()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00500">CommMonitor::recvRespRetry()</a>, and <a class="el" href="xbar_8hh_source.html#l00278">BaseXBar::RespLayer::sendRetry()</a>.</p>

</div>
</div>
<a id="acba350c337376f074a37507d6018bec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba350c337376f074a37507d6018bec3">&#9670;&nbsp;</a></span>sendTimingReq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MasterPort::sendTimingReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to send a timing request to the slave port by calling its corresponding receive function. </p>
<p>If the send does not succeed, as indicated by the return value, then the sender must wait for a recvReqRetry at which point it can re-issue a sendTimingReq.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the send was succesful or not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00445">445</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00050">TimingRequestProtocol::sendReq()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GarnetSyntheticTraffic_8cc_source.html#l00339">GarnetSyntheticTraffic::doRetry()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00208">FetchUnit::fetch()</a>, <a class="el" href="fetch__impl_8hh_source.html#l00654">DefaultFetch&lt; Impl &gt;::finishTranslation()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00259">TimingSimpleCPU::handleReadPacket()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00475">TimingSimpleCPU::handleWritePacket()</a>, <a class="el" href="SeriesRequestGenerator_8cc_source.html#l00053">SeriesRequestGenerator::initiate()</a>, <a class="el" href="InvalidateGenerator_8cc_source.html#l00055">InvalidateGenerator::initiate()</a>, <a class="el" href="Check_8cc_source.html#l00167">Check::initiateAction()</a>, <a class="el" href="Check_8cc_source.html#l00227">Check::initiateCheck()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00116">FetchUnit::initiateFetch()</a>, <a class="el" href="Check_8cc_source.html#l00138">Check::initiateFlush()</a>, <a class="el" href="Check_8cc_source.html#l00082">Check::initiatePrefetch()</a>, <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00146">SMMUv3::masterRecvReqRetry()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00192">SMMUv3::masterTableWalkRecvReqRetry()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01117">Gicv3Its::recvReqRetry()</a>, <a class="el" href="fetch__impl_8hh_source.html#l01420">DefaultFetch&lt; Impl &gt;::recvReqRetry()</a>, <a class="el" href="compute__unit_8cc_source.html#l01881">ComputeUnit::LDSPort::recvReqRetry()</a>, <a class="el" href="memtest_8cc_source.html#l00328">MemTest::recvRetry()</a>, <a class="el" href="cache_8cc_source.html#l00406">Cache::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l02341">BaseCache::CpuSidePort::recvTimingReq()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00298">BaseTrafficGen::retryReq()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00282">SMMUv3::runProcessTiming()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01160">Gicv3Its::runProcessTiming()</a>, <a class="el" href="trace__cpu_8cc_source.html#l01149">TraceCPU::FixedRetryGen::send()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00697">TimingSimpleCPU::sendFetch()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00155">X86ISA::Walker::sendTiming()</a>, <a class="el" href="packet__queue_8cc_source.html#l00246">ReqPacketQueue::sendTiming()</a>, <a class="el" href="compute__unit_8cc_source.html#l01839">ComputeUnit::LDSPort::sendTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01785">BaseCache::sendWriteQueuePacket()</a>, <a class="el" href="trace__cpu_8cc_source.html#l01063">TraceCPU::FixedRetryGen::tryNext()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l01058">LSQUnit&lt; Impl &gt;::trySendPacket()</a>, <a class="el" href="fetch1_8cc_source.html#l00331">Minor::Fetch1::tryToSend()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01164">Minor::LSQ::tryToSend()</a>, and <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00170">BaseTrafficGen::update()</a>.</p>

</div>
</div>
<a id="a86fd4c4633f60b489f024288ecce4248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fd4c4633f60b489f024288ecce4248">&#9670;&nbsp;</a></span>sendTimingSnoopResp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MasterPort::sendTimingSnoopResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to send a timing snoop response packet to the slave port by calling its corresponding receive function. </p>
<p>If the send does not succeed, as indicated by the return value, then the sender must wait for a recvRetrySnoop at which point it can re-issue a sendTimingSnoopResp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> to send. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00457">457</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00065">TimingRequestProtocol::sendSnoopResp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00329">MemCheckerMonitor::recvTimingSnoopResp()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00174">AddrMapper::recvTimingSnoopResp()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00468">CommMonitor::recvTimingSnoopResp()</a>, and <a class="el" href="packet__queue_8cc_source.html#l00261">SnoopRespPacketQueue::sendTiming()</a>.</p>

</div>
</div>
<a id="a987c8bce748766ffaab64bf9a7c3d98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987c8bce748766ffaab64bf9a7c3d98b">&#9670;&nbsp;</a></span>tryTiming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MasterPort::tryTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if the slave can handle a timing request. </p>
<p>If the send cannot be handled at the moment, as indicated by the return value, then the sender will receive a recvReqRetry at which point it can re-issue a sendTimingReq.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the send was succesful or not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00451">451</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, and <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00057">TimingRequestProtocol::trySend()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8hh_source.html#l00111">isSnooping()</a>, and <a class="el" href="comm__monitor_8cc_source.html#l00506">CommMonitor::tryTiming()</a>.</p>

</div>
</div>
<a id="a3220e6f2fc9ddc8fb765cdb240ae97ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3220e6f2fc9ddc8fb765cdb240ae97ff">&#9670;&nbsp;</a></span>unbind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MasterPort::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind this master port and the associated slave port. </p>

<p>Reimplemented from <a class="el" href="classPort.html#a4e03e29c5afcbd5df0c74dbfc970622f">Port</a>.</p>

<p class="definition">Definition at line <a class="el" href="mem_2port_8cc_source.html#l00082">82</a> of file <a class="el" href="mem_2port_8cc_source.html">port.cc</a>.</p>

<p class="reference">References <a class="el" href="mem_2port_8hh_source.html#l00081">_slavePort</a>, <a class="el" href="sim_2port_8hh_source.html#l00106">Port::name()</a>, <a class="el" href="logging_8hh_source.html#l00167">panic</a>, <a class="el" href="mem_2port_8cc_source.html#l00125">SlavePort::slaveUnbind()</a>, and <a class="el" href="sim_2port_8hh_source.html#l00121">Port::unbind()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5344d902f61e69b03cd4d737c6375ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5344d902f61e69b03cd4d737c6375ce3">&#9670;&nbsp;</a></span>SlavePort</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSlavePort.html">SlavePort</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00078">78</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a805c6d3c90bef6de1c35b72d21ab578c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805c6d3c90bef6de1c35b72d21ab578c">&#9670;&nbsp;</a></span>_slavePort</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSlavePort.html">SlavePort</a>* MasterPort::_slavePort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00081">81</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2port_8cc_source.html#l00067">bind()</a>, <a class="el" href="mem_2port_8cc_source.html#l00093">getAddrRanges()</a>, <a class="el" href="mem_2port_8hh_source.html#l00427">sendAtomic()</a>, <a class="el" href="mem_2port_8hh_source.html#l00433">sendAtomicBackdoor()</a>, <a class="el" href="mem_2port_8hh_source.html#l00439">sendFunctional()</a>, <a class="el" href="mem_2port_8hh_source.html#l00463">sendRetryResp()</a>, <a class="el" href="mem_2port_8hh_source.html#l00445">sendTimingReq()</a>, <a class="el" href="mem_2port_8hh_source.html#l00457">sendTimingSnoopResp()</a>, <a class="el" href="mem_2port_8hh_source.html#l00451">tryTiming()</a>, and <a class="el" href="mem_2port_8cc_source.html#l00082">unbind()</a>.</p>

</div>
</div>
<a id="a94fa49941f41ad161da6144b5eae0135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fa49941f41ad161da6144b5eae0135">&#9670;&nbsp;</a></span>owner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimObject.html">SimObject</a>&amp; MasterPort::owner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mem_2port_8hh_source.html#l00084">84</a> of file <a class="el" href="mem_2port_8hh_source.html">port.hh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="mem_2port_8hh_source.html">port.hh</a></li>
<li>mem/<a class="el" href="mem_2port_8cc_source.html">port.cc</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:18 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
