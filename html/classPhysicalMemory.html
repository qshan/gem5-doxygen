<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: PhysicalMemory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPhysicalMemory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PhysicalMemory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The physical memory encapsulates all memories in the system and provides basic functionality for accessing those memories without going through the memory system and interconnect.  
 <a href="classPhysicalMemory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="physical_8hh_source.html">physical.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PhysicalMemory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPhysicalMemory.png" usemap="#PhysicalMemory_map" alt=""/>
  <map id="PhysicalMemory_map" name="PhysicalMemory_map">
<area href="classSerializable.html" title="Basic support for object serialization. " alt="Serializable" shape="rect" coords="0,0,106,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a996cc2cb9c0252a7770401e39ced082a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a996cc2cb9c0252a7770401e39ced082a">PhysicalMemory</a> (const std::string &amp;<a class="el" href="classPhysicalMemory.html#ab350c0762d0512becaba3ef121cec592">_name</a>, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> *&gt; &amp;_memories, bool mmap_using_noreserve)</td></tr>
<tr class="memdesc:a996cc2cb9c0252a7770401e39ced082a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a physical memory object, wrapping a number of memories.  <a href="#a996cc2cb9c0252a7770401e39ced082a">More...</a><br /></td></tr>
<tr class="separator:a996cc2cb9c0252a7770401e39ced082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72332a339430d947462769976c1ab1f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a72332a339430d947462769976c1ab1f2">~PhysicalMemory</a> ()</td></tr>
<tr class="memdesc:a72332a339430d947462769976c1ab1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap all the backing store we have used.  <a href="#a72332a339430d947462769976c1ab1f2">More...</a><br /></td></tr>
<tr class="separator:a72332a339430d947462769976c1ab1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9395042677f13a53c57da5663c224e6f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a9395042677f13a53c57da5663c224e6f">name</a> () const</td></tr>
<tr class="memdesc:a9395042677f13a53c57da5663c224e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name for debugging and for creation of sections for checkpointing.  <a href="#a9395042677f13a53c57da5663c224e6f">More...</a><br /></td></tr>
<tr class="separator:a9395042677f13a53c57da5663c224e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f0ffabcaeb234814888e1335c52814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ac0f0ffabcaeb234814888e1335c52814">isMemAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="inet_8hh.html#ae32b25ff633168fbdecd8d24293034cd">addr</a>) const</td></tr>
<tr class="memdesc:ac0f0ffabcaeb234814888e1335c52814"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if a physical address is within a range of a memory that is part of the global address map.  <a href="#ac0f0ffabcaeb234814888e1335c52814">More...</a><br /></td></tr>
<tr class="separator:ac0f0ffabcaeb234814888e1335c52814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a72b65b23009914f24a39beb3582fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="addr__range_8hh.html#a8f73751754cd29dbff43400e751325c0">AddrRangeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ab7a72b65b23009914f24a39beb3582fe">getConfAddrRanges</a> () const</td></tr>
<tr class="memdesc:ab7a72b65b23009914f24a39beb3582fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory ranges for all memories that are to be reported to the configuration table.  <a href="#ab7a72b65b23009914f24a39beb3582fe">More...</a><br /></td></tr>
<tr class="separator:ab7a72b65b23009914f24a39beb3582fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32854f9d7719edc606da92181f0bc03"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ab32854f9d7719edc606da92181f0bc03">totalSize</a> () const</td></tr>
<tr class="memdesc:ab32854f9d7719edc606da92181f0bc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total physical memory size.  <a href="#ab32854f9d7719edc606da92181f0bc03">More...</a><br /></td></tr>
<tr class="separator:ab32854f9d7719edc606da92181f0bc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d32aae1170ce297a8c0d45626e8dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classBackingStoreEntry.html">BackingStoreEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a21d32aae1170ce297a8c0d45626e8dd1">getBackingStore</a> () const</td></tr>
<tr class="memdesc:a21d32aae1170ce297a8c0d45626e8dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointers to the backing store for external host access.  <a href="#a21d32aae1170ce297a8c0d45626e8dd1">More...</a><br /></td></tr>
<tr class="separator:a21d32aae1170ce297a8c0d45626e8dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b3796dfbc3dfd693675e79052b2deb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb">access</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a37b3796dfbc3dfd693675e79052b2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an untimed memory access and update all the state (e.g.  <a href="#a37b3796dfbc3dfd693675e79052b2deb">More...</a><br /></td></tr>
<tr class="separator:a37b3796dfbc3dfd693675e79052b2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d828f36824d5593511c79fe716e484c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a2d828f36824d5593511c79fe716e484c">functionalAccess</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a2d828f36824d5593511c79fe716e484c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an untimed memory read or write without changing anything but the memory itself.  <a href="#a2d828f36824d5593511c79fe716e484c">More...</a><br /></td></tr>
<tr class="separator:a2d828f36824d5593511c79fe716e484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4a6341189e8c1d293e21504d1c989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#adeb4a6341189e8c1d293e21504d1c989">serialize</a> (<a class="el" href="serialize_8hh.html#a821b5f5905353967b548ad54944d553e">CheckpointOut</a> &amp;cp) const override</td></tr>
<tr class="memdesc:adeb4a6341189e8c1d293e21504d1c989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize all the memories in the system.  <a href="#adeb4a6341189e8c1d293e21504d1c989">More...</a><br /></td></tr>
<tr class="separator:adeb4a6341189e8c1d293e21504d1c989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabaa707fdab62e58307ed7487eb19f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#acabaa707fdab62e58307ed7487eb19f8">serializeStore</a> (<a class="el" href="serialize_8hh.html#a821b5f5905353967b548ad54944d553e">CheckpointOut</a> &amp;cp, unsigned int store_id, <a class="el" href="classAddrRange.html">AddrRange</a> range, uint8_t *pmem) const</td></tr>
<tr class="memdesc:acabaa707fdab62e58307ed7487eb19f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a specific store.  <a href="#acabaa707fdab62e58307ed7487eb19f8">More...</a><br /></td></tr>
<tr class="separator:acabaa707fdab62e58307ed7487eb19f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68712b29eaff34a5fdffb982583d0492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a68712b29eaff34a5fdffb982583d0492">unserialize</a> (<a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;cp) override</td></tr>
<tr class="memdesc:a68712b29eaff34a5fdffb982583d0492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserialize the memories in the system.  <a href="#a68712b29eaff34a5fdffb982583d0492">More...</a><br /></td></tr>
<tr class="separator:a68712b29eaff34a5fdffb982583d0492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba176bbc099adc0ea42abf7b4c6b92ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aba176bbc099adc0ea42abf7b4c6b92ec">unserializeStore</a> (<a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;cp)</td></tr>
<tr class="memdesc:aba176bbc099adc0ea42abf7b4c6b92ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserialize a specific backing store, identified by a section.  <a href="#aba176bbc099adc0ea42abf7b4c6b92ec">More...</a><br /></td></tr>
<tr class="separator:aba176bbc099adc0ea42abf7b4c6b92ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSerializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSerializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSerializable.html">Serializable</a></td></tr>
<tr class="memitem:ae2b10a6d95c9873ede8c4562cc5105be inherit pub_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#ae2b10a6d95c9873ede8c4562cc5105be">Serializable</a> ()</td></tr>
<tr class="separator:ae2b10a6d95c9873ede8c4562cc5105be inherit pub_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae29a43e8b1a24b0f107129b5af7e14 inherit pub_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#aaae29a43e8b1a24b0f107129b5af7e14">~Serializable</a> ()</td></tr>
<tr class="separator:aaae29a43e8b1a24b0f107129b5af7e14 inherit pub_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5360c9a9ee288009ba4abfc0ee0179b4 inherit pub_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a5360c9a9ee288009ba4abfc0ee0179b4">serializeSection</a> (<a class="el" href="serialize_8hh.html#a821b5f5905353967b548ad54944d553e">CheckpointOut</a> &amp;cp, const char *<a class="el" href="base_2trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>) const</td></tr>
<tr class="memdesc:a5360c9a9ee288009ba4abfc0ee0179b4 inherit pub_methods_classSerializable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object into a new section.  <a href="classSerializable.html#a5360c9a9ee288009ba4abfc0ee0179b4">More...</a><br /></td></tr>
<tr class="separator:a5360c9a9ee288009ba4abfc0ee0179b4 inherit pub_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7f0beddd557e732af0940eb20c09b0 inherit pub_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a0a7f0beddd557e732af0940eb20c09b0">serializeSection</a> (<a class="el" href="serialize_8hh.html#a821b5f5905353967b548ad54944d553e">CheckpointOut</a> &amp;cp, const std::string &amp;<a class="el" href="base_2trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>) const</td></tr>
<tr class="separator:a0a7f0beddd557e732af0940eb20c09b0 inherit pub_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad019457160891a7974f124f1c6899f21 inherit pub_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#ad019457160891a7974f124f1c6899f21">unserializeSection</a> (<a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;cp, const char *<a class="el" href="base_2trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>)</td></tr>
<tr class="memdesc:ad019457160891a7974f124f1c6899f21 inherit pub_methods_classSerializable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserialize an a child object.  <a href="classSerializable.html#ad019457160891a7974f124f1c6899f21">More...</a><br /></td></tr>
<tr class="separator:ad019457160891a7974f124f1c6899f21 inherit pub_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405b36fd9b9af68394ca3f777edbbc9f inherit pub_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a405b36fd9b9af68394ca3f777edbbc9f">unserializeSection</a> (<a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;cp, const std::string &amp;<a class="el" href="base_2trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>)</td></tr>
<tr class="separator:a405b36fd9b9af68394ca3f777edbbc9f inherit pub_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aef8c3120060f8bec78007da8e9210090"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aef8c3120060f8bec78007da8e9210090">PhysicalMemory</a> (const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;)</td></tr>
<tr class="separator:aef8c3120060f8bec78007da8e9210090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c8726f1fb049dcb4c219e474158589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a71c8726f1fb049dcb4c219e474158589">operator=</a> (const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;)</td></tr>
<tr class="separator:a71c8726f1fb049dcb4c219e474158589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508f4d025a47307f7012bef76300ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a1508f4d025a47307f7012bef76300ab8">createBackingStore</a> (<a class="el" href="classAddrRange.html">AddrRange</a> range, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> *&gt; &amp;_memories, bool conf_table_reported, bool in_addr_map, bool kvm_map)</td></tr>
<tr class="memdesc:a1508f4d025a47307f7012bef76300ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the memory region providing the backing store for a given address range that corresponds to a set of memories in the simulated system.  <a href="#a1508f4d025a47307f7012bef76300ab8">More...</a><br /></td></tr>
<tr class="separator:a1508f4d025a47307f7012bef76300ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab350c0762d0512becaba3ef121cec592"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ab350c0762d0512becaba3ef121cec592">_name</a></td></tr>
<tr class="separator:ab350c0762d0512becaba3ef121cec592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9143684abd49d9b2dc1a3bd651e00053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrRangeMap.html">AddrRangeMap</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> *, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a9143684abd49d9b2dc1a3bd651e00053">addrMap</a></td></tr>
<tr class="separator:a9143684abd49d9b2dc1a3bd651e00053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa871234aa6c34d601d7382243285a4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aa871234aa6c34d601d7382243285a4e2">memories</a></td></tr>
<tr class="separator:aa871234aa6c34d601d7382243285a4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5593123b31f52c14675a125076fca73e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a5593123b31f52c14675a125076fca73e">size</a></td></tr>
<tr class="separator:a5593123b31f52c14675a125076fca73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5445b02e4913019ec3efcdfbe7576475"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a5445b02e4913019ec3efcdfbe7576475">mmapUsingNoReserve</a></td></tr>
<tr class="separator:a5445b02e4913019ec3efcdfbe7576475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0b0131d4ca5e342e09cc1303185a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classBackingStoreEntry.html">BackingStoreEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a9c0b0131d4ca5e342e09cc1303185a4c">backingStore</a></td></tr>
<tr class="separator:a9c0b0131d4ca5e342e09cc1303185a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSerializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSerializable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSerializable.html">Serializable</a></td></tr>
<tr class="memitem:a20c6c398de76a2b81a90f06b8073ff5d inherit pub_static_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a20c6c398de76a2b81a90f06b8073ff5d">currentSection</a> ()</td></tr>
<tr class="memdesc:a20c6c398de76a2b81a90f06b8073ff5d inherit pub_static_methods_classSerializable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fully-qualified name of the active section.  <a href="classSerializable.html#a20c6c398de76a2b81a90f06b8073ff5d">More...</a><br /></td></tr>
<tr class="separator:a20c6c398de76a2b81a90f06b8073ff5d inherit pub_static_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35635bf4842a3a12ffb40261879cf243 inherit pub_static_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a35635bf4842a3a12ffb40261879cf243">serializeAll</a> (const std::string &amp;cpt_dir)</td></tr>
<tr class="separator:a35635bf4842a3a12ffb40261879cf243 inherit pub_static_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e33f134d36aa0cd5a36b3fb461962df inherit pub_static_methods_classSerializable"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a2e33f134d36aa0cd5a36b3fb461962df">unserializeGlobals</a> (<a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;cp)</td></tr>
<tr class="separator:a2e33f134d36aa0cd5a36b3fb461962df inherit pub_static_methods_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classSerializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classSerializable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classSerializable.html">Serializable</a></td></tr>
<tr class="memitem:a3edd16fe55d68f6610ea38ba8a2e0543 inherit pub_static_attribs_classSerializable"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a3edd16fe55d68f6610ea38ba8a2e0543">ckptCount</a> = 0</td></tr>
<tr class="separator:a3edd16fe55d68f6610ea38ba8a2e0543 inherit pub_static_attribs_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55994e6905bd7a5a739df8b748fe749 inherit pub_static_attribs_classSerializable"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#aa55994e6905bd7a5a739df8b748fe749">ckptMaxCount</a> = 0</td></tr>
<tr class="separator:aa55994e6905bd7a5a739df8b748fe749 inherit pub_static_attribs_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddcadfd3045221bee368bddb20a9f9f inherit pub_static_attribs_classSerializable"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializable.html#a2ddcadfd3045221bee368bddb20a9f9f">ckptPrevCount</a> = -1</td></tr>
<tr class="separator:a2ddcadfd3045221bee368bddb20a9f9f inherit pub_static_attribs_classSerializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The physical memory encapsulates all memories in the system and provides basic functionality for accessing those memories without going through the memory system and interconnect. </p>
<p>The physical memory is also responsible for providing the host system backingstore used by the memories in the simulated guest system. When the system is created, the physical memory allocates the backing store based on the address ranges that are populated in the system, and does so independent of how those map to actual memory controllers. Thus, the physical memory completely abstracts the mapping of the backing store of the host system and the address mapping in the guest system. This enables us to arbitrarily change the number of memory controllers, and their address mapping, as long as the ranges stay the same. </p>

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00112">112</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef8c3120060f8bec78007da8e9210090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8c3120060f8bec78007da8e9210090">&#9670;&nbsp;</a></span>PhysicalMemory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PhysicalMemory::PhysicalMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a996cc2cb9c0252a7770401e39ced082a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996cc2cb9c0252a7770401e39ced082a">&#9670;&nbsp;</a></span>PhysicalMemory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PhysicalMemory::PhysicalMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>_memories</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mmap_using_noreserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a physical memory object, wrapping a number of memories. </p>

</div>
</div>
<a id="a72332a339430d947462769976c1ab1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72332a339430d947462769976c1ab1f2">&#9670;&nbsp;</a></span>~PhysicalMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PhysicalMemory::~PhysicalMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap all the backing store we have used. </p>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00228">228</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00532">ArmISA::s</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37b3796dfbc3dfd693675e79052b2deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b3796dfbc3dfd693675e79052b2deb">&#9670;&nbsp;</a></span>access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an untimed memory access and update all the state (e.g. </p>
<p>locked addresses) and statistics accordingly. The packet is turned into a response if required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> performing the access </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00278">278</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8cc_source.html#l00228">Packet::getAddrRange()</a>, <a class="el" href="packet_8hh_source.html#l00531">Packet::isRequest()</a>, and <a class="el" href="miscregs__types_8hh_source.html#l00368">ArmISA::m</a>.</p>

<p class="reference">Referenced by <a class="el" href="noncaching_8cc_source.html#l00057">NonCachingSimpleCPU::sendPacket()</a>.</p>

</div>
</div>
<a id="a1508f4d025a47307f7012bef76300ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1508f4d025a47307f7012bef76300ab8">&#9670;&nbsp;</a></span>createBackingStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::createBackingStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrRange.html">AddrRange</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>_memories</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conf_table_reported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_addr_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kvm_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the memory region providing the backing store for a given address range that corresponds to a set of memories in the simulated system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The address range covered </td></tr>
    <tr><td class="paramname">memories</td><td>The memories this range maps to </td></tr>
    <tr><td class="paramname">kvm_map</td><td>Should KVM map this memory for the guest </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00185">185</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="base_2trace_8hh_source.html#l00215">DPRINTF</a>, <a class="el" href="logging_8hh_source.html#l00175">fatal</a>, <a class="el" href="addr__range_8hh_source.html#l00250">AddrRange::interleaved()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00368">ArmISA::m</a>, <a class="el" href="logging_8hh_source.html#l00185">panic_if</a>, <a class="el" href="addr__range_8hh_source.html#l00284">AddrRange::size()</a>, and <a class="el" href="addr__range_8hh_source.html#l00309">AddrRange::to_string()</a>.</p>

</div>
</div>
<a id="a2d828f36824d5593511c79fe716e484c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d828f36824d5593511c79fe716e484c">&#9670;&nbsp;</a></span>functionalAccess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::functionalAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an untimed memory read or write without changing anything but the memory itself. </p>
<p>No stats are affected by this access. In addition to normal accesses this also facilitates print requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> performing the access </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00287">287</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8cc_source.html#l00228">Packet::getAddrRange()</a>, <a class="el" href="packet_8hh_source.html#l00531">Packet::isRequest()</a>, and <a class="el" href="miscregs__types_8hh_source.html#l00368">ArmISA::m</a>.</p>

</div>
</div>
<a id="a21d32aae1170ce297a8c0d45626e8dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d32aae1170ce297a8c0d45626e8dd1">&#9670;&nbsp;</a></span>getBackingStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classBackingStoreEntry.html">BackingStoreEntry</a>&gt; PhysicalMemory::getBackingStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointers to the backing store for external host access. </p>
<p>Note that memory in the guest should be accessed using <a class="el" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb" title="Perform an untimed memory access and update all the state (e.g. ">access()</a> or <a class="el" href="classPhysicalMemory.html#a2d828f36824d5593511c79fe716e484c" title="Perform an untimed memory read or write without changing anything but the memory itself. ">functionalAccess()</a>. This interface is primarily intended for CPU models using hardware virtualization. Note that memories that are null are not present, and that the backing store may also contain memories that are not part of the OS-visible global address map and thus are allowed to overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointers to the memory backing store </dd></dl>

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00214">214</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p class="reference">References <a class="el" href="physical_8hh_source.html#l00077">BackingStoreEntry::pmem</a>, <a class="el" href="physical_8hh_source.html#l00071">BackingStoreEntry::range</a>, <a class="el" href="cpu_2thread__context_8cc_source.html#l00166">serialize()</a>, and <a class="el" href="cpu_2thread__context_8cc_source.html#l00207">unserialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="vm_8cc_source.html#l00344">KvmVM::delayedStartup()</a>.</p>

</div>
</div>
<a id="ab7a72b65b23009914f24a39beb3582fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a72b65b23009914f24a39beb3582fe">&#9670;&nbsp;</a></span>getConfAddrRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="addr__range_8hh.html#a8f73751754cd29dbff43400e751325c0">AddrRangeList</a> PhysicalMemory::getConfAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory ranges for all memories that are to be reported to the configuration table. </p>
<p>The ranges are merged before they are returned such that any interleaved ranges appear as a single range.</p>
<dl class="section return"><dt>Returns</dt><dd>All configuration table memory ranges </dd></dl>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00242">242</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="mips_2pra__constants_8hh_source.html#l00097">MipsISA::r</a>.</p>

<p class="reference">Referenced by <a class="el" href="arch_2arm_2linux_2system_8cc_source.html#l00106">LinuxArmSystem::initState()</a>, and <a class="el" href="semihosting_8cc_source.html#l00270">ArmSemihosting::readString()</a>.</p>

</div>
</div>
<a id="ac0f0ffabcaeb234814888e1335c52814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f0ffabcaeb234814888e1335c52814">&#9670;&nbsp;</a></span>isMemAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PhysicalMemory::isMemAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if a physical address is within a range of a memory that is part of the global address map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A physical address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the address corresponds to a memory </dd></dl>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00236">236</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="sim_2system_8cc_source.html#l00436">System::isMemAddr()</a>.</p>

</div>
</div>
<a id="a9395042677f13a53c57da5663c224e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9395042677f13a53c57da5663c224e6f">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string PhysicalMemory::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name for debugging and for creation of sections for checkpointing. </p>

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00174">174</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p class="reference">References <a class="el" href="inet_8hh_source.html#l00335">addr</a>.</p>

</div>
</div>
<a id="a71c8726f1fb049dcb4c219e474158589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c8726f1fb049dcb4c219e474158589">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a>&amp; PhysicalMemory::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adeb4a6341189e8c1d293e21504d1c989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb4a6341189e8c1d293e21504d1c989">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="serialize_8hh.html#a821b5f5905353967b548ad54944d553e">CheckpointOut</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize all the memories in the system. </p>
<p>This is independent of the logical memory layout, and the serialization only sees the contigous backing store, independent of how this maps to logical memories in the guest system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>stream to serialize to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSerializable.html#a8355a51f6749147f5565bb4fb107ed97">Serializable</a>.</p>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00296">296</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="cprintf_8hh_source.html#l00162">csprintf()</a>, <a class="el" href="mips_2pra__constants_8hh_source.html#l00322">MipsISA::l</a>, <a class="el" href="locked__mem_8cc_source.html#l00009">RiscvISA::locked_addrs</a>, <a class="el" href="miscregs__types_8hh_source.html#l00368">ArmISA::m</a>, <a class="el" href="miscregs__types_8hh_source.html#l00532">ArmISA::s</a>, <a class="el" href="serialize_8hh_source.html#l00664">SERIALIZE_CONTAINER</a>, and <a class="el" href="serialize_8hh_source.html#l00643">SERIALIZE_SCALAR</a>.</p>

</div>
</div>
<a id="acabaa707fdab62e58307ed7487eb19f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabaa707fdab62e58307ed7487eb19f8">&#9670;&nbsp;</a></span>serializeStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::serializeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="serialize_8hh.html#a821b5f5905353967b548ad54944d553e">CheckpointOut</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>store_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrRange.html">AddrRange</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pmem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a specific store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store_id</td><td>Unique identifier of this backing store </td></tr>
    <tr><td class="paramname">range</td><td>The address range of this backing store </td></tr>
    <tr><td class="paramname">pmem</td><td>The host pointer to this backing store </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00326">326</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="serialize_8cc_source.html#l00268">CheckpointIn::dir()</a>, <a class="el" href="base_2trace_8hh_source.html#l00215">DPRINTF</a>, <a class="el" href="logging_8hh_source.html#l00175">fatal</a>, <a class="el" href="page__table_8hh_source.html#l00105">EmulationPageTable::name()</a>, <a class="el" href="serialize_8hh_source.html#l00643">SERIALIZE_SCALAR</a>, <a class="el" href="addr__range_8hh_source.html#l00284">AddrRange::size()</a>, and <a class="el" href="sc__fxdefs_8cc_source.html#l00060">sc_dt::to_string()</a>.</p>

</div>
</div>
<a id="ab32854f9d7719edc606da92181f0bc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32854f9d7719edc606da92181f0bc03">&#9670;&nbsp;</a></span>totalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PhysicalMemory::totalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total physical memory size. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all memory sizes </dd></dl>

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00200">200</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="sim_2system_8cc_source.html#l00404">System::allocPhysPages()</a>, <a class="el" href="sim_2system_8cc_source.html#l00430">System::freeMemSize()</a>, and <a class="el" href="sim_2system_8cc_source.html#l00424">System::memSize()</a>.</p>

</div>
</div>
<a id="a68712b29eaff34a5fdffb982583d0492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68712b29eaff34a5fdffb982583d0492">&#9670;&nbsp;</a></span>unserialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unserialize the memories in the system. </p>
<p>As with the serialization, this action is independent of how the address ranges are mapped to logical memories in the guest system. </p>

<p>Implements <a class="el" href="classSerializable.html#afd7d0fe2730122837f99d2c93dee2308">Serializable</a>.</p>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00372">372</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="cprintf_8hh_source.html#l00162">csprintf()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="miscregs__types_8hh_source.html#l00368">ArmISA::m</a>, <a class="el" href="serialize_8hh_source.html#l00667">UNSERIALIZE_CONTAINER</a>, and <a class="el" href="serialize_8hh_source.html#l00645">UNSERIALIZE_SCALAR</a>.</p>

</div>
</div>
<a id="aba176bbc099adc0ea42abf7b4c6b92ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba176bbc099adc0ea42abf7b4c6b92ec">&#9670;&nbsp;</a></span>unserializeStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::unserializeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpointIn.html">CheckpointIn</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unserialize a specific backing store, identified by a section. </p>

<p class="definition">Definition at line <a class="el" href="physical_8cc_source.html#l00397">397</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p class="reference">References <a class="el" href="serialize_8hh_source.html#l00084">CheckpointIn::cptDir</a>, <a class="el" href="base_2trace_8hh_source.html#l00215">DPRINTF</a>, <a class="el" href="logging_8hh_source.html#l00175">fatal</a>, <a class="el" href="addr__range_8hh_source.html#l00284">AddrRange::size()</a>, <a class="el" href="serialize_8hh_source.html#l00645">UNSERIALIZE_SCALAR</a>, and <a class="el" href="arch_2x86_2types_8hh_source.html#l00105">X86ISA::x</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab350c0762d0512becaba3ef121cec592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab350c0762d0512becaba3ef121cec592">&#9670;&nbsp;</a></span>_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string PhysicalMemory::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00118">118</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<a id="a9143684abd49d9b2dc1a3bd651e00053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9143684abd49d9b2dc1a3bd651e00053">&#9670;&nbsp;</a></span>addrMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRangeMap.html">AddrRangeMap</a>&lt;<a class="el" href="classAbstractMemory.html">AbstractMemory</a>*, 1&gt; PhysicalMemory::addrMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00121">121</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<a id="a9c0b0131d4ca5e342e09cc1303185a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0b0131d4ca5e342e09cc1303185a4c">&#9670;&nbsp;</a></span>backingStore</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classBackingStoreEntry.html">BackingStoreEntry</a>&gt; PhysicalMemory::backingStore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00134">134</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<a id="aa871234aa6c34d601d7382243285a4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa871234aa6c34d601d7382243285a4e2">&#9670;&nbsp;</a></span>memories</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classAbstractMemory.html">AbstractMemory</a>*&gt; PhysicalMemory::memories</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00124">124</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<a id="a5445b02e4913019ec3efcdfbe7576475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5445b02e4913019ec3efcdfbe7576475">&#9670;&nbsp;</a></span>mmapUsingNoReserve</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool PhysicalMemory::mmapUsingNoReserve</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00130">130</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<a id="a5593123b31f52c14675a125076fca73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5593123b31f52c14675a125076fca73e">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PhysicalMemory::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="physical_8hh_source.html#l00127">127</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="physical_8hh_source.html">physical.hh</a></li>
<li>mem/<a class="el" href="physical_8cc_source.html">physical.cc</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:19 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
