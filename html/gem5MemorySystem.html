<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: Memory System in gem5</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Memory <a class="el" href="classSystem.html">System</a> in gem5 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#gem5_MS_MH">MODEL HIERARCHY</a></li>
<li class="level1"><a href="#gem5_CPU">CPU</a></li>
<li class="level1"><a href="#gem5_DCache">DATA CACHE OBJECT</a><ul><li class="level2"><a href="#gem5_MS_TAndDBlock">Tags &amp; Data Block</a></li>
<li class="level2"><a href="#gem5_MS_Queues">MSHR and Write Buffer Queues</a></li>
<li class="level2"><a href="#gem5_MS_Ordering">Memory Access Ordering</a></li>
</ul>
</li>
<li class="level1"><a href="#gem5_MS_Bus">COHERENT BUS OBJECT</a></li>
<li class="level1"><a href="#gem5_MS_SimpleMemory">SIMPLE MEMORY OBJECT</a></li>
<li class="level1"><a href="#gem5_MS_MessageFlow">MESSAGE FLOW</a></li>
</ul>
</div>
<div class="textblock"><p>The document describes memory subsystem in gem5 with focus on program flow during CPU’s simple memory transactions (read or write).</p>
<h1><a class="anchor" id="gem5_MS_MH"></a>
MODEL HIERARCHY</h1>
<p>Model that is used in this document consists of two out-of-order (O3) ARM v7 CPUs with corresponding L1 data caches and Simple Memory. It is created by running gem5 with the following parameters:</p>
<p>configs/example/fs.py &ndash;caches &ndash;cpu-type=arm_detailed &ndash;num-cpus=2</p>
<p>Gem5 uses Simulation Objects (<a class="el" href="classSimObject.html" title="Abstract superclass for simulation objects. ">SimObject</a>) derived objects as basic blocks for building memory system. They are connected via ports with established master/slave hierarchy. Data flow is initiated on master port while the response messages and snoop queries appear on the slave port. The following figure shows the hierarchy of Simulation Objects used in this document:</p>
<div class="image">
<img src="gem5_MS_Fig1.PNG" alt="gem5_MS_Fig1.PNG" width="3cm"/>
<div class="caption">
Simulation Object hierarchy of the model</div></div>
<h1><a class="anchor" id="gem5_CPU"></a>
CPU</h1>
<p>It is not in the scope of this document to describe O3 CPU model in details, so here are only a few relevant notes about the model:</p>
<p><b>Read access </b>is initiated by sending message to the port towards DCache object. If DCache rejects the message (for being blocked or busy) CPU will flush the pipeline and the access will be re-attempted later on. The access is completed upon receiving reply message (ReadRep) from DCache.</p>
<p><b>Write access</b> is initiated by storing the request into store buffer whose context is emptied and sent to DCache on every tick. DCache may also reject the request. Write access is completed when write reply (WriteRep) message is received from DCache.</p>
<p>Load &amp; store buffers (for read and write access) don’t impose any restriction on the number of active memory accesses. Therefore, the maximum number of outstanding CPU’s memory access requests is not limited by CPU Simulation Object but by underlying memory system model.</p>
<p><b>Split memory access</b> is implemented.</p>
<p>The message that is sent by CPU contains memory type (Normal, Device, Strongly Ordered and cachebility) of the accessed region. However, this is not being used by the rest of the model that takes more simplified approach towards memory types.</p>
<h1><a class="anchor" id="gem5_DCache"></a>
DATA CACHE OBJECT</h1>
<p>Data <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> object implements a standard cache structure:</p>
<div class="image">
<img src="gem5_MS_Fig2.PNG" alt="gem5_MS_Fig2.PNG" width="3cm"/>
<div class="caption">
DCache Simulation Object</div></div>
<p><b>Cached memory reads</b> that match particular cache tag (with Valid &amp; Read flags) will be completed (by sending ReadResp to CPU) after a configurable time. Otherwise, the request is forwarded to Miss Status and Handling Register (<a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a>) block.</p>
<p><b>Cached memory writes</b> that match particular cache tag (with Valid, Read &amp; Write flags) will be completed (by sending WriteResp CPU) after the same configurable time. Otherwise, the request is forwarded to Miss Status and Handling Register(MSHR) block.</p>
<p><b>Uncached memory reads</b> are forwarded to <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> block.</p>
<p><b>Uncached memory writes</b> are forwarded to WriteBuffer block.</p>
<p><b>Evicted (&amp; dirty) cache lines</b> are forwarded to WriteBuffer block.</p>
<p>CPU’s access to Data <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> is blocked if any of the following is true:</p>
<ul>
<li><a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> block is full. (The size of MSHR’s buffer is configurable.)</li>
<li>Writeback block is full. (The size of the block’s buffer is configurable.)</li>
<li>The number of outstanding memory accesses against the same memory cache line has reached configurable threshold value – see <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> and Write Buffer for details.</li>
</ul>
<p>Data <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> in block state will reject any request from slave port (from CPU) regardless of whether it would result in cache hit or miss. Note that incoming messages on master port (response messages and snoop requests) are never rejected.</p>
<p><a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> hit on uncachable memory region (unpredicted behaviour according to ARM ARM) will invalidate cache line and fetch data from memory.</p>
<h2><a class="anchor" id="gem5_MS_TAndDBlock"></a>
Tags &amp; Data Block</h2>
<p><a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> lines (referred as blocks in source code) are organised into sets with configurable associativity and size. They have the following status flags:</p><ul>
<li><b>Valid.</b> It holds data. Address tag is valid</li>
<li><b>Read.</b> No read request will be accepted without this flag being set. For example, cache line is valid and unreadable when it waits for write flag to complete write access.</li>
<li><b>Write.</b> It may accept writes. <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> line with Write flags identifies Unique state – no other cache memory holds the copy.</li>
<li><b>Dirty.</b> It needs Writeback when evicted.</li>
</ul>
<p>Read access will hit cache line if address tags match and Valid and Read flags are set. Write access will hit cache line if address tags match and Valid, Read and Write flags are set.</p>
<h2><a class="anchor" id="gem5_MS_Queues"></a>
MSHR and Write Buffer Queues</h2>
<p>Miss Status and Handling Register (<a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a>) queue holds the list of CPU’s outstanding memory requests that require read access to lower memory level. They are:</p><ul>
<li>Cached Read misses.</li>
<li>Cached Write misses.</li>
<li>Uncached reads.</li>
</ul>
<p>WriteBuffer queue holds the following memory requests:</p><ul>
<li>Uncached writes.</li>
<li>Writeback from evicted (&amp; dirty) cache lines.</li>
</ul>
<div class="image">
<img src="gem5_MS_Fig3.PNG" alt="gem5_MS_Fig3.PNG" width="6cm"/>
<div class="caption">
MSHR and Write Buffer Blocks</div></div>
<p>Each memory request is assigned to corresponding <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> object (READ or WRITE on diagram above) that represents particular block (cache line) of memory that has to be read or written in order to complete the command(s). As shown on gigure above, cached read/writes against the same cache line have a common <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> object and will be completed with a single memory access.</p>
<p>The size of the block (and therefore the size of read/write access to lower memory) is:</p><ul>
<li>The size of cache line for cached access &amp; writeback;</li>
<li>As specified in CPU instruction for uncached access.</li>
</ul>
<p>In general, Data <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> model distinguishes between just two memory types:</p><ul>
<li>Normal Cached memory. It is always treated as write back, read and write allocate.</li>
<li>Normal uncached, Device and Strongly Ordered types are treated equally (as uncached memory)</li>
</ul>
<h2><a class="anchor" id="gem5_MS_Ordering"></a>
Memory Access Ordering</h2>
<p>An unique order number is assigned to each CPU read/write request(as they appear on slave port). Order numbers of <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> objects are copied from the first assigned read/write.</p>
<p>Memory read/writes from each of these two queues are executed in order (according to the assigned order number). When both queues are not empty the model will execute memory read from <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a> block unless WriteBuffer is full. It will, however, always preserve the order of read/writes on the same (or overlapping) memory cache line (block).</p>
<p>In summary:</p><ul>
<li>Order of accesses to cached memory is not preserved unless they target the same cache line. For example, the accesses #1, #5 &amp; #10 will complete simultaneously in the same tick (still in order). The access #5 will complete before #3.</li>
<li>Order of all uncached memory writes is preserved. Write#6 always completes before Write#13.</li>
<li>Order to all uncached memory reads is preserved. Read#2 always completes before Read#8.</li>
<li>The order of a read and a write uncached access is not necessarily preserved - unless their access regions overlap. Therefore, Write#6 always completes before Read#8 (they target the same memory block). However, Write#13 may complete before Read#8.</li>
</ul>
<h1><a class="anchor" id="gem5_MS_Bus"></a>
COHERENT BUS OBJECT</h1>
<div class="image">
<img src="gem5_MS_Fig4.PNG" alt="gem5_MS_Fig4.PNG" width="3cm"/>
<div class="caption">
Coherent Bus Object</div></div>
<p>Coherent Bus object provides basic support for snoop protocol:</p>
<p><b>All requests on the slave port</b> are forwarded to the appropriate master port. Requests for cached memory regions are also forwarded to other slave ports (as snoop requests).</p>
<p><b>Master port replies</b> are forwarded to the appropriate slave port.</p>
<p><b>Master port snoop requests</b> are forwarded to all slave ports.</p>
<p><b>Slave port snoop replies</b> are forwarded to the port that was the source of the request. (Note that the source of snoop request can be either slave or master port.)</p>
<p>The bus declares itself blocked for a configurable period of time after any of the following events:</p><ul>
<li>A packet is sent (or failed to be sent) to a slave port.</li>
<li>A reply message is sent to a master port.</li>
<li>Snoop response from one slave port is sent to another slave port.</li>
</ul>
<p>The bus in blocked state rejects the following incoming messages:</p><ul>
<li>Slave port requests.</li>
<li>Master port replies.</li>
<li>Master port snoop requests.</li>
</ul>
<h1><a class="anchor" id="gem5_MS_SimpleMemory"></a>
SIMPLE MEMORY OBJECT</h1>
<p>It never blocks the access on slave port.</p>
<p>Memory read/write takes immediate effect. (Read or write is performed when the request is received).</p>
<p>Reply message is sent after a configurable period of time .</p>
<h1><a class="anchor" id="gem5_MS_MessageFlow"></a>
MESSAGE FLOW</h1>
<h2><a class="anchor" id="gem5_MS_Ordering"></a>
Memory Access Ordering</h2>
<p>The following diagram shows read access that hits Data <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> line with Valid and Read flags:</p>
<div class="image">
<img src="gem5_MS_Fig5.PNG" alt="gem5_MS_Fig5.PNG" width="3cm"/>
<div class="caption">
Read Hit (Read flag must be set in cache line)</div></div>
<p><a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> miss read access will generate the following sequence of messages:</p>
<div class="image">
<img src="gem5_MS_Fig6.PNG" alt="gem5_MS_Fig6.PNG" width="3cm"/>
<div class="caption">
Read Miss with snoop reply</div></div>
<p>Note that bus object never gets response from both DCache2 and Memory object. It sends the very same ReadReq package (message) object to memory and data cache. When Data <a class="el" href="classCache.html" title="A coherent cache that can be arranged in flexible topologies. ">Cache</a> wants to reply on snoop request it marks the message with MEM_INHIBIT flag that tells Memory object not to process the message.</p>
<h2><a class="anchor" id="gem5_MS_Ordering"></a>
Memory Access Ordering</h2>
<p>The following diagram shows write access that hits DCache1 cache line with Valid &amp; Write flags:</p>
<div class="image">
<img src="gem5_MS_Fig7.PNG" alt="gem5_MS_Fig7.PNG" width="3cm"/>
<div class="caption">
Write Hit (with Write flag set in cache line)</div></div>
<p>Next figure shows write access that hits DCache1 cache line with Valid but no Write flags – which qualifies as write miss. DCache1 issues UpgradeReq to obtain write permission. DCache2::snoopTiming will invalidate cache line that has been hit. Note that UpgradeResp message doesn’t carry data.</p>
<div class="image">
<img src="gem5_MS_Fig8.PNG" alt="gem5_MS_Fig8.PNG" width="3cm"/>
<div class="caption">
Write Miss – matching tag with no Write flag</div></div>
<p>The next diagram shows write miss in DCache. ReadExReq invalidates cache line in DCache2. ReadExResp carries the content of memory cache line.</p>
<div class="image">
<img src="gem5_MS_Fig9.PNG" alt="gem5_MS_Fig9.PNG" width="3cm"/>
<div class="caption">
Miss - no matching tag</div></div>
 </div></div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:13 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
