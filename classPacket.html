<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: Packet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPacket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Packet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> is used to encapsulate a transfer between two objects in the memory system (e.g., the L1 and L2 cache).  
 <a href="classPacket.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="packet_8hh_source.html">packet.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Packet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPacket.png" usemap="#Packet_map" alt=""/>
  <map id="Packet_map" name="Packet_map">
<area href="classPrintable.html" title="Abstract base class for objects which support being printed to a stream for debugging. " alt="Printable" shape="rect" coords="0,0,62,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket_1_1PrintReqState.html">PrintReqState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object used to maintain state of a PrintReq.  <a href="classPacket_1_1PrintReqState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPacket_1_1SenderState.html">SenderState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual base opaque structure used to hold state associated with the packet (e.g., an <a class="el" href="classMSHR.html" title="Miss Status and handling Register. ">MSHR</a>), specific to a <a class="el" href="classSimObject.html" title="Abstract superclass for simulation objects. ">SimObject</a> that sees the packet.  <a href="structPacket_1_1SenderState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae0916804186bffa24ea64d52324391b7"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae0916804186bffa24ea64d52324391b7">FlagsType</a></td></tr>
<tr class="separator:ae0916804186bffa24ea64d52324391b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5901a7043b7770017d3d2e85fa0fca36"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="classPacket.html#a5901a7043b7770017d3d2e85fa0fca36">Flags</a>&lt; <a class="el" href="classPacket.html#ae0916804186bffa24ea64d52324391b7">FlagsType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a5901a7043b7770017d3d2e85fa0fca36">Flags</a></td></tr>
<tr class="separator:a5901a7043b7770017d3d2e85fa0fca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3fdea469fc4024c95c49aab34742e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classMemCmd.html#ae5c39c2de0ad998b5176bc519b358102">MemCmd::Command</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae9a3fdea469fc4024c95c49aab34742e">Command</a></td></tr>
<tr class="separator:ae9a3fdea469fc4024c95c49aab34742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8036e59fcb2cf3391e8bb9d0ffc37b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a8036e59fcb2cf3391e8bb9d0ffc37b9e">pushSenderState</a> (<a class="el" href="structPacket_1_1SenderState.html">SenderState</a> *sender_state)</td></tr>
<tr class="memdesc:a8036e59fcb2cf3391e8bb9d0ffc37b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a new sender state to the packet and make the current sender state the predecessor of the new one.  <a href="#a8036e59fcb2cf3391e8bb9d0ffc37b9e">More...</a><br /></td></tr>
<tr class="separator:a8036e59fcb2cf3391e8bb9d0ffc37b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ab9a18584eefa18e4c2b41f208b8e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPacket_1_1SenderState.html">SenderState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#af6ab9a18584eefa18e4c2b41f208b8e6">popSenderState</a> ()</td></tr>
<tr class="memdesc:af6ab9a18584eefa18e4c2b41f208b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the top of the state stack and return a pointer to it.  <a href="#af6ab9a18584eefa18e4c2b41f208b8e6">More...</a><br /></td></tr>
<tr class="separator:af6ab9a18584eefa18e4c2b41f208b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404e7d969de3bc92b650843d0dd6f34f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a404e7d969de3bc92b650843d0dd6f34f"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a404e7d969de3bc92b650843d0dd6f34f">findNextSenderState</a> () const</td></tr>
<tr class="memdesc:a404e7d969de3bc92b650843d0dd6f34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through the sender state stack and return the first instance that is of type T (as determined by a dynamic_cast).  <a href="#a404e7d969de3bc92b650843d0dd6f34f">More...</a><br /></td></tr>
<tr class="separator:a404e7d969de3bc92b650843d0dd6f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0f371dc0969b06e80c0fd4fa558b1a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a1f0f371dc0969b06e80c0fd4fa558b1a">cmdString</a> () const</td></tr>
<tr class="memdesc:a1f0f371dc0969b06e80c0fd4fa558b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string name of the cmd field (for debugging and tracing).  <a href="#a1f0f371dc0969b06e80c0fd4fa558b1a">More...</a><br /></td></tr>
<tr class="separator:a1f0f371dc0969b06e80c0fd4fa558b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a73789b61dfcffbba858ea6210ef4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a14a73789b61dfcffbba858ea6210ef4c">cmdToIndex</a> () const</td></tr>
<tr class="memdesc:a14a73789b61dfcffbba858ea6210ef4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of this command.  <a href="#a14a73789b61dfcffbba858ea6210ef4c">More...</a><br /></td></tr>
<tr class="separator:a14a73789b61dfcffbba858ea6210ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c89f5514a473f96561758b00c4a5e00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a1c89f5514a473f96561758b00c4a5e00">isRead</a> () const</td></tr>
<tr class="separator:a1c89f5514a473f96561758b00c4a5e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec89f98657b94e77f4f7a3087dfe690c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aec89f98657b94e77f4f7a3087dfe690c">isWrite</a> () const</td></tr>
<tr class="separator:aec89f98657b94e77f4f7a3087dfe690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64520e61c50912cbe56e3c408a443ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad64520e61c50912cbe56e3c408a443ac">isUpgrade</a> () const</td></tr>
<tr class="separator:ad64520e61c50912cbe56e3c408a443ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9867cdbf0c0157b274dc11fe177a449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ac9867cdbf0c0157b274dc11fe177a449">isRequest</a> () const</td></tr>
<tr class="separator:ac9867cdbf0c0157b274dc11fe177a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae116431868d1c7f6b0dd127bbb7faeab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae116431868d1c7f6b0dd127bbb7faeab">isResponse</a> () const</td></tr>
<tr class="separator:ae116431868d1c7f6b0dd127bbb7faeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a63311f59c1582ba8a4419e14dfb94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a85a63311f59c1582ba8a4419e14dfb94">needsWritable</a> () const</td></tr>
<tr class="separator:a85a63311f59c1582ba8a4419e14dfb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb255770a0a1278960af6ffa1e0ceb64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#abb255770a0a1278960af6ffa1e0ceb64">needsResponse</a> () const</td></tr>
<tr class="separator:abb255770a0a1278960af6ffa1e0ceb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9975fd49c410e40ac9b6c5ebc872caa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad9975fd49c410e40ac9b6c5ebc872caa">isInvalidate</a> () const</td></tr>
<tr class="separator:ad9975fd49c410e40ac9b6c5ebc872caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3d51b535ec42973453f5584dc16cb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aee3d51b535ec42973453f5584dc16cb6">isEviction</a> () const</td></tr>
<tr class="separator:aee3d51b535ec42973453f5584dc16cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1382602367d7ce5546d941e7bb13d8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad1382602367d7ce5546d941e7bb13d8f">isClean</a> () const</td></tr>
<tr class="separator:ad1382602367d7ce5546d941e7bb13d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66394881a222e2bbc3abb33783df0f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a66394881a222e2bbc3abb33783df0f46">fromCache</a> () const</td></tr>
<tr class="separator:a66394881a222e2bbc3abb33783df0f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2875abee78be7cb12a52829cd793213d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a2875abee78be7cb12a52829cd793213d">isWriteback</a> () const</td></tr>
<tr class="separator:a2875abee78be7cb12a52829cd793213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389afe9616729132378ab8228a74441d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a389afe9616729132378ab8228a74441d">hasData</a> () const</td></tr>
<tr class="separator:a389afe9616729132378ab8228a74441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae096121f2a49ded72e13e144089dce7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae096121f2a49ded72e13e144089dce7c">hasRespData</a> () const</td></tr>
<tr class="separator:ae096121f2a49ded72e13e144089dce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3ec691f080416b43c501f974b176f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a4dd3ec691f080416b43c501f974b176f">isLLSC</a> () const</td></tr>
<tr class="separator:a4dd3ec691f080416b43c501f974b176f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f5ba118cd03b6948424973cfe46154"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a58f5ba118cd03b6948424973cfe46154">isError</a> () const</td></tr>
<tr class="separator:a58f5ba118cd03b6948424973cfe46154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a4bf642d67ecbba475a400c0842066"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a60a4bf642d67ecbba475a400c0842066">isPrint</a> () const</td></tr>
<tr class="separator:a60a4bf642d67ecbba475a400c0842066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ee0394a64976dcca1035076e363131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aa8ee0394a64976dcca1035076e363131">isFlush</a> () const</td></tr>
<tr class="separator:aa8ee0394a64976dcca1035076e363131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2db9fe64102760c36d61a948dc6414"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aea2db9fe64102760c36d61a948dc6414">isWholeLineWrite</a> (unsigned blk_size)</td></tr>
<tr class="separator:aea2db9fe64102760c36d61a948dc6414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bab6f4a0b9552b6555e57d0cf86b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a72bab6f4a0b9552b6555e57d0cf86b99">setExpressSnoop</a> ()</td></tr>
<tr class="memdesc:a72bab6f4a0b9552b6555e57d0cf86b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The express snoop flag is used for two purposes.  <a href="#a72bab6f4a0b9552b6555e57d0cf86b99">More...</a><br /></td></tr>
<tr class="separator:a72bab6f4a0b9552b6555e57d0cf86b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4793369116c8c7782ed5033539c7f543"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a4793369116c8c7782ed5033539c7f543">isExpressSnoop</a> () const</td></tr>
<tr class="separator:a4793369116c8c7782ed5033539c7f543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d124a428a7bca01c40c679050aaef5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a0d124a428a7bca01c40c679050aaef5c">setResponderHadWritable</a> ()</td></tr>
<tr class="memdesc:a0d124a428a7bca01c40c679050aaef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">On responding to a snoop request (which only happens for Modified or Owned lines), make sure that we can transform an Owned response to a Modified one.  <a href="#a0d124a428a7bca01c40c679050aaef5c">More...</a><br /></td></tr>
<tr class="separator:a0d124a428a7bca01c40c679050aaef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828c8eada6caef43d3b13ca739ebb961"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a828c8eada6caef43d3b13ca739ebb961">responderHadWritable</a> () const</td></tr>
<tr class="separator:a828c8eada6caef43d3b13ca739ebb961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b18aed3bc8105f9a44a888d8094648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a49b18aed3bc8105f9a44a888d8094648">copyResponderFlags</a> (const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt)</td></tr>
<tr class="memdesc:a49b18aed3bc8105f9a44a888d8094648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the reponse flags from an input packet to this packet.  <a href="#a49b18aed3bc8105f9a44a888d8094648">More...</a><br /></td></tr>
<tr class="separator:a49b18aed3bc8105f9a44a888d8094648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836e225e423e0c4abf5811682b5a3cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a836e225e423e0c4abf5811682b5a3cdb">setWriteThrough</a> ()</td></tr>
<tr class="memdesc:a836e225e423e0c4abf5811682b5a3cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writeback/writeclean cmd gets propagated further downstream by the receiver when the flag is set.  <a href="#a836e225e423e0c4abf5811682b5a3cdb">More...</a><br /></td></tr>
<tr class="separator:a836e225e423e0c4abf5811682b5a3cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b7449d2290af366ffd6dd8f59ebe45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a68b7449d2290af366ffd6dd8f59ebe45">clearWriteThrough</a> ()</td></tr>
<tr class="separator:a68b7449d2290af366ffd6dd8f59ebe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2c132f904d455ffac6057faf5a584"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a5bb2c132f904d455ffac6057faf5a584">writeThrough</a> () const</td></tr>
<tr class="separator:a5bb2c132f904d455ffac6057faf5a584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa0fbd34b0d03fbee86a1df3c81c5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#adfa0fbd34b0d03fbee86a1df3c81c5c1">setSatisfied</a> ()</td></tr>
<tr class="memdesc:adfa0fbd34b0d03fbee86a1df3c81c5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> when a request hits in a cache and the cache is not going to respond.  <a href="#adfa0fbd34b0d03fbee86a1df3c81c5c1">More...</a><br /></td></tr>
<tr class="separator:adfa0fbd34b0d03fbee86a1df3c81c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db65d99eef3f53f20af61190883d741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a0db65d99eef3f53f20af61190883d741">satisfied</a> () const</td></tr>
<tr class="separator:a0db65d99eef3f53f20af61190883d741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe71cc940de59979daccabb38434546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aafe71cc940de59979daccabb38434546">setSuppressFuncError</a> ()</td></tr>
<tr class="separator:aafe71cc940de59979daccabb38434546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe90926af9d31f320e5800b04cb76bed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#abe90926af9d31f320e5800b04cb76bed">suppressFuncError</a> () const</td></tr>
<tr class="separator:abe90926af9d31f320e5800b04cb76bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed3d512e1660940c23561a0605f2ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a4ed3d512e1660940c23561a0605f2ab3">setBlockCached</a> ()</td></tr>
<tr class="separator:a4ed3d512e1660940c23561a0605f2ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184768b024571a5c3a4e6f36bdf5170"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a3184768b024571a5c3a4e6f36bdf5170">isBlockCached</a> () const</td></tr>
<tr class="separator:a3184768b024571a5c3a4e6f36bdf5170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb432d9d7a922312dbd1ef8a876162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad3fb432d9d7a922312dbd1ef8a876162">clearBlockCached</a> ()</td></tr>
<tr class="separator:ad3fb432d9d7a922312dbd1ef8a876162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873cf94ccd31edf1acc095f1b9015554"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a873cf94ccd31edf1acc095f1b9015554">qosValue</a> () const</td></tr>
<tr class="memdesc:a873cf94ccd31edf1acc095f1b9015554"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceQoS.html">QoS</a> Value getter Returns 0 if <a class="el" href="namespaceQoS.html">QoS</a> value was never set (constructor default).  <a href="#a873cf94ccd31edf1acc095f1b9015554">More...</a><br /></td></tr>
<tr class="separator:a873cf94ccd31edf1acc095f1b9015554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449abea7fb67b1b6e1a56ea498406eab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a449abea7fb67b1b6e1a56ea498406eab">qosValue</a> (const uint8_t qos_value)</td></tr>
<tr class="memdesc:a449abea7fb67b1b6e1a56ea498406eab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceQoS.html">QoS</a> Value setter Interface for setting <a class="el" href="namespaceQoS.html">QoS</a> priority value of the packet.  <a href="#a449abea7fb67b1b6e1a56ea498406eab">More...</a><br /></td></tr>
<tr class="separator:a449abea7fb67b1b6e1a56ea498406eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f5b1c9a747b4bf94bc3d1993467f65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="request_8hh.html#ac366b729262fd8e7cbd3283da6f775cf">MasterID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a41f5b1c9a747b4bf94bc3d1993467f65">masterId</a> () const</td></tr>
<tr class="separator:a41f5b1c9a747b4bf94bc3d1993467f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0099781d30971c8dc263332474851a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a0099781d30971c8dc263332474851a7c">setBadAddress</a> ()</td></tr>
<tr class="separator:a0099781d30971c8dc263332474851a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa8840024624ac34bf619b87de8976e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a8aa8840024624ac34bf619b87de8976e">copyError</a> (<a class="el" href="classPacket.html">Packet</a> *pkt)</td></tr>
<tr class="separator:a8aa8840024624ac34bf619b87de8976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b9bb469e6879c03c73effe3640634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a5d8b9bb469e6879c03c73effe3640634">getAddr</a> () const</td></tr>
<tr class="separator:a5d8b9bb469e6879c03c73effe3640634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc778666940292e86cad8b4e0aa23835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#acc778666940292e86cad8b4e0aa23835">setAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> _addr)</td></tr>
<tr class="memdesc:acc778666940292e86cad8b4e0aa23835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the address of this packet mid-transaction.  <a href="#acc778666940292e86cad8b4e0aa23835">More...</a><br /></td></tr>
<tr class="separator:acc778666940292e86cad8b4e0aa23835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1f26587ac7e1e5790b04931e35f64d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aaf1f26587ac7e1e5790b04931e35f64d">getSize</a> () const</td></tr>
<tr class="separator:aaf1f26587ac7e1e5790b04931e35f64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71d1ff754f712c337e8908a1595f8a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrRange.html">AddrRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aa71d1ff754f712c337e8908a1595f8a0">getAddrRange</a> () const</td></tr>
<tr class="memdesc:aa71d1ff754f712c337e8908a1595f8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address range to which this packet belongs.  <a href="#aa71d1ff754f712c337e8908a1595f8a0">More...</a><br /></td></tr>
<tr class="separator:aa71d1ff754f712c337e8908a1595f8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae868effb4ada6beba486666a63304ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae868effb4ada6beba486666a63304ec7">getOffset</a> (unsigned int blk_size) const</td></tr>
<tr class="separator:ae868effb4ada6beba486666a63304ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad143614d376622e093aaf4324106bed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad143614d376622e093aaf4324106bed1">getBlockAddr</a> (unsigned int blk_size) const</td></tr>
<tr class="separator:ad143614d376622e093aaf4324106bed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85c7ecfa5461f6804ad4dbaec28b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aca85c7ecfa5461f6804ad4dbaec28b29">isSecure</a> () const</td></tr>
<tr class="separator:aca85c7ecfa5461f6804ad4dbaec28b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513d3d147c657f34b45e1c2fbf05cddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAtomicOpFunctor.html">AtomicOpFunctor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a513d3d147c657f34b45e1c2fbf05cddc">getAtomicOp</a> () const</td></tr>
<tr class="memdesc:a513d3d147c657f34b45e1c2fbf05cddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor function to atomic op.  <a href="#a513d3d147c657f34b45e1c2fbf05cddc">More...</a><br /></td></tr>
<tr class="separator:a513d3d147c657f34b45e1c2fbf05cddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360150749606cbb2a28ab49e5351fbab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a360150749606cbb2a28ab49e5351fbab">isAtomicOp</a> () const</td></tr>
<tr class="separator:a360150749606cbb2a28ab49e5351fbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85805a56a4e8ebd757bbab42e1c8d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad85805a56a4e8ebd757bbab42e1c8d5d">convertScToWrite</a> ()</td></tr>
<tr class="memdesc:ad85805a56a4e8ebd757bbab42e1c8d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">It has been determined that the SC packet should successfully update memory.  <a href="#ad85805a56a4e8ebd757bbab42e1c8d5d">More...</a><br /></td></tr>
<tr class="separator:ad85805a56a4e8ebd757bbab42e1c8d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8600439796528ac5e97b8617a5b090f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a8600439796528ac5e97b8617a5b090f1">convertLlToRead</a> ()</td></tr>
<tr class="memdesc:a8600439796528ac5e97b8617a5b090f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">When ruby is in use, Ruby will monitor the cache line and the phys memory should treat LL ops as normal reads.  <a href="#a8600439796528ac5e97b8617a5b090f1">More...</a><br /></td></tr>
<tr class="separator:a8600439796528ac5e97b8617a5b090f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a9d9134824b4c5ee7eb96c81ceb5d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a32a9d9134824b4c5ee7eb96c81ceb5d5">Packet</a> (const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;_req, <a class="el" href="classMemCmd.html">MemCmd</a> _cmd)</td></tr>
<tr class="memdesc:a32a9d9134824b4c5ee7eb96c81ceb5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a32a9d9134824b4c5ee7eb96c81ceb5d5">More...</a><br /></td></tr>
<tr class="separator:a32a9d9134824b4c5ee7eb96c81ceb5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9889eb9a89ae9e7676f91022d861d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a6a9889eb9a89ae9e7676f91022d861d0">Packet</a> (const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;_req, <a class="el" href="classMemCmd.html">MemCmd</a> _cmd, int _blkSize, <a class="el" href="packet_8hh.html#ad38dfafec51e964d93d60cdec3bfb489">PacketId</a> _id=0)</td></tr>
<tr class="memdesc:a6a9889eb9a89ae9e7676f91022d861d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate constructor if you are trying to create a packet with a request that is for a whole block, not the address from the req.  <a href="#a6a9889eb9a89ae9e7676f91022d861d0">More...</a><br /></td></tr>
<tr class="separator:a6a9889eb9a89ae9e7676f91022d861d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa320b67952756edac635b0683f16ca31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aa320b67952756edac635b0683f16ca31">Packet</a> (const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt, bool clear_flags, bool alloc_data)</td></tr>
<tr class="memdesc:aa320b67952756edac635b0683f16ca31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate constructor for copying a packet.  <a href="#aa320b67952756edac635b0683f16ca31">More...</a><br /></td></tr>
<tr class="separator:aa320b67952756edac635b0683f16ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48938391fb7e07460bb0e01198ae5ede"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a48938391fb7e07460bb0e01198ae5ede">~Packet</a> ()</td></tr>
<tr class="memdesc:a48938391fb7e07460bb0e01198ae5ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">clean up packet variables  <a href="#a48938391fb7e07460bb0e01198ae5ede">More...</a><br /></td></tr>
<tr class="separator:a48938391fb7e07460bb0e01198ae5ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1ba3f32ebb3c8be10cf9b58ca54e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a51e1ba3f32ebb3c8be10cf9b58ca54e0">makeResponse</a> ()</td></tr>
<tr class="memdesc:a51e1ba3f32ebb3c8be10cf9b58ca54e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a request packet and modify it in place to be suitable for returning as a response to that request.  <a href="#a51e1ba3f32ebb3c8be10cf9b58ca54e0">More...</a><br /></td></tr>
<tr class="separator:a51e1ba3f32ebb3c8be10cf9b58ca54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f71e6885712d4951e70eaba2e364cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a79f71e6885712d4951e70eaba2e364cb">makeAtomicResponse</a> ()</td></tr>
<tr class="separator:a79f71e6885712d4951e70eaba2e364cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad570f51a677a215d45a1d04b00cbb8f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad570f51a677a215d45a1d04b00cbb8f6">makeTimingResponse</a> ()</td></tr>
<tr class="separator:ad570f51a677a215d45a1d04b00cbb8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2a4a47715e7fa38b83a42ce217e672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a4d2a4a47715e7fa38b83a42ce217e672">setFunctionalResponseStatus</a> (bool success)</td></tr>
<tr class="separator:a4d2a4a47715e7fa38b83a42ce217e672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754476a15d1fff71aa3c0884416368aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a754476a15d1fff71aa3c0884416368aa">setSize</a> (unsigned <a class="el" href="classPacket.html#a2ec256dae61980f980ada9d6071c25ab">size</a>)</td></tr>
<tr class="separator:a754476a15d1fff71aa3c0884416368aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f406cf48fe096291edf795a3c46b98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a52f406cf48fe096291edf795a3c46b98">matchBlockAddr</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classPacket.html#ae60308db1a818c0ed3c923fae7c6989e">addr</a>, const bool is_secure, const int blk_size) const</td></tr>
<tr class="memdesc:a52f406cf48fe096291edf795a3c46b98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if packet corresponds to a given block-aligned address and address space.  <a href="#a52f406cf48fe096291edf795a3c46b98">More...</a><br /></td></tr>
<tr class="separator:a52f406cf48fe096291edf795a3c46b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe311e0cf09e4a65aca329626d8851b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a8fe311e0cf09e4a65aca329626d8851b">matchBlockAddr</a> (const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt, const int blk_size) const</td></tr>
<tr class="memdesc:a8fe311e0cf09e4a65aca329626d8851b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if this packet refers to the same block-aligned address and address space as another packet.  <a href="#a8fe311e0cf09e4a65aca329626d8851b">More...</a><br /></td></tr>
<tr class="separator:a8fe311e0cf09e4a65aca329626d8851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c0bdd57c5359e7d87426bafd1c2601"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ab9c0bdd57c5359e7d87426bafd1c2601">matchAddr</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classPacket.html#ae60308db1a818c0ed3c923fae7c6989e">addr</a>, const bool is_secure) const</td></tr>
<tr class="memdesc:ab9c0bdd57c5359e7d87426bafd1c2601"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if packet corresponds to a given address and address space.  <a href="#ab9c0bdd57c5359e7d87426bafd1c2601">More...</a><br /></td></tr>
<tr class="separator:ab9c0bdd57c5359e7d87426bafd1c2601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae265ff27bb1d6ada0ccd80161f0c1062"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae265ff27bb1d6ada0ccd80161f0c1062">matchAddr</a> (const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> pkt) const</td></tr>
<tr class="memdesc:ae265ff27bb1d6ada0ccd80161f0c1062"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if this packet refers to the same address and address space as another packet.  <a href="#ae265ff27bb1d6ada0ccd80161f0c1062">More...</a><br /></td></tr>
<tr class="separator:ae265ff27bb1d6ada0ccd80161f0c1062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef2950692a91ec29f441bea7127b11f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ef2950692a91ec29f441bea7127b11f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a5ef2950692a91ec29f441bea7127b11f">getRaw</a> () const</td></tr>
<tr class="memdesc:a5ef2950692a91ec29f441bea7127b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data in the packet without byte swapping.  <a href="#a5ef2950692a91ec29f441bea7127b11f">More...</a><br /></td></tr>
<tr class="separator:a5ef2950692a91ec29f441bea7127b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda4d98dcf9f9948996fa2e98f1ab1c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adda4d98dcf9f9948996fa2e98f1ab1c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#adda4d98dcf9f9948996fa2e98f1ab1c3">setRaw</a> (T v)</td></tr>
<tr class="memdesc:adda4d98dcf9f9948996fa2e98f1ab1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the value in the data pointer to v without byte swapping.  <a href="#adda4d98dcf9f9948996fa2e98f1ab1c3">More...</a><br /></td></tr>
<tr class="separator:adda4d98dcf9f9948996fa2e98f1ab1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aaefcd9a94849f7b4956802e051046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a18aaefcd9a94849f7b4956802e051046">trySatisfyFunctional</a> (<a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> other)</td></tr>
<tr class="memdesc:a18aaefcd9a94849f7b4956802e051046"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> a functional request against a memory value stored in another packet (i.e.  <a href="#a18aaefcd9a94849f7b4956802e051046">More...</a><br /></td></tr>
<tr class="separator:a18aaefcd9a94849f7b4956802e051046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554a23c5c950992c7d53f323f03fb95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ac554a23c5c950992c7d53f323f03fb95">mustCheckAbove</a> () const</td></tr>
<tr class="memdesc:ac554a23c5c950992c7d53f323f03fb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the request need to check for cached copies of the same block in the memory hierarchy above.  <a href="#ac554a23c5c950992c7d53f323f03fb95">More...</a><br /></td></tr>
<tr class="separator:ac554a23c5c950992c7d53f323f03fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dd5b3ed1383009029c27edfaf24d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a40dd5b3ed1383009029c27edfaf24d07">isCleanEviction</a> () const</td></tr>
<tr class="memdesc:a40dd5b3ed1383009029c27edfaf24d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this packet a clean eviction, including both actual clean evict packets, but also clean writebacks.  <a href="#a40dd5b3ed1383009029c27edfaf24d07">More...</a><br /></td></tr>
<tr class="separator:a40dd5b3ed1383009029c27edfaf24d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d78f7c3553b71471d97e1a5db7f1450"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a8d78f7c3553b71471d97e1a5db7f1450">isMaskedWrite</a> () const</td></tr>
<tr class="separator:a8d78f7c3553b71471d97e1a5db7f1450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99350ab3793239acca64a0ed4162b6da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a99350ab3793239acca64a0ed4162b6da">trySatisfyFunctional</a> (<a class="el" href="classPrintable.html">Printable</a> *obj, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> base, bool is_secure, int <a class="el" href="classPacket.html#a2ec256dae61980f980ada9d6071c25ab">size</a>, uint8_t *_data)</td></tr>
<tr class="memdesc:a99350ab3793239acca64a0ed4162b6da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> a functional request against a memory value represented by a base/size pair and an associated data array.  <a href="#a99350ab3793239acca64a0ed4162b6da">More...</a><br /></td></tr>
<tr class="separator:a99350ab3793239acca64a0ed4162b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a177ee6ddce59da49869cfeecc7bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#abf1a177ee6ddce59da49869cfeecc7bc">pushLabel</a> (const std::string &amp;lbl)</td></tr>
<tr class="memdesc:abf1a177ee6ddce59da49869cfeecc7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push label for PrintReq (safe to call unconditionally).  <a href="#abf1a177ee6ddce59da49869cfeecc7bc">More...</a><br /></td></tr>
<tr class="separator:abf1a177ee6ddce59da49869cfeecc7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d4bd566aee12a370dc9180e064bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad28d4bd566aee12a370dc9180e064bea">popLabel</a> ()</td></tr>
<tr class="memdesc:ad28d4bd566aee12a370dc9180e064bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop label for PrintReq (safe to call unconditionally).  <a href="#ad28d4bd566aee12a370dc9180e064bea">More...</a><br /></td></tr>
<tr class="separator:ad28d4bd566aee12a370dc9180e064bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a19b40cc01e43c41bc99fb7fadb89ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a7a19b40cc01e43c41bc99fb7fadb89ea">print</a> (std::ostream &amp;o, int verbosity=0, const std::string &amp;prefix=&quot;&quot;) const</td></tr>
<tr class="separator:a7a19b40cc01e43c41bc99fb7fadb89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81320dcb565590895648b0d2a427763"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad81320dcb565590895648b0d2a427763">print</a> () const</td></tr>
<tr class="memdesc:ad81320dcb565590895648b0d2a427763"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-args wrapper of print(std::ostream...) meant to be invoked from DPRINTFs avoiding string overheads in fast mode.  <a href="#ad81320dcb565590895648b0d2a427763">More...</a><br /></td></tr>
<tr class="separator:ad81320dcb565590895648b0d2a427763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a115cf2fb1e5b871e02e6286d8b569d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a115cf2fb1e5b871e02e6286d8b569d17">setCacheResponding</a> ()</td></tr>
<tr class="memdesc:a115cf2fb1e5b871e02e6286d8b569d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snoop flags.  <a href="#a115cf2fb1e5b871e02e6286d8b569d17">More...</a><br /></td></tr>
<tr class="separator:a115cf2fb1e5b871e02e6286d8b569d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14141460ec6de11c61eb6dc2ab5eda8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a14141460ec6de11c61eb6dc2ab5eda8f">cacheResponding</a> () const</td></tr>
<tr class="separator:a14141460ec6de11c61eb6dc2ab5eda8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe12093acc96f02e3f806a4c0003c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#afbe12093acc96f02e3f806a4c0003c83">setHasSharers</a> ()</td></tr>
<tr class="memdesc:afbe12093acc96f02e3f806a4c0003c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">On fills, the hasSharers flag is used by the caches in combination with the cacheResponding flag, as clarified above.  <a href="#afbe12093acc96f02e3f806a4c0003c83">More...</a><br /></td></tr>
<tr class="separator:afbe12093acc96f02e3f806a4c0003c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85724e95fcdde23c4f33840cfa04bc98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a85724e95fcdde23c4f33840cfa04bc98">hasSharers</a> () const</td></tr>
<tr class="separator:a85724e95fcdde23c4f33840cfa04bc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data accessor mehtods</div></td></tr>
<tr class="memitem:afe77e06caa81808b679abf9291dfc44f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe77e06caa81808b679abf9291dfc44f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#afe77e06caa81808b679abf9291dfc44f">dataStatic</a> (T *p)</td></tr>
<tr class="memdesc:afe77e06caa81808b679abf9291dfc44f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the data pointer to the following value that should not be freed.  <a href="#afe77e06caa81808b679abf9291dfc44f">More...</a><br /></td></tr>
<tr class="separator:afe77e06caa81808b679abf9291dfc44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8d23baa08f1d5efd7e3321dc3d2fa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d8d23baa08f1d5efd7e3321dc3d2fa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a8d8d23baa08f1d5efd7e3321dc3d2fa1">dataStaticConst</a> (const T *p)</td></tr>
<tr class="memdesc:a8d8d23baa08f1d5efd7e3321dc3d2fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the data pointer to the following value that should not be freed.  <a href="#a8d8d23baa08f1d5efd7e3321dc3d2fa1">More...</a><br /></td></tr>
<tr class="separator:a8d8d23baa08f1d5efd7e3321dc3d2fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86da42d7b9a882873deb75798e8ff8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa86da42d7b9a882873deb75798e8ff8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#aa86da42d7b9a882873deb75798e8ff8d">dataDynamic</a> (T *p)</td></tr>
<tr class="memdesc:aa86da42d7b9a882873deb75798e8ff8d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the data pointer to a value that should have delete [] called on it.  <a href="#aa86da42d7b9a882873deb75798e8ff8d">More...</a><br /></td></tr>
<tr class="separator:aa86da42d7b9a882873deb75798e8ff8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b89d352ac3256638f40819edfa38837"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b89d352ac3256638f40819edfa38837"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a4b89d352ac3256638f40819edfa38837">getPtr</a> ()</td></tr>
<tr class="memdesc:a4b89d352ac3256638f40819edfa38837"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the data ptr.  <a href="#a4b89d352ac3256638f40819edfa38837">More...</a><br /></td></tr>
<tr class="separator:a4b89d352ac3256638f40819edfa38837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164a45730b5b52b42fe0cf7c586dec9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a164a45730b5b52b42fe0cf7c586dec9c"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a164a45730b5b52b42fe0cf7c586dec9c">getConstPtr</a> () const</td></tr>
<tr class="separator:a164a45730b5b52b42fe0cf7c586dec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54785af5ba6515f4b7453c763f01329"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa54785af5ba6515f4b7453c763f01329"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#aa54785af5ba6515f4b7453c763f01329">getBE</a> () const</td></tr>
<tr class="memdesc:aa54785af5ba6515f4b7453c763f01329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data in the packet byte swapped from big endian to host endian.  <a href="#aa54785af5ba6515f4b7453c763f01329">More...</a><br /></td></tr>
<tr class="separator:aa54785af5ba6515f4b7453c763f01329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c349e851d04dc20402a8dd0fddf102d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c349e851d04dc20402a8dd0fddf102d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a7c349e851d04dc20402a8dd0fddf102d">getLE</a> () const</td></tr>
<tr class="memdesc:a7c349e851d04dc20402a8dd0fddf102d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data in the packet byte swapped from little endian to host endian.  <a href="#a7c349e851d04dc20402a8dd0fddf102d">More...</a><br /></td></tr>
<tr class="separator:a7c349e851d04dc20402a8dd0fddf102d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e64401909b90c4170dcd1bcd8775725"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e64401909b90c4170dcd1bcd8775725"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a4e64401909b90c4170dcd1bcd8775725">get</a> (<a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> endian) const</td></tr>
<tr class="memdesc:a4e64401909b90c4170dcd1bcd8775725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data in the packet byte swapped from the specified endianness.  <a href="#a4e64401909b90c4170dcd1bcd8775725">More...</a><br /></td></tr>
<tr class="separator:a4e64401909b90c4170dcd1bcd8775725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f3979ae4a456c05b69809a0025e46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a439f3979ae4a456c05b69809a0025e46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a439f3979ae4a456c05b69809a0025e46">setBE</a> (T v)</td></tr>
<tr class="memdesc:a439f3979ae4a456c05b69809a0025e46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the value in the data pointer to v as big endian.  <a href="#a439f3979ae4a456c05b69809a0025e46">More...</a><br /></td></tr>
<tr class="separator:a439f3979ae4a456c05b69809a0025e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25668a7254542eab91f95ae46c2f1fea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25668a7254542eab91f95ae46c2f1fea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#a25668a7254542eab91f95ae46c2f1fea">setLE</a> (T v)</td></tr>
<tr class="memdesc:a25668a7254542eab91f95ae46c2f1fea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the value in the data pointer to v as little endian.  <a href="#a25668a7254542eab91f95ae46c2f1fea">More...</a><br /></td></tr>
<tr class="separator:a25668a7254542eab91f95ae46c2f1fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e3f9cb71ae74898bd12c0f92c61023"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e3f9cb71ae74898bd12c0f92c61023"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPacket.html#ad4e3f9cb71ae74898bd12c0f92c61023">set</a> (T v, <a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> endian)</td></tr>
<tr class="memdesc:ad4e3f9cb71ae74898bd12c0f92c61023"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the value in the data pointer to v using the specified endianness.  <a href="#ad4e3f9cb71ae74898bd12c0f92c61023">More...</a><br /></td></tr>
<tr class="separator:ad4e3f9cb71ae74898bd12c0f92c61023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac361e7820fd71efef377343b25d56b83"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ac361e7820fd71efef377343b25d56b83">getUintX</a> (<a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> endian) const</td></tr>
<tr class="memdesc:ac361e7820fd71efef377343b25d56b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data in the packet byte swapped from the specified endianness and zero-extended to 64 bits.  <a href="#ac361e7820fd71efef377343b25d56b83">More...</a><br /></td></tr>
<tr class="separator:ac361e7820fd71efef377343b25d56b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a07335955fc19b3aae759c0c1cbe20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad1a07335955fc19b3aae759c0c1cbe20">setUintX</a> (uint64_t w, <a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> endian)</td></tr>
<tr class="memdesc:ad1a07335955fc19b3aae759c0c1cbe20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSet.html">Set</a> the value in the word w after truncating it to the length of the packet and then byteswapping it to the desired endianness.  <a href="#ad1a07335955fc19b3aae759c0c1cbe20">More...</a><br /></td></tr>
<tr class="separator:ad1a07335955fc19b3aae759c0c1cbe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758810a25a789ae0be9a461fd0bcf7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a758810a25a789ae0be9a461fd0bcf7e5">setData</a> (const uint8_t *p)</td></tr>
<tr class="memdesc:a758810a25a789ae0be9a461fd0bcf7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data into the packet from the provided pointer.  <a href="#a758810a25a789ae0be9a461fd0bcf7e5">More...</a><br /></td></tr>
<tr class="separator:a758810a25a789ae0be9a461fd0bcf7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5a80b775ab033127c54d2fdedf531d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a4d5a80b775ab033127c54d2fdedf531d">setDataFromBlock</a> (const uint8_t *blk_data, int blkSize)</td></tr>
<tr class="memdesc:a4d5a80b775ab033127c54d2fdedf531d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data into the packet from the provided block pointer, which is aligned to the given block size.  <a href="#a4d5a80b775ab033127c54d2fdedf531d">More...</a><br /></td></tr>
<tr class="separator:a4d5a80b775ab033127c54d2fdedf531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac508f4cb732d0f2f3c26d29fd1ad524f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ac508f4cb732d0f2f3c26d29fd1ad524f">writeData</a> (uint8_t *p) const</td></tr>
<tr class="memdesc:ac508f4cb732d0f2f3c26d29fd1ad524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the packet to the memory at the provided pointer.  <a href="#ac508f4cb732d0f2f3c26d29fd1ad524f">More...</a><br /></td></tr>
<tr class="separator:ac508f4cb732d0f2f3c26d29fd1ad524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a04ffe0cad417cf8892797a92428c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae57a04ffe0cad417cf8892797a92428c">writeDataToBlock</a> (uint8_t *blk_data, int blkSize) const</td></tr>
<tr class="memdesc:ae57a04ffe0cad417cf8892797a92428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the packet to the provided block pointer, which is aligned to the given block size.  <a href="#ae57a04ffe0cad417cf8892797a92428c">More...</a><br /></td></tr>
<tr class="separator:ae57a04ffe0cad417cf8892797a92428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b34ddc8bf368c6fa351f25d9b9afe5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a3b34ddc8bf368c6fa351f25d9b9afe5d">deleteData</a> ()</td></tr>
<tr class="memdesc:a3b34ddc8bf368c6fa351f25d9b9afe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the data pointed to in the data pointer.  <a href="#a3b34ddc8bf368c6fa351f25d9b9afe5d">More...</a><br /></td></tr>
<tr class="separator:a3b34ddc8bf368c6fa351f25d9b9afe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d4a16d37597168dcff5857d9c6717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aaa5d4a16d37597168dcff5857d9c6717">allocate</a> ()</td></tr>
<tr class="memdesc:aaa5d4a16d37597168dcff5857d9c6717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for the packet.  <a href="#aaa5d4a16d37597168dcff5857d9c6717">More...</a><br /></td></tr>
<tr class="separator:aaa5d4a16d37597168dcff5857d9c6717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPrintable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPrintable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPrintable.html">Printable</a></td></tr>
<tr class="memitem:a85a1129646e4b91f61ed027558d8666a inherit pub_methods_classPrintable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrintable.html#a85a1129646e4b91f61ed027558d8666a">Printable</a> ()</td></tr>
<tr class="separator:a85a1129646e4b91f61ed027558d8666a inherit pub_methods_classPrintable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6df687cb9894778b10bd28a517282d3 inherit pub_methods_classPrintable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrintable.html#af6df687cb9894778b10bd28a517282d3">~Printable</a> ()</td></tr>
<tr class="separator:af6df687cb9894778b10bd28a517282d3 inherit pub_methods_classPrintable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8069f9318acf9cb9576e0ae200f53b2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMemCmd.html">MemCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a8069f9318acf9cb9576e0ae200f53b2e">makeReadCmd</a> (const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;<a class="el" href="classPacket.html#ae348c208f0ffb3cf22f1f65a19c13c4f">req</a>)</td></tr>
<tr class="memdesc:a8069f9318acf9cb9576e0ae200f53b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the appropriate read <a class="el" href="classMemCmd.html">MemCmd</a> based on the <a class="el" href="classRequest.html">Request</a> flags.  <a href="#a8069f9318acf9cb9576e0ae200f53b2e">More...</a><br /></td></tr>
<tr class="separator:a8069f9318acf9cb9576e0ae200f53b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddc6f454f6aedd83cb1f21c8e2309aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMemCmd.html">MemCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#acddc6f454f6aedd83cb1f21c8e2309aa">makeWriteCmd</a> (const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;<a class="el" href="classPacket.html#ae348c208f0ffb3cf22f1f65a19c13c4f">req</a>)</td></tr>
<tr class="memdesc:acddc6f454f6aedd83cb1f21c8e2309aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the appropriate write <a class="el" href="classMemCmd.html">MemCmd</a> based on the <a class="el" href="classRequest.html">Request</a> flags.  <a href="#acddc6f454f6aedd83cb1f21c8e2309aa">More...</a><br /></td></tr>
<tr class="separator:acddc6f454f6aedd83cb1f21c8e2309aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdfada965fdf5c5524b7bf418a43358"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a3cdfada965fdf5c5524b7bf418a43358">createRead</a> (const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;<a class="el" href="classPacket.html#ae348c208f0ffb3cf22f1f65a19c13c4f">req</a>)</td></tr>
<tr class="memdesc:a3cdfada965fdf5c5524b7bf418a43358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor-like methods that return Packets based on <a class="el" href="classRequest.html">Request</a> objects.  <a href="#a3cdfada965fdf5c5524b7bf418a43358">More...</a><br /></td></tr>
<tr class="separator:a3cdfada965fdf5c5524b7bf418a43358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0114aa0ba90995a74bebd29a7aab70aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a0114aa0ba90995a74bebd29a7aab70aa">createWrite</a> (const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;<a class="el" href="classPacket.html#ae348c208f0ffb3cf22f1f65a19c13c4f">req</a>)</td></tr>
<tr class="separator:a0114aa0ba90995a74bebd29a7aab70aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade61bff6cd470a7ce6376f3c85bdd3ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMemCmd.html">MemCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ade61bff6cd470a7ce6376f3c85bdd3ae">cmd</a></td></tr>
<tr class="memdesc:ade61bff6cd470a7ce6376f3c85bdd3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command field of the packet.  <a href="#ade61bff6cd470a7ce6376f3c85bdd3ae">More...</a><br /></td></tr>
<tr class="separator:ade61bff6cd470a7ce6376f3c85bdd3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af720e740227e1083a16fc188cc7f22b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="packet_8hh.html#ad38dfafec51e964d93d60cdec3bfb489">PacketId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#af720e740227e1083a16fc188cc7f22b4">id</a></td></tr>
<tr class="separator:af720e740227e1083a16fc188cc7f22b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae348c208f0ffb3cf22f1f65a19c13c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae348c208f0ffb3cf22f1f65a19c13c4f">req</a></td></tr>
<tr class="memdesc:ae348c208f0ffb3cf22f1f65a19c13c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the original request.  <a href="#ae348c208f0ffb3cf22f1f65a19c13c4f">More...</a><br /></td></tr>
<tr class="separator:ae348c208f0ffb3cf22f1f65a19c13c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae035c719eee7a7713ab831a11e9e7406"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae035c719eee7a7713ab831a11e9e7406">headerDelay</a></td></tr>
<tr class="memdesc:ae035c719eee7a7713ab831a11e9e7406"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extra delay from seeing the packet until the header is transmitted.  <a href="#ae035c719eee7a7713ab831a11e9e7406">More...</a><br /></td></tr>
<tr class="separator:ae035c719eee7a7713ab831a11e9e7406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4a9b04aa6384293ff44918805cdc02"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a5e4a9b04aa6384293ff44918805cdc02">snoopDelay</a></td></tr>
<tr class="memdesc:a5e4a9b04aa6384293ff44918805cdc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of the extra delay incurred by snooping upwards before sending a request down the memory system.  <a href="#a5e4a9b04aa6384293ff44918805cdc02">More...</a><br /></td></tr>
<tr class="separator:a5e4a9b04aa6384293ff44918805cdc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672f63108880c72376276d9ed01b3fc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a672f63108880c72376276d9ed01b3fc3">payloadDelay</a></td></tr>
<tr class="memdesc:a672f63108880c72376276d9ed01b3fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extra pipelining delay from seeing the packet until the end of payload is transmitted by the component that provided it (if any).  <a href="#a672f63108880c72376276d9ed01b3fc3">More...</a><br /></td></tr>
<tr class="separator:a672f63108880c72376276d9ed01b3fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dd4fa4370e508806fe4a8253a0ad12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPacket_1_1SenderState.html">SenderState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ad1dd4fa4370e508806fe4a8253a0ad12">senderState</a></td></tr>
<tr class="memdesc:ad1dd4fa4370e508806fe4a8253a0ad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This packet's sender state.  <a href="#ad1dd4fa4370e508806fe4a8253a0ad12">More...</a><br /></td></tr>
<tr class="separator:ad1dd4fa4370e508806fe4a8253a0ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:afd8905f406e597a515028d1da27531a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: FlagsType { <br />
&#160;&#160;<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a38b714278dd6b492405f98b9a29ab030">COPY_FLAGS</a> = 0x0000003F, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3adfa1366ab9fcea34568866b51e4fa42e">RESPONDER_FLAGS</a> = 0x00000009, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3af4d44c99edbe097ea21baf6ccbb0466e">HAS_SHARERS</a> = 0x00000001, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a234463465dac8e4795f358d4fe8ab573">EXPRESS_SNOOP</a> = 0x00000002, 
<br />
&#160;&#160;<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a176bb0521eacfb2fbe237979fbf989bb">RESPONDER_HAD_WRITABLE</a> = 0x00000004, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3ab32631f7ee09e4407a40e80de211daa2">CACHE_RESPONDING</a> = 0x00000008, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3ad363e9831c83e4169b2c5d3a4d5a8713">WRITE_THROUGH</a> = 0x00000010, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3ae28d4c6f499fa55d6974231781c6b15b">SATISFIED</a> = 0x00000020, 
<br />
&#160;&#160;<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a44abfce3b42005eb184cb385e18623d0">VALID_ADDR</a> = 0x00000100, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3af7ad0df69125d82e024c86e4958dd812">VALID_SIZE</a> = 0x00000200, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a6c182a6bf22516d5db3817f81a506a64">STATIC_DATA</a> = 0x00001000, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a8f1b563c1c5bcf1439a325e71e53ad55">DYNAMIC_DATA</a> = 0x00002000, 
<br />
&#160;&#160;<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a7f539de34478489ced4dde86de136d6b">SUPPRESS_FUNC_ERROR</a> = 0x00008000, 
<a class="el" href="classPacket.html#afd8905f406e597a515028d1da27531a3a54882ba7ddd96170c99e9bde345d406f">BLOCK_CACHED</a> = 0x00010000
<br />
 }</td></tr>
<tr class="separator:afd8905f406e597a515028d1da27531a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1d59d7505cbc8790860b6200eb4c4a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPacket.html#a5901a7043b7770017d3d2e85fa0fca36">Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a1d59d7505cbc8790860b6200eb4c4a73">flags</a></td></tr>
<tr class="separator:a1d59d7505cbc8790860b6200eb4c4a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4816ce10747b969a88c4a7f9e9fb4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="packet_8hh.html#ae85a9de970f801a77a1ad88ee2b39ea2">PacketDataPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#aff4816ce10747b969a88c4a7f9e9fb4a">data</a></td></tr>
<tr class="memdesc:aff4816ce10747b969a88c4a7f9e9fb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the data being transferred.  <a href="#aff4816ce10747b969a88c4a7f9e9fb4a">More...</a><br /></td></tr>
<tr class="separator:aff4816ce10747b969a88c4a7f9e9fb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60308db1a818c0ed3c923fae7c6989e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#ae60308db1a818c0ed3c923fae7c6989e">addr</a></td></tr>
<tr class="memdesc:ae60308db1a818c0ed3c923fae7c6989e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address of the request.  <a href="#ae60308db1a818c0ed3c923fae7c6989e">More...</a><br /></td></tr>
<tr class="separator:ae60308db1a818c0ed3c923fae7c6989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe46fedc9eb3e8d05ad1412de86c090a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#afe46fedc9eb3e8d05ad1412de86c090a">_isSecure</a></td></tr>
<tr class="memdesc:afe46fedc9eb3e8d05ad1412de86c090a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the request targets the secure memory space.  <a href="#afe46fedc9eb3e8d05ad1412de86c090a">More...</a><br /></td></tr>
<tr class="separator:afe46fedc9eb3e8d05ad1412de86c090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec256dae61980f980ada9d6071c25ab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a2ec256dae61980f980ada9d6071c25ab">size</a></td></tr>
<tr class="memdesc:a2ec256dae61980f980ada9d6071c25ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the request or transfer.  <a href="#a2ec256dae61980f980ada9d6071c25ab">More...</a><br /></td></tr>
<tr class="separator:a2ec256dae61980f980ada9d6071c25ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9464a7a269e143840e6e39d6b7c10d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#a9464a7a269e143840e6e39d6b7c10d44">bytesValid</a></td></tr>
<tr class="memdesc:a9464a7a269e143840e6e39d6b7c10d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track the bytes found that satisfy a functional read.  <a href="#a9464a7a269e143840e6e39d6b7c10d44">More...</a><br /></td></tr>
<tr class="separator:a9464a7a269e143840e6e39d6b7c10d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc16b8e019de22818d4f14efe57dac96"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPacket.html#afc16b8e019de22818d4f14efe57dac96">_qosValue</a></td></tr>
<tr class="separator:afc16b8e019de22818d4f14efe57dac96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> is used to encapsulate a transfer between two objects in the memory system (e.g., the L1 and L2 cache). </p>
<p>(In contrast, a single <a class="el" href="classRequest.html">Request</a> travels all the way from the requester to the ultimate destination and back, possibly being conveyed by several different Packets along the way.) </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00255">255</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae9a3fdea469fc4024c95c49aab34742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3fdea469fc4024c95c49aab34742e">&#9670;&nbsp;</a></span>Command</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classMemCmd.html#ae5c39c2de0ad998b5176bc519b358102">MemCmd::Command</a> <a class="el" href="classMemCmd.html#ae5c39c2de0ad998b5176bc519b358102">Packet::Command</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00319">319</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<a id="a5901a7043b7770017d3d2e85fa0fca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5901a7043b7770017d3d2e85fa0fca36">&#9670;&nbsp;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classPacket.html#a5901a7043b7770017d3d2e85fa0fca36">Flags</a>&lt;<a class="el" href="classPacket.html#ae0916804186bffa24ea64d52324391b7">FlagsType</a>&gt; <a class="el" href="classPacket.html#a5901a7043b7770017d3d2e85fa0fca36">Packet::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00259">259</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<a id="ae0916804186bffa24ea64d52324391b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0916804186bffa24ea64d52324391b7">&#9670;&nbsp;</a></span>FlagsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="classPacket.html#ae0916804186bffa24ea64d52324391b7">Packet::FlagsType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00258">258</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afd8905f406e597a515028d1da27531a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8905f406e597a515028d1da27531a3">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="classPacket.html#ae0916804186bffa24ea64d52324391b7">FlagsType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a38b714278dd6b492405f98b9a29ab030"></a>COPY_FLAGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3adfa1366ab9fcea34568866b51e4fa42e"></a>RESPONDER_FLAGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3af4d44c99edbe097ea21baf6ccbb0466e"></a>HAS_SHARERS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a234463465dac8e4795f358d4fe8ab573"></a>EXPRESS_SNOOP&#160;</td><td class="fielddoc"><p>Special timing-mode atomic snoop for multi-level coherence. </p>
</td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a176bb0521eacfb2fbe237979fbf989bb"></a>RESPONDER_HAD_WRITABLE&#160;</td><td class="fielddoc"><p>Allow a responding cache to inform the cache hierarchy that it had a writable copy before responding. </p>
<p>See setResponderHadWritable below. </p>
</td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3ab32631f7ee09e4407a40e80de211daa2"></a>CACHE_RESPONDING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3ad363e9831c83e4169b2c5d3a4d5a8713"></a>WRITE_THROUGH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3ae28d4c6f499fa55d6974231781c6b15b"></a>SATISFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a44abfce3b42005eb184cb385e18623d0"></a>VALID_ADDR&#160;</td><td class="fielddoc"><p>Are the 'addr' and 'size' fields valid? </p>
</td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3af7ad0df69125d82e024c86e4958dd812"></a>VALID_SIZE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a6c182a6bf22516d5db3817f81a506a64"></a>STATIC_DATA&#160;</td><td class="fielddoc"><p>Is the data pointer set to a value that shouldn't be freed when the packet is destroyed? </p>
</td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a8f1b563c1c5bcf1439a325e71e53ad55"></a>DYNAMIC_DATA&#160;</td><td class="fielddoc"><p>The data pointer points to a value that should be freed when the packet is destroyed. </p>
<p>The pointer is assumed to be pointing to an array, and delete [] is consequently called </p>
</td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a7f539de34478489ced4dde86de136d6b"></a>SUPPRESS_FUNC_ERROR&#160;</td><td class="fielddoc"><p>suppress the error if this packet encounters a functional access failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="afd8905f406e597a515028d1da27531a3a54882ba7ddd96170c99e9bde345d406f"></a>BLOCK_CACHED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00263">263</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a32a9d9134824b4c5ee7eb96c81ceb5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a9d9134824b4c5ee7eb96c81ceb5d5">&#9670;&nbsp;</a></span>Packet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemCmd.html">MemCmd</a>&#160;</td>
          <td class="paramname"><em>_cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Note that a <a class="el" href="classRequest.html">Request</a> object must be constructed first, but the Requests's physical address and size fields need not be valid. The command must be supplied. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00796">796</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a id="a6a9889eb9a89ae9e7676f91022d861d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9889eb9a89ae9e7676f91022d861d0">&#9670;&nbsp;</a></span>Packet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemCmd.html">MemCmd</a>&#160;</td>
          <td class="paramname"><em>_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_blkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#ad38dfafec51e964d93d60cdec3bfb489">PacketId</a>&#160;</td>
          <td class="paramname"><em>_id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate constructor if you are trying to create a packet with a request that is for a whole block, not the address from the req. </p>
<p>this allows for overriding the size/addr of the req. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00818">818</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a id="aa320b67952756edac635b0683f16ca31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa320b67952756edac635b0683f16ca31">&#9670;&nbsp;</a></span>Packet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alloc_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate constructor for copying a packet. </p>
<p>Copy all fields <em>except</em> if the original packet's data was dynamic, don't copy that, as we can't guarantee that the new packet's lifetime is less than that of the original packet. In this case the new packet should allocate its own data. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00840">840</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00337">data</a>, <a class="el" href="packet_8hh_source.html#l00316">flags</a>, <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a id="a48938391fb7e07460bb0e01198ae5ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48938391fb7e07460bb0e01198ae5ede">&#9670;&nbsp;</a></span>~Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Packet::~Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clean up packet variables </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00927">927</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaa5d4a16d37597168dcff5857d9c6717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5d4a16d37597168dcff5857d9c6717">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for the packet. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01232">1232</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00220">MemCmd::hasData()</a>, <a class="el" href="flags_8hh_source.html#l00066">Flags&lt; T &gt;::noneSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="intdev_8hh_source.html#l00087">X86ISA::buildIntPacket()</a>, <a class="el" href="cache_8cc_source.html#l00899">Cache::cleanEvictBlk()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="queued_8cc_source.html#l00053">QueuedPrefetcher::DeferredPacket::createPkt()</a>, <a class="el" href="SeriesRequestGenerator_8cc_source.html#l00053">SeriesRequestGenerator::initiate()</a>, <a class="el" href="InvalidateGenerator_8cc_source.html#l00055">InvalidateGenerator::initiate()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01679">Minor::makePacketForRequest()</a>, <a class="el" href="dispatcher_8cc_source.html#l00127">GpuDispatcher::read()</a>, <a class="el" href="mshr_8cc_source.html#l00139">replaceUpgrade()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01511">BaseCache::writebackBlk()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01559">BaseCache::writecleanBlk()</a>.</p>

</div>
</div>
<a id="a14141460ec6de11c61eb6dc2ab5eda8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14141460ec6de11c61eb6dc2ab5eda8f">&#9670;&nbsp;</a></span>cacheResponding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::cacheResponding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00591">591</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="packet_8cc_source.html#l00309">copyResponderFlags()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00921">CoherentXBar::forwardAtomic()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l01316">Cache::isCachedAbove()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00223">NoncoherentCache::recvAtomic()</a>, <a class="el" href="cache_8cc_source.html#l00658">Cache::recvAtomic()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00216">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvAtomic()</a>, <a class="el" href="simple__mem_8cc_source.html#l00074">SimpleMemory::recvAtomic()</a>, <a class="el" href="dramsim2_8cc_source.html#l00155">DRAMSim2::recvAtomic()</a>, <a class="el" href="bridge_8cc_source.html#l00341">Bridge::BridgeSlavePort::recvAtomic()</a>, <a class="el" href="mem__sink_8cc_source.html#l00089">QoS::MemSinkCtrl::recvAtomic()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00345">CommMonitor::recvAtomic()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00263">DRAMCtrl::recvAtomic()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00241">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvAtomicBackdoor()</a>, <a class="el" href="tport_8cc_source.html#l00063">SimpleTimingPort::recvTimingReq()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00138">NoncoherentCache::recvTimingReq()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="cache_8cc_source.html#l00406">Cache::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00284">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="bridge_8cc_source.html#l00146">Bridge::BridgeSlavePort::recvTimingReq()</a>, <a class="el" href="dramsim2_8cc_source.html#l00178">DRAMSim2::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00586">DRAMCtrl::recvTimingReq()</a>, <a class="el" href="fetch__impl_8hh_source.html#l01677">DefaultFetch&lt; Impl &gt;::IcachePort::recvTimingResp()</a>, <a class="el" href="dma__device_8cc_source.html#l00111">DmaPort::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00301">SnoopFilter::updateSnoopForward()</a>, and <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>.</p>

</div>
</div>
<a id="ad3fb432d9d7a922312dbd1ef8a876162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb432d9d7a922312dbd1ef8a876162">&#9670;&nbsp;</a></span>clearBlockCached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::clearBlockCached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00693">693</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00068">Flags&lt; T &gt;::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>.</p>

</div>
</div>
<a id="a68b7449d2290af366ffd6dd8f59ebe45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b7449d2290af366ffd6dd8f59ebe45">&#9670;&nbsp;</a></span>clearWriteThrough()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::clearWriteThrough </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00673">673</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00068">Flags&lt; T &gt;::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>.</p>

</div>
</div>
<a id="a1f0f371dc0969b06e80c0fd4fa558b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0f371dc0969b06e80c0fd4fa558b1a">&#9670;&nbsp;</a></span>cmdString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Packet::cmdString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the string name of the cmd field (for debugging and tracing). </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00523">523</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00237">MemCmd::toString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="dma__device_8cc_source.html#l00068">DmaPort::handleResp()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="packet_8cc_source.html#l00376">print()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00263">DRAMCtrl::recvAtomic()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00284">AtomicSimpleCPU::AtomicCPUDPort::recvAtomicSnoop()</a>, <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00286">NoncoherentXBar::recvFunctional()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00314">AtomicSimpleCPU::AtomicCPUDPort::recvFunctionalSnoop()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="bridge_8cc_source.html#l00146">Bridge::BridgeSlavePort::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00586">DRAMCtrl::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="serial__link_8cc_source.html#l00132">SerialLink::SerialLinkMasterPort::recvTimingResp()</a>, <a class="el" href="bridge_8cc_source.html#l00124">Bridge::BridgeMasterPort::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00364">LSQ&lt; Impl &gt;::recvTimingSnoopReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00417">RubyPort::ruby_hit_callback()</a>, <a class="el" href="packet__queue_8cc_source.html#l00107">PacketQueue::schedSendTiming()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00129">AtomicSimpleCPU::threadSnoop()</a>, <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>, <a class="el" href="dma__device_8cc_source.html#l00220">DmaPort::trySendTimingReq()</a>, and <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00170">BaseTrafficGen::update()</a>.</p>

</div>
</div>
<a id="a14a73789b61dfcffbba858ea6210ef4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a73789b61dfcffbba858ea6210ef4c">&#9670;&nbsp;</a></span>cmdToIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::cmdToIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index of this command. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00526">526</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00238">MemCmd::toInt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8hh_source.html#l00970">BaseCache::CacheStats::cmdStats()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>.</p>

</div>
</div>
<a id="a8600439796528ac5e97b8617a5b090f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8600439796528ac5e97b8617a5b090f1">&#9670;&nbsp;</a></span>convertLlToRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::convertLlToRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When ruby is in use, Ruby will monitor the cache line and the phys memory should treat LL ops as normal reads. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00784">784</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00221">MemCmd::isLLSC()</a>, <a class="el" href="packet_8hh_source.html#l00197">MemCmd::isRead()</a>, and <a class="el" href="packet_8hh_source.html#l00087">MemCmd::ReadReq</a>.</p>

<p class="reference">Referenced by <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>.</p>

</div>
</div>
<a id="ad85805a56a4e8ebd757bbab42e1c8d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85805a56a4e8ebd757bbab42e1c8d5d">&#9670;&nbsp;</a></span>convertScToWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::convertScToWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It has been determined that the SC packet should successfully update memory. </p>
<p>Therefore, convert this SC packet to a normal write. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00772">772</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00221">MemCmd::isLLSC()</a>, <a class="el" href="packet_8hh_source.html#l00198">MemCmd::isWrite()</a>, and <a class="el" href="packet_8hh_source.html#l00090">MemCmd::WriteReq</a>.</p>

<p class="reference">Referenced by <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>.</p>

</div>
</div>
<a id="a8aa8840024624ac34bf619b87de8976e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa8840024624ac34bf619b87de8976e">&#9670;&nbsp;</a></span>copyError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::copyError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00724">724</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00322">cmd</a>, and <a class="el" href="packet_8hh_source.html#l00555">isError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, and <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>.</p>

</div>
</div>
<a id="a49b18aed3bc8105f9a44a888d8094648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b18aed3bc8105f9a44a888d8094648">&#9670;&nbsp;</a></span>copyResponderFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::copyResponderFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the reponse flags from an input packet to this packet. </p>
<p>The reponse flags determine whether a responder has been found and the state at which the block will be at the destination.</p>
<p>The packet that we will copy flags from </p>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00309">309</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00591">cacheResponding()</a>, <a class="el" href="packet_8hh_source.html#l00316">flags</a>, <a class="el" href="packet_8hh_source.html#l00531">isRequest()</a>, <a class="el" href="packet_8hh_source.html#l00268">RESPONDER_FLAGS</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, and <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>.</p>

</div>
</div>
<a id="a3cdfada965fdf5c5524b7bf418a43358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdfada965fdf5c5524b7bf418a43358">&#9670;&nbsp;</a></span>createRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> Packet::createRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor-like methods that return Packets based on <a class="el" href="classRequest.html">Request</a> objects. </p>
<p>Fine-tune the <a class="el" href="classMemCmd.html">MemCmd</a> type if it's not a vanilla read or write. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00913">913</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00078">MemCmd::Packet</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00381">TimingSimpleCPU::buildPacket()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01027">LSQ&lt; Impl &gt;::SingleDataRequest::buildPackets()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01044">LSQ&lt; Impl &gt;::SplitDataRequest::buildPackets()</a>, <a class="el" href="trace__cpu_8cc_source.html#l00625">TraceCPU::ElasticDataGen::executeMemReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01679">Minor::makePacketForRequest()</a>, <a class="el" href="AbstractController_8cc_source.html#l00240">AbstractController::queueMemoryRead()</a>, <a class="el" href="cpu_2checker_2cpu_8cc_source.html#l00177">CheckerCPU::readMem()</a>, and <a class="el" href="lsq__impl_8hh_source.html#l00999">LSQ&lt; Impl &gt;::SplitDataRequest::recvTimingResp()</a>.</p>

</div>
</div>
<a id="a0114aa0ba90995a74bebd29a7aab70aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0114aa0ba90995a74bebd29a7aab70aa">&#9670;&nbsp;</a></span>createWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a> Packet::createWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00919">919</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00078">MemCmd::Packet</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00381">TimingSimpleCPU::buildPacket()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01027">LSQ&lt; Impl &gt;::SingleDataRequest::buildPackets()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01044">LSQ&lt; Impl &gt;::SplitDataRequest::buildPackets()</a>, <a class="el" href="trace__cpu_8cc_source.html#l00625">TraceCPU::ElasticDataGen::executeMemReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01679">Minor::makePacketForRequest()</a>, <a class="el" href="AbstractController_8cc_source.html#l00264">AbstractController::queueMemoryWrite()</a>, <a class="el" href="AbstractController_8cc_source.html#l00289">AbstractController::queueMemoryWritePartial()</a>, and <a class="el" href="lsq__impl_8hh_source.html#l00999">LSQ&lt; Impl &gt;::SplitDataRequest::recvTimingResp()</a>.</p>

</div>
</div>
<a id="aa86da42d7b9a882873deb75798e8ff8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86da42d7b9a882873deb75798e8ff8d">&#9670;&nbsp;</a></span>dataDynamic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::dataDynamic </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the data pointer to a value that should have delete [] called on it. </p>
<p>Dynamic data is local to this packet, and as the packet travels from source to destination, forwarded packets will allocate their own data. When a packet reaches the final destination it will populate the dynamic data of that specific packet, and on the way back towards the source, memcpy will be invoked in every step where a new packet was created e.g. in the caches. Ultimately when the response reaches the source a final memcpy is needed to extract the data from the packet before it is deallocated. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01078">1078</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00066">Flags&lt; T &gt;::noneSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lsq__impl_8hh_source.html#l01044">LSQ&lt; Impl &gt;::SplitDataRequest::buildPackets()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00387">TimingSimpleCPU::buildSplitPacket()</a>, <a class="el" href="trace__cpu_8cc_source.html#l00625">TraceCPU::ElasticDataGen::executeMemReq()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00208">FetchUnit::fetch()</a>, <a class="el" href="fetch__impl_8hh_source.html#l00654">DefaultFetch&lt; Impl &gt;::finishTranslation()</a>, <a class="el" href="base__gen_8cc_source.html#l00061">BaseGen::getPacket()</a>, <a class="el" href="Check_8cc_source.html#l00167">Check::initiateAction()</a>, <a class="el" href="Check_8cc_source.html#l00227">Check::initiateCheck()</a>, <a class="el" href="Check_8cc_source.html#l00082">Check::initiatePrefetch()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01679">Minor::makePacketForRequest()</a>, <a class="el" href="trace__cpu_8cc_source.html#l01149">TraceCPU::FixedRetryGen::send()</a>, and <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00288">TimingSimpleCPU::sendData()</a>.</p>

</div>
</div>
<a id="afe77e06caa81808b679abf9291dfc44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe77e06caa81808b679abf9291dfc44f">&#9670;&nbsp;</a></span>dataStatic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::dataStatic </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the data pointer to the following value that should not be freed. </p>
<p>Static data allows us to do a single memcpy even if multiple packets are required to get from source to destination and back. In essence the pointer is set calling dataStatic on the original packet, and whenever this packet is copied and forwarded the same pointer is passed on. When a packet eventually reaches the destination holding the data, it is copied once into the location originally set. On the way back to the source, no copies are necessary. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01040">1040</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00066">Flags&lt; T &gt;::noneSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00568">AtomicSimpleCPU::amoMem()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01044">LSQ&lt; Impl &gt;::SplitDataRequest::buildPackets()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00387">TimingSimpleCPU::buildSplitPacket()</a>, <a class="el" href="dma__device_8cc_source.html#l00153">DmaPort::dmaAction()</a>, <a class="el" href="shader_8cc_source.html#l00229">Shader::doFunctionalAccess()</a>, <a class="el" href="cpu_2kvm_2base_8cc_source.html#l01114">BaseKvmCPU::doMMIOAccess()</a>, <a class="el" href="smmu__v3__proc_8cc_source.html#l00071">SMMUProcess::doRead()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00088">ItsProcess::doRead()</a>, <a class="el" href="smmu__v3__proc_8cc_source.html#l00100">SMMUProcess::doWrite()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00112">ItsProcess::doWrite()</a>, <a class="el" href="arch_2hsail_2insts_2mem_8hh_source.html#l01566">HsailISA::AtomicInst&lt; MemDataType, AddrOperandType, NumSrcOperands, HasDst &gt;::execAtomic()</a>, <a class="el" href="arch_2hsail_2insts_2mem_8hh_source.html#l01042">HsailISA::StInst&lt; MemDataType, SrcDataType, AddrOperandType &gt;::execSt()</a>, <a class="el" href="table__walker_8cc_source.html#l02005">ArmISA::TableWalker::fetchDescriptor()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01130">LSQ&lt; Impl &gt;::SplitDataRequest::handleIprRead()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01107">LSQ&lt; Impl &gt;::SplitDataRequest::handleIprWrite()</a>, <a class="el" href="x86__cpu_8cc_source.html#l01309">X86KvmCPU::handleKvmExitIO()</a>, <a class="el" href="arch_2hsail_2insts_2mem_8hh_source.html#l00436">HsailISA::LdInst&lt; MemDataType, DestDataType, AddrOperandType &gt;::initiateAcc()</a>, <a class="el" href="lsq__unit_8hh_source.html#l00613">LSQUnit&lt; Impl &gt;::read()</a>, <a class="el" href="stage2__mmu_8cc_source.html#l00064">ArmISA::Stage2MMU::readDataUntimed()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00372">AtomicSimpleCPU::readMem()</a>, <a class="el" href="cpu_2checker_2cpu_8cc_source.html#l00177">CheckerCPU::readMem()</a>, <a class="el" href="compute__unit_8cc_source.html#l01069">ComputeUnit::DTLBPort::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00999">LSQ&lt; Impl &gt;::SplitDataRequest::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00633">AtomicSimpleCPU::tick()</a>, <a class="el" href="cpu__impl_8hh_source.html#l00127">Checker&lt; O3CPUImpl &gt;::verify()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l00719">LSQUnit&lt; Impl &gt;::writebackStores()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01629">BaseCache::writebackVisitor()</a>, and <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00454">AtomicSimpleCPU::writeMem()</a>.</p>

</div>
</div>
<a id="a8d8d23baa08f1d5efd7e3321dc3d2fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8d23baa08f1d5efd7e3321dc3d2fa1">&#9670;&nbsp;</a></span>dataStaticConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::dataStaticConst </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the data pointer to the following value that should not be freed. </p>
<p>This version of the function allows the pointer passed to us to be const. To avoid issues down the line we cast the constness away, the alternative would be to keep both a const and non-const data pointer and cleverly choose between them. Note that this is only allowed for static data. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01057">1057</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00066">Flags&lt; T &gt;::noneSet()</a>, <a class="el" href="mips_2pra__constants_8hh_source.html#l00325">MipsISA::p</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a id="a3b34ddc8bf368c6fa351f25d9b9afe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b34ddc8bf368c6fa351f25d9b9afe5d">&#9670;&nbsp;</a></span>deleteData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::deleteData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete the data pointed to in the data pointer. </p>
<p>Ok to call to matter how data was allocted. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01221">1221</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00068">Flags&lt; T &gt;::clear()</a>, and <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

</div>
</div>
<a id="a404e7d969de3bc92b650843d0dd6f34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404e7d969de3bc92b650843d0dd6f34f">&#9670;&nbsp;</a></span>findNextSenderState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* Packet::findNextSenderState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go through the sender state stack and return the first instance that is of type T (as determined by a dynamic_cast). </p>
<p>If there is no sender state of type T, NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The topmost state of type T </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00510">510</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00405">Packet::SenderState::predecessor</a>, and <a class="el" href="miscregs__types_8hh_source.html#l00070">ArmISA::t</a>.</p>

<p class="reference">Referenced by <a class="el" href="mshr_8cc_source.html#l00115">MSHR::TargetList::add()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, and <a class="el" href="minor_2lsq_8cc_source.html#l01164">Minor::LSQ::tryToSend()</a>.</p>

</div>
</div>
<a id="a66394881a222e2bbc3abb33783df0f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66394881a222e2bbc3abb33783df0f46">&#9670;&nbsp;</a></span>fromCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::fromCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00546">546</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00207">MemCmd::fromCache()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, and <a class="el" href="mshr_8cc_source.html#l00078">MSHR::TargetList::updateFlags()</a>.</p>

</div>
</div>
<a id="a4e64401909b90c4170dcd1bcd8775725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e64401909b90c4170dcd1bcd8775725">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Packet::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>endian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data in the packet byte swapped from the specified endianness. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00086">86</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="base_2types_8hh_source.html#l00265">BigEndianByteOrder</a>, <a class="el" href="base_2types_8hh_source.html#l00266">LittleEndianByteOrder</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

<p class="reference">Referenced by <a class="el" href="generic_2memhelpers_8hh_source.html#l00067">getMem()</a>.</p>

</div>
</div>
<a id="a5d8b9bb469e6879c03c73effe3640634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8b9bb469e6879c03c73effe3640634">&#9670;&nbsp;</a></span>getAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> Packet::getAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00726">726</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="inet_8hh_source.html#l00335">addr</a>, and <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00164">Cache::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="dramsim2_8cc_source.html#l00251">DRAMSim2::accessAndRespond()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00887">DRAMCtrl::accessAndRespond()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00380">DRAMCtrl::addToReadQueue()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00487">DRAMCtrl::addToWriteQueue()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01396">BaseCache::allocateBlock()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l01052">GPUCoalescer::atomicCallback()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00215">SMMUv3SlaveInterface::atsMasterRecvTimingResp()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00172">SMMUv3SlaveInterface::atsSlaveRecvAtomic()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00190">SMMUv3SlaveInterface::atsSlaveRecvTimingReq()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00258">AbstractMemory::checkLockedAddrList()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l00371">LSQUnit&lt; Impl &gt;::checkSnoop()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00774">TimingSimpleCPU::completeIfetch()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00488">IdeController::dispatchAccess()</a>, <a class="el" href="sparc_2tlb_8cc_source.html#l00861">SparcISA::TLB::doMmuRegRead()</a>, <a class="el" href="sparc_2tlb_8cc_source.html#l01046">SparcISA::TLB::doMmuRegWrite()</a>, <a class="el" href="cpu_2base_8cc_source.html#l00741">AddressMonitor::doMonitor()</a>, <a class="el" href="smmu__v3__transl_8cc_source.html#l00049">SMMUTranslRequest::fromPacket()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="RubySystem_8cc_source.html#l00399">RubySystem::functionalRead()</a>, <a class="el" href="RubySystem_8cc_source.html#l00488">RubySystem::functionalWrite()</a>, <a class="el" href="RubyRequest_8cc_source.html#l00061">RubyRequest::functionalWrite()</a>, <a class="el" href="packet_8cc_source.html#l00228">getAddrRange()</a>, <a class="el" href="queued_8cc_source.html#l00199">QueuedPrefetcher::getPacket()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00235">GPUCoalescer::getRequestStatus()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="mmapped__ipr_8cc_source.html#l00056">GenericISA::handleGenericIprRead()</a>, <a class="el" href="mmapped__ipr_8cc_source.html#l00073">GenericISA::handleGenericIprWrite()</a>, <a class="el" href="x86_2mmapped__ipr_8hh_source.html#l00058">X86ISA::handleIprRead()</a>, <a class="el" href="x86_2mmapped__ipr_8hh_source.html#l00075">X86ISA::handleIprWrite()</a>, <a class="el" href="mips_2locked__mem_8hh_source.html#l00063">MipsISA::handleLockedSnoop()</a>, <a class="el" href="arm_2locked__mem_8hh_source.html#l00065">ArmISA::handleLockedSnoop()</a>, <a class="el" href="alpha_2locked__mem_8hh_source.html#l00069">AlphaISA::handleLockedSnoop()</a>, <a class="el" href="riscv_2locked__mem_8hh_source.html#l00074">RiscvISA::handleLockedSnoop()</a>, <a class="el" href="execute_8cc_source.html#l00321">Minor::Execute::handleMemResponse()</a>, <a class="el" href="mmapped__ipr_8cc_source.html#l00042">handlePseudoInst()</a>, <a class="el" href="simple__memobj_8cc_source.html#l00166">SimpleMemobj::handleRequest()</a>, <a class="el" href="simple__cache_8cc_source.html#l00192">SimpleCache::handleRequest()</a>, <a class="el" href="dma__device_8cc_source.html#l00068">DmaPort::handleResp()</a>, <a class="el" href="simple__memobj_8cc_source.html#l00185">SimpleMemobj::handleResponse()</a>, <a class="el" href="simple__cache_8cc_source.html#l00217">SimpleCache::handleResponse()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00594">GPUCoalescer::hitCallback()</a>, <a class="el" href="simple__cache_8cc_source.html#l00360">SimpleCache::insert()</a>, <a class="el" href="mem_2cache_2tags_2base_8cc_source.html#l00103">BaseTags::insertBlock()</a>, <a class="el" href="Sequencer_8cc_source.html#l00147">Sequencer::insertRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00312">GPUCoalescer::insertRequest()</a>, <a class="el" href="bus_8cc_source.html#l00193">I2CBus::isClockSet()</a>, <a class="el" href="bus_8cc_source.html#l00209">I2CBus::isEnd()</a>, <a class="el" href="bus_8cc_source.html#l00201">I2CBus::isStart()</a>, <a class="el" href="Sequencer_8cc_source.html#l00620">Sequencer::issueRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, <a class="el" href="DMASequencer_8cc_source.html#l00065">DMASequencer::makeRequest()</a>, <a class="el" href="Sequencer_8cc_source.html#l00517">Sequencer::makeRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00146">SMMUv3::masterRecvReqRetry()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00129">SMMUv3::masterRecvTimingResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00192">SMMUv3::masterTableWalkRecvReqRetry()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00175">SMMUv3::masterTableWalkRecvTimingResp()</a>, <a class="el" href="packet_8cc_source.html#l00411">matchAddr()</a>, <a class="el" href="cpu_2base_8cc_source.html#l00226">BaseCPU::mwait()</a>, <a class="el" href="bop_8cc_source.html#l00251">BOPPrefetcher::notifyFill()</a>, <a class="el" href="sbooe_8cc_source.html#l00097">SBOOEPrefetcher::notifyFill()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00059">BasePrefetcher::PrefetchInfo::PrefetchInfo()</a>, <a class="el" href="packet_8cc_source.html#l00376">print()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00203">BasePrefetcher::probeNotify()</a>, <a class="el" href="mem__sink_8cc_source.html#l00199">QoS::MemSinkCtrl::processNextReqEvent()</a>, <a class="el" href="simple_8cc_source.html#l00055">SimpleUart::read()</a>, <a class="el" href="pci_8cc_source.html#l00068">PciVirtIO::read()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00064">MmioVirtIO::read()</a>, <a class="el" href="i8237_8cc_source.html#l00037">X86ISA::I8237::read()</a>, <a class="el" href="mm__disk_8cc_source.html#l00056">MmDisk::read()</a>, <a class="el" href="dtod_8cc_source.html#l00062">DumbTOD::read()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00149">NoMaliGpu::read()</a>, <a class="el" href="pl011_8cc_source.html#l00067">Pl011::read()</a>, <a class="el" href="amba__fake_8cc_source.html#l00056">AmbaFake::read()</a>, <a class="el" href="speaker_8cc_source.html#l00041">X86ISA::Speaker::read()</a>, <a class="el" href="a9scu_8cc_source.html#l00054">A9SCU::read()</a>, <a class="el" href="isa__fake_8cc_source.html#l00055">IsaFake::read()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00072">TsunamiPChip::read()</a>, <a class="el" href="uart8250_8cc_source.html#l00096">Uart8250::read()</a>, <a class="el" href="cmos_8cc_source.html#l00048">X86ISA::Cmos::read()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00074">TsunamiCChip::read()</a>, <a class="el" href="i8254_8cc_source.html#l00052">X86ISA::I8254::read()</a>, <a class="el" href="i82094aa_8cc_source.html#l00093">X86ISA::I82094AA::read()</a>, <a class="el" href="i8259_8cc_source.html#l00073">X86ISA::I8259::read()</a>, <a class="el" href="hdlcd_8cc_source.html#l00238">HDLcd::read()</a>, <a class="el" href="gic__v2m_8cc_source.html#l00107">Gicv2m::read()</a>, <a class="el" href="backdoor_8cc_source.html#l00103">AlphaBackdoor::read()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00061">PL031::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00087">TsunamiIO::read()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00064">EnergyCtrl::read()</a>, <a class="el" href="kmi_8cc_source.html#l00063">Pl050::read()</a>, <a class="el" href="iob_8cc_source.html#l00077">Iob::read()</a>, <a class="el" href="i8042_8cc_source.html#l00126">X86ISA::I8042::read()</a>, <a class="el" href="dispatcher_8cc_source.html#l00127">GpuDispatcher::read()</a>, <a class="el" href="bus_8cc_source.html#l00071">I2CBus::read()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00819">Gicv3Its::read()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00066">Sp804::read()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00066">A9GlobalTimer::read()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00056">RealViewCtrl::read()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00092">CpuLocalTimer::read()</a>, <a class="el" href="copy__engine_8cc_source.html#l00169">CopyEngine::read()</a>, <a class="el" href="vgic_8cc_source.html#l00071">VGic::read()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00192">X86ISA::Interrupts::read()</a>, <a class="el" href="sinic_8cc_source.html#l00212">Sinic::Device::read()</a>, <a class="el" href="host_8cc_source.html#l00136">GenericPciHost::read()</a>, <a class="el" href="generic__timer_8cc_source.html#l00569">GenericTimerMem::read()</a>, <a class="el" href="ns__gige_8cc_source.html#l00187">NSGigE::read()</a>, <a class="el" href="pl111_8cc_source.html#l00101">Pl111::read()</a>, <a class="el" href="gic__v2_8cc_source.html#l00113">GicV2::read()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00170">IGbE::read()</a>, <a class="el" href="ufs__device_8cc_source.html#l00929">UFSHostDevice::read()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00177">IdeController::readConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00220">PciDevice::readConfig()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00582">SMMUv3::readControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00291">GicV2::readCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00144">VGic::readCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00140">GicV2::readDistributor()</a>, <a class="el" href="amba__device_8cc_source.html#l00074">AmbaDevice::readId()</a>, <a class="el" href="iob_8cc_source.html#l00092">Iob::readIob()</a>, <a class="el" href="iob_8cc_source.html#l00121">Iob::readJBus()</a>, <a class="el" href="vgic_8cc_source.html#l00097">VGic::readVCpu()</a>, <a class="el" href="Sequencer_8cc_source.html#l00235">Sequencer::recordMissLatency()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l01180">GPUCoalescer::recordMissLatency()</a>, <a class="el" href="external__slave_8cc_source.html#l00099">StubSlavePort::recvAtomic()</a>, <a class="el" href="RubyPort_8cc_source.html#l00304">RubyPort::MemSlavePort::recvAtomic()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00124">SMMUv3SlaveInterface::recvAtomic()</a>, <a class="el" href="smmu__v3__ports_8cc_source.html#l00118">SMMUControlPort::recvAtomic()</a>, <a class="el" href="RubyPort_8cc_source.html#l00214">RubyPort::PioSlavePort::recvAtomic()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00087">AddrMapper::recvAtomic()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00263">DRAMCtrl::recvAtomic()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="cache_8cc_source.html#l01303">Cache::recvAtomicSnoop()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00284">AtomicSimpleCPU::AtomicCPUDPort::recvAtomicSnoop()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00097">AddrMapper::recvAtomicSnoop()</a>, <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00286">NoncoherentXBar::recvFunctional()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00089">MemCheckerMonitor::recvFunctional()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00069">AddrMapper::recvFunctional()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00314">AtomicSimpleCPU::AtomicCPUDPort::recvFunctionalSnoop()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00107">MemCheckerMonitor::recvFunctionalSnoop()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00078">AddrMapper::recvFunctionalSnoop()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00304">X86ISA::Interrupts::recvMessage()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00140">SMMUv3SlaveInterface::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00193">RubyPort::PioSlavePort::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="bridge_8cc_source.html#l00146">Bridge::BridgeSlavePort::recvTimingReq()</a>, <a class="el" href="dramsim2_8cc_source.html#l00178">DRAMSim2::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00586">DRAMCtrl::recvTimingReq()</a>, <a class="el" href="RubyDirectedTester_8cc_source.html#l00097">RubyDirectedTester::CpuPort::recvTimingResp()</a>, <a class="el" href="RubyPort_8cc_source.html#l00168">RubyPort::MemMasterPort::recvTimingResp()</a>, <a class="el" href="RubyPort_8cc_source.html#l00157">RubyPort::PioMasterPort::recvTimingResp()</a>, <a class="el" href="AbstractController_8cc_source.html#l00328">AbstractController::recvTimingResp()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00851">TimingSimpleCPU::IcachePort::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00135">AddrMapper::recvTimingResp()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00977">TimingSimpleCPU::DcachePort::recvTimingResp()</a>, <a class="el" href="serial__link_8cc_source.html#l00132">SerialLink::SerialLinkMasterPort::recvTimingResp()</a>, <a class="el" href="bridge_8cc_source.html#l00124">Bridge::BridgeMasterPort::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01287">Minor::LSQ::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00326">LSQ&lt; Impl &gt;::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00364">LSQ&lt; Impl &gt;::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00390">GPUCoalescer::removeRequest()</a>, <a class="el" href="RubyPort_8cc_source.html#l00417">RubyPort::ruby_hit_callback()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00282">SMMUv3::runProcessTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="packet__queue_8cc_source.html#l00107">PacketQueue::schedSendTiming()</a>, <a class="el" href="cache_8cc_source.html#l01344">Cache::sendMSHRQueuePacket()</a>, <a class="el" href="noncaching_8cc_source.html#l00057">NonCachingSimpleCPU::sendPacket()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="simple__cache_8cc_source.html#l00247">SimpleCache::sendResponse()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00101">testAndRead()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00127">testAndReadMask()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00156">testAndWrite()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00129">AtomicSimpleCPU::threadSnoop()</a>, <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00316">SerialLink::SerialLinkSlavePort::trySendTiming()</a>, <a class="el" href="bridge_8cc_source.html#l00285">Bridge::BridgeSlavePort::trySendTiming()</a>, <a class="el" href="serial__link_8cc_source.html#l00273">SerialLink::SerialLinkMasterPort::trySendTiming()</a>, <a class="el" href="bridge_8cc_source.html#l00247">Bridge::BridgeMasterPort::trySendTiming()</a>, <a class="el" href="dma__device_8cc_source.html#l00220">DmaPort::trySendTimingReq()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00170">BaseTrafficGen::update()</a>, <a class="el" href="bus_8cc_source.html#l00173">I2CBus::updateSignals()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00155">GPUCoalescer::wakeup()</a>, <a class="el" href="simple_8cc_source.html#l00071">SimpleUart::write()</a>, <a class="el" href="pci_8cc_source.html#l00149">PciVirtIO::write()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00162">MmioVirtIO::write()</a>, <a class="el" href="i8237_8cc_source.html#l00072">X86ISA::I8237::write()</a>, <a class="el" href="mm__disk_8cc_source.html#l00114">MmDisk::write()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00170">NoMaliGpu::write()</a>, <a class="el" href="pl011_8cc_source.html#l00172">Pl011::write()</a>, <a class="el" href="amba__fake_8cc_source.html#l00073">AmbaFake::write()</a>, <a class="el" href="speaker_8cc_source.html#l00057">X86ISA::Speaker::write()</a>, <a class="el" href="a9scu_8cc_source.html#l00091">A9SCU::write()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00156">TsunamiPChip::write()</a>, <a class="el" href="isa__fake_8cc_source.html#l00094">IsaFake::write()</a>, <a class="el" href="uart8250_8cc_source.html#l00177">Uart8250::write()</a>, <a class="el" href="cmos_8cc_source.html#l00067">X86ISA::Cmos::write()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00190">TsunamiCChip::write()</a>, <a class="el" href="i8254_8cc_source.html#l00068">X86ISA::I8254::write()</a>, <a class="el" href="i82094aa_8cc_source.html#l00112">X86ISA::I82094AA::write()</a>, <a class="el" href="i8259_8cc_source.html#l00097">X86ISA::I8259::write()</a>, <a class="el" href="hdlcd_8cc_source.html#l00258">HDLcd::write()</a>, <a class="el" href="gic__v2m_8cc_source.html#l00137">Gicv2m::write()</a>, <a class="el" href="backdoor_8cc_source.html#l00201">AlphaBackdoor::write()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00123">PL031::write()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00150">TsunamiIO::write()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00150">EnergyCtrl::write()</a>, <a class="el" href="kmi_8cc_source.html#l00115">Pl050::write()</a>, <a class="el" href="iob_8cc_source.html#l00171">Iob::write()</a>, <a class="el" href="i8042_8cc_source.html#l00145">X86ISA::I8042::write()</a>, <a class="el" href="bus_8cc_source.html#l00090">I2CBus::write()</a>, <a class="el" href="dispatcher_8cc_source.html#l00157">GpuDispatcher::write()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00893">Gicv3Its::write()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00121">Sp804::write()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00146">A9GlobalTimer::write()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00132">RealViewCtrl::write()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00170">CpuLocalTimer::write()</a>, <a class="el" href="copy__engine_8cc_source.html#l00292">CopyEngine::write()</a>, <a class="el" href="vgic_8cc_source.html#l00084">VGic::write()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00209">X86ISA::Interrupts::write()</a>, <a class="el" href="sinic_8cc_source.html#l00297">Sinic::Device::write()</a>, <a class="el" href="host_8cc_source.html#l00160">GenericPciHost::write()</a>, <a class="el" href="generic__timer_8cc_source.html#l00598">GenericTimerMem::write()</a>, <a class="el" href="ns__gige_8cc_source.html#l00409">NSGigE::write()</a>, <a class="el" href="pl111_8cc_source.html#l00230">Pl111::write()</a>, <a class="el" href="gic__v2_8cc_source.html#l00127">GicV2::write()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00358">IGbE::write()</a>, <a class="el" href="ufs__device_8cc_source.html#l01067">UFSHostDevice::write()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00259">IdeController::writeConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00288">PciDevice::writeConfig()</a>, <a class="el" href="ns__gige_8cc_source.html#l00151">NSGigE::writeConfig()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00151">IGbE::writeConfig()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00615">SMMUv3::writeControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00558">GicV2::writeCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00287">VGic::writeCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00389">GicV2::writeDistributor()</a>, <a class="el" href="iob_8cc_source.html#l00186">Iob::writeIob()</a>, <a class="el" href="iob_8cc_source.html#l00237">Iob::writeJBus()</a>, and <a class="el" href="vgic_8cc_source.html#l00238">VGic::writeVCpu()</a>.</p>

</div>
</div>
<a id="aa71d1ff754f712c337e8908a1595f8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71d1ff754f712c337e8908a1595f8a0">&#9670;&nbsp;</a></span>getAddrRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> Packet::getAddrRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address range to which this packet belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>Address range of this packet. </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00228">228</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00726">getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00736">getSize()</a>, and <a class="el" href="addr__range_8hh_source.html#l00584">RangeSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="physical_8cc_source.html#l00278">PhysicalMemory::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="physical_8cc_source.html#l00287">PhysicalMemory::functionalAccess()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00286">NoncoherentXBar::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00992">CoherentXBar::recvFunctional()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>.</p>

</div>
</div>
<a id="a513d3d147c657f34b45e1c2fbf05cddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513d3d147c657f34b45e1c2fbf05cddc">&#9670;&nbsp;</a></span>getAtomicOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAtomicOpFunctor.html">AtomicOpFunctor</a>* Packet::getAtomicOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor function to atomic op. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00764">764</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>.</p>

</div>
</div>
<a id="aa54785af5ba6515f4b7453c763f01329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54785af5ba6515f4b7453c763f01329">&#9670;&nbsp;</a></span>getBE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Packet::getBE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data in the packet byte swapped from big endian to host endian. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00072">72</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="byteswap_8hh_source.html#l00147">betoh()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sparc_2tlb_8cc_source.html#l01046">SparcISA::TLB::doMmuRegWrite()</a>, <a class="el" href="iob_8cc_source.html#l00186">Iob::writeIob()</a>, and <a class="el" href="iob_8cc_source.html#l00237">Iob::writeJBus()</a>.</p>

</div>
</div>
<a id="ad143614d376622e093aaf4324106bed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad143614d376622e093aaf4324106bed1">&#9670;&nbsp;</a></span>getBlockAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> Packet::getBlockAddr </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blk_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00750">750</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple__cache_8cc_source.html#l00340">SimpleCache::accessFunctional()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01089">BaseCache::allocateMissBuffer()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01107">BaseCache::allocateWriteBuffer()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00720">BaseCache::getNextQueueEntry()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00122">NoncoherentCache::handleTimingReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="simple__cache_8cc_source.html#l00360">SimpleCache::insert()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="packet_8cc_source.html#l00397">matchBlockAddr()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00338">SnoopFilter::updateResponse()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00301">SnoopFilter::updateSnoopForward()</a>, and <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>.</p>

</div>
</div>
<a id="a164a45730b5b52b42fe0cf7c586dec9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164a45730b5b52b42fe0cf7c586dec9c">&#9670;&nbsp;</a></span>getConstPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* Packet::getConstPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01099">1099</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="circlebuf_8test_8cc_source.html#l00044">data</a>, <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00054">ArmISA::v</a>, and <a class="el" href="mips_2pra__constants_8hh_source.html#l00280">MipsISA::w</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01396">BaseCache::allocateBlock()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00258">AbstractMemory::checkLockedAddrList()</a>, <a class="el" href="memtest_8cc_source.html#l00135">MemTest::completeRequest()</a>, <a class="el" href="RubyRequest_8cc_source.html#l00061">RubyRequest::functionalWrite()</a>, <a class="el" href="execute_8cc_source.html#l00321">Minor::Execute::handleMemResponse()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="Check_8cc_source.html#l00167">Check::initiateAction()</a>, <a class="el" href="simple__cache_8cc_source.html#l00360">SimpleCache::insert()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00059">BasePrefetcher::PrefetchInfo::PrefetchInfo()</a>, <a class="el" href="fetch__impl_8hh_source.html#l00389">DefaultFetch&lt; Impl &gt;::processCacheCompletion()</a>, <a class="el" href="external__slave_8cc_source.html#l00099">StubSlavePort::recvAtomic()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00156">testAndWrite()</a>, and <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00454">AtomicSimpleCPU::writeMem()</a>.</p>

</div>
</div>
<a id="a7c349e851d04dc20402a8dd0fddf102d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c349e851d04dc20402a8dd0fddf102d">&#9670;&nbsp;</a></span>getLE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Packet::getLE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data in the packet byte swapped from little endian to host endian. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00079">79</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="byteswap_8hh_source.html#l00145">letoh()</a>.</p>

<p class="reference">Referenced by <a class="el" href="copy__engine_8cc_source.html#l00370">CopyEngine::CopyEngineChannel::channelWrite()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00488">IdeController::dispatchAccess()</a>, <a class="el" href="x86_2memhelpers_8hh_source.html#l00054">X86ISA::getMem()</a>, <a class="el" href="x86_2memhelpers_8hh_source.html#l00079">X86ISA::getPackedMem()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00235">ItsTranslation::main()</a>, <a class="el" href="pl011_8cc_source.html#l00067">Pl011::read()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00074">TsunamiCChip::read()</a>, <a class="el" href="backdoor_8cc_source.html#l00103">AlphaBackdoor::read()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00085">Sp804::Timer::read()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00061">PL031::read()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00088">A9GlobalTimer::Timer::read()</a>, <a class="el" href="kmi_8cc_source.html#l00063">Pl050::read()</a>, <a class="el" href="pl111_8cc_source.html#l00101">Pl111::read()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00177">IdeController::readConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00220">PciDevice::readConfig()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00282">X86ISA::Walker::WalkerState::stepWalk()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00162">MmioVirtIO::write()</a>, <a class="el" href="pci_8cc_source.html#l00149">PciVirtIO::write()</a>, <a class="el" href="i8237_8cc_source.html#l00072">X86ISA::I8237::write()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00170">NoMaliGpu::write()</a>, <a class="el" href="pl011_8cc_source.html#l00172">Pl011::write()</a>, <a class="el" href="speaker_8cc_source.html#l00057">X86ISA::Speaker::write()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00156">TsunamiPChip::write()</a>, <a class="el" href="isa__fake_8cc_source.html#l00094">IsaFake::write()</a>, <a class="el" href="cmos_8cc_source.html#l00067">X86ISA::Cmos::write()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00190">TsunamiCChip::write()</a>, <a class="el" href="i8254_8cc_source.html#l00068">X86ISA::I8254::write()</a>, <a class="el" href="i82094aa_8cc_source.html#l00112">X86ISA::I82094AA::write()</a>, <a class="el" href="i8259_8cc_source.html#l00097">X86ISA::I8259::write()</a>, <a class="el" href="hdlcd_8cc_source.html#l00258">HDLcd::write()</a>, <a class="el" href="gic__v2m_8cc_source.html#l00137">Gicv2m::write()</a>, <a class="el" href="backdoor_8cc_source.html#l00201">AlphaBackdoor::write()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00139">Sp804::Timer::write()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00123">PL031::write()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00150">TsunamiIO::write()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00150">EnergyCtrl::write()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00165">A9GlobalTimer::Timer::write()</a>, <a class="el" href="i8042_8cc_source.html#l00145">X86ISA::I8042::write()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00189">CpuLocalTimer::Timer::write()</a>, <a class="el" href="dispatcher_8cc_source.html#l00157">GpuDispatcher::write()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00893">Gicv3Its::write()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00132">RealViewCtrl::write()</a>, <a class="el" href="copy__engine_8cc_source.html#l00292">CopyEngine::write()</a>, <a class="el" href="sinic_8cc_source.html#l00297">Sinic::Device::write()</a>, <a class="el" href="generic__timer_8cc_source.html#l00598">GenericTimerMem::write()</a>, <a class="el" href="ns__gige_8cc_source.html#l00409">NSGigE::write()</a>, <a class="el" href="pl111_8cc_source.html#l00230">Pl111::write()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00358">IGbE::write()</a>, <a class="el" href="ufs__device_8cc_source.html#l01067">UFSHostDevice::write()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00259">IdeController::writeConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00288">PciDevice::writeConfig()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00615">SMMUv3::writeControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00558">GicV2::writeCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00287">VGic::writeCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00389">GicV2::writeDistributor()</a>, and <a class="el" href="vgic_8cc_source.html#l00238">VGic::writeVCpu()</a>.</p>

</div>
</div>
<a id="ae868effb4ada6beba486666a63304ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae868effb4ada6beba486666a63304ec7">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> Packet::getOffset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blk_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00745">745</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l00680">BaseCache::cmpAndSwap()</a>, <a class="el" href="cache_8cc_source.html#l00304">Cache::promoteWholeLineWrites()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, and <a class="el" href="mshr_8hh_source.html#l00231">MSHR::TargetList::updateWriteFlags()</a>.</p>

</div>
</div>
<a id="a4b89d352ac3256638f40819edfa38837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b89d352ac3256638f40819edfa38837">&#9670;&nbsp;</a></span>getPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* Packet::getPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the data ptr. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01090">1090</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="circlebuf_8test_8cc_source.html#l00044">data</a>, and <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="pipe__data_8cc_source.html#l00185">Minor::ForwardLineData::adoptPacketData()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l01052">GPUCoalescer::atomicCallback()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00488">IdeController::dispatchAccess()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00804">Minor::LSQ::StoreBuffer::forwardStoreData()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01130">LSQ&lt; Impl &gt;::SplitDataRequest::handleIprRead()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01107">LSQ&lt; Impl &gt;::SplitDataRequest::handleIprWrite()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00594">GPUCoalescer::hitCallback()</a>, <a class="el" href="Sequencer_8cc_source.html#l00620">Sequencer::issueRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, <a class="el" href="DMASequencer_8cc_source.html#l00065">DMASequencer::makeRequest()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00256">FetchUnit::processFetchReturn()</a>, <a class="el" href="isa__fake_8cc_source.html#l00055">IsaFake::read()</a>, <a class="el" href="dispatcher_8cc_source.html#l00127">GpuDispatcher::read()</a>, <a class="el" href="host_8cc_source.html#l00136">GenericPciHost::read()</a>, <a class="el" href="ns__gige_8cc_source.html#l00187">NSGigE::read()</a>, <a class="el" href="AbstractController_8cc_source.html#l00328">AbstractController::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01069">ComputeUnit::DTLBPort::recvTimingResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00101">testAndRead()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00127">testAndReadMask()</a>, <a class="el" href="packet_8hh_source.html#l01264">trySatisfyFunctional()</a>, and <a class="el" href="dispatcher_8cc_source.html#l00157">GpuDispatcher::write()</a>.</p>

</div>
</div>
<a id="a5ef2950692a91ec29f441bea7127b11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef2950692a91ec29f441bea7127b11f">&#9670;&nbsp;</a></span>getRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Packet::getRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data in the packet without byte swapping. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00053">53</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00337">data</a>, <a class="el" href="packet_8hh_source.html#l00305">DYNAMIC_DATA</a>, <a class="el" href="packet_8hh_source.html#l00316">flags</a>, <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, <a class="el" href="packet_8hh_source.html#l00347">size</a>, and <a class="el" href="packet_8hh_source.html#l00301">STATIC_DATA</a>.</p>

<p class="reference">Referenced by <a class="el" href="bus_8cc_source.html#l00193">I2CBus::isClockSet()</a>, <a class="el" href="bus_8cc_source.html#l00209">I2CBus::isEnd()</a>, <a class="el" href="bus_8cc_source.html#l00201">I2CBus::isStart()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00304">X86ISA::Interrupts::recvMessage()</a>, <a class="el" href="bus_8cc_source.html#l00173">I2CBus::updateSignals()</a>, <a class="el" href="mm__disk_8cc_source.html#l00114">MmDisk::write()</a>, and <a class="el" href="uart8250_8cc_source.html#l00177">Uart8250::write()</a>.</p>

</div>
</div>
<a id="aaf1f26587ac7e1e5790b04931e35f64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1f26587ac7e1e5790b04931e35f64d">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Packet::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00736">736</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00380">DRAMCtrl::addToReadQueue()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00487">DRAMCtrl::addToWriteQueue()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l01052">GPUCoalescer::atomicCallback()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00215">SMMUv3SlaveInterface::atsMasterRecvTimingResp()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00172">SMMUv3SlaveInterface::atsSlaveRecvAtomic()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00190">SMMUv3SlaveInterface::atsSlaveRecvTimingReq()</a>, <a class="el" href="xbar_8cc_source.html#l00103">BaseXBar::calcPacketTiming()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00258">AbstractMemory::checkLockedAddrList()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00680">BaseCache::cmpAndSwap()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00488">IdeController::dispatchAccess()</a>, <a class="el" href="smmu__v3__proc_8cc_source.html#l00071">SMMUProcess::doRead()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00088">ItsProcess::doRead()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00112">ItsProcess::doWrite()</a>, <a class="el" href="smmu__v3__transl_8cc_source.html#l00049">SMMUTranslRequest::fromPacket()</a>, <a class="el" href="RubyRequest_8cc_source.html#l00061">RubyRequest::functionalWrite()</a>, <a class="el" href="packet_8cc_source.html#l00228">getAddrRange()</a>, <a class="el" href="packet_8cc_source.html#l00337">getUintX()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="x86_2mmapped__ipr_8hh_source.html#l00058">X86ISA::handleIprRead()</a>, <a class="el" href="x86_2mmapped__ipr_8hh_source.html#l00075">X86ISA::handleIprWrite()</a>, <a class="el" href="execute_8cc_source.html#l00321">Minor::Execute::handleMemResponse()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00594">GPUCoalescer::hitCallback()</a>, <a class="el" href="Sequencer_8cc_source.html#l00620">Sequencer::issueRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, <a class="el" href="DMASequencer_8cc_source.html#l00065">DMASequencer::makeRequest()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00146">SMMUv3::masterRecvReqRetry()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00129">SMMUv3::masterRecvTimingResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00192">SMMUv3::masterTableWalkRecvReqRetry()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00175">SMMUv3::masterTableWalkRecvTimingResp()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="packet_8cc_source.html#l00376">print()</a>, <a class="el" href="mem__sink_8cc_source.html#l00199">QoS::MemSinkCtrl::processNextReqEvent()</a>, <a class="el" href="cache_8cc_source.html#l00304">Cache::promoteWholeLineWrites()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00064">MmioVirtIO::read()</a>, <a class="el" href="pci_8cc_source.html#l00068">PciVirtIO::read()</a>, <a class="el" href="i8237_8cc_source.html#l00037">X86ISA::I8237::read()</a>, <a class="el" href="mm__disk_8cc_source.html#l00056">MmDisk::read()</a>, <a class="el" href="dtod_8cc_source.html#l00062">DumbTOD::read()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00149">NoMaliGpu::read()</a>, <a class="el" href="pl011_8cc_source.html#l00067">Pl011::read()</a>, <a class="el" href="a9scu_8cc_source.html#l00054">A9SCU::read()</a>, <a class="el" href="speaker_8cc_source.html#l00041">X86ISA::Speaker::read()</a>, <a class="el" href="isa__fake_8cc_source.html#l00055">IsaFake::read()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00072">TsunamiPChip::read()</a>, <a class="el" href="uart8250_8cc_source.html#l00096">Uart8250::read()</a>, <a class="el" href="cmos_8cc_source.html#l00048">X86ISA::Cmos::read()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00074">TsunamiCChip::read()</a>, <a class="el" href="i8254_8cc_source.html#l00052">X86ISA::I8254::read()</a>, <a class="el" href="i82094aa_8cc_source.html#l00093">X86ISA::I82094AA::read()</a>, <a class="el" href="i8259_8cc_source.html#l00073">X86ISA::I8259::read()</a>, <a class="el" href="hdlcd_8cc_source.html#l00238">HDLcd::read()</a>, <a class="el" href="backdoor_8cc_source.html#l00103">AlphaBackdoor::read()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00061">PL031::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00087">TsunamiIO::read()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00064">EnergyCtrl::read()</a>, <a class="el" href="i8042_8cc_source.html#l00126">X86ISA::I8042::read()</a>, <a class="el" href="dispatcher_8cc_source.html#l00127">GpuDispatcher::read()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00066">Sp804::read()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00066">A9GlobalTimer::read()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00056">RealViewCtrl::read()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00092">CpuLocalTimer::read()</a>, <a class="el" href="copy__engine_8cc_source.html#l00169">CopyEngine::read()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00192">X86ISA::Interrupts::read()</a>, <a class="el" href="sinic_8cc_source.html#l00212">Sinic::Device::read()</a>, <a class="el" href="host_8cc_source.html#l00136">GenericPciHost::read()</a>, <a class="el" href="generic__timer_8cc_source.html#l00569">GenericTimerMem::read()</a>, <a class="el" href="ns__gige_8cc_source.html#l00187">NSGigE::read()</a>, <a class="el" href="pl111_8cc_source.html#l00101">Pl111::read()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00170">IGbE::read()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00177">IdeController::readConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00220">PciDevice::readConfig()</a>, <a class="el" href="dev_2virtio_2base_8cc_source.html#l00423">VirtIODeviceBase::readConfigBlob()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00582">SMMUv3::readControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00140">GicV2::readDistributor()</a>, <a class="el" href="amba__device_8cc_source.html#l00074">AmbaDevice::readId()</a>, <a class="el" href="external__slave_8cc_source.html#l00099">StubSlavePort::recvAtomic()</a>, <a class="el" href="RubyPort_8cc_source.html#l00304">RubyPort::MemSlavePort::recvAtomic()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00124">SMMUv3SlaveInterface::recvAtomic()</a>, <a class="el" href="smmu__v3__ports_8cc_source.html#l00118">SMMUControlPort::recvAtomic()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00880">CoherentXBar::recvAtomicSnoop()</a>, <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00089">MemCheckerMonitor::recvFunctional()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00107">MemCheckerMonitor::recvFunctionalSnoop()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00140">SMMUv3SlaveInterface::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00586">DRAMCtrl::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="serial__link_8cc_source.html#l00132">SerialLink::SerialLinkMasterPort::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00282">SMMUv3::runProcessTiming()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="packet__queue_8cc_source.html#l00107">PacketQueue::schedSendTiming()</a>, <a class="el" href="policy_8cc_source.html#l00051">QoS::Policy::schedule()</a>, <a class="el" href="mem__ctrl_8cc_source.html#l00228">QoS::MemCtrl::schedule()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="packet_8cc_source.html#l00354">setUintX()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00282">X86ISA::Walker::WalkerState::stepWalk()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00101">testAndRead()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00127">testAndReadMask()</a>, <a class="el" href="RubySlicc__Util_8hh_source.html#l00156">testAndWrite()</a>, <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00316">SerialLink::SerialLinkSlavePort::trySendTiming()</a>, <a class="el" href="serial__link_8cc_source.html#l00273">SerialLink::SerialLinkMasterPort::trySendTiming()</a>, <a class="el" href="mshr_8hh_source.html#l00231">MSHR::TargetList::updateWriteFlags()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00162">MmioVirtIO::write()</a>, <a class="el" href="pci_8cc_source.html#l00149">PciVirtIO::write()</a>, <a class="el" href="i8237_8cc_source.html#l00072">X86ISA::I8237::write()</a>, <a class="el" href="mm__disk_8cc_source.html#l00114">MmDisk::write()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00170">NoMaliGpu::write()</a>, <a class="el" href="pl011_8cc_source.html#l00172">Pl011::write()</a>, <a class="el" href="speaker_8cc_source.html#l00057">X86ISA::Speaker::write()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00156">TsunamiPChip::write()</a>, <a class="el" href="isa__fake_8cc_source.html#l00094">IsaFake::write()</a>, <a class="el" href="uart8250_8cc_source.html#l00177">Uart8250::write()</a>, <a class="el" href="cmos_8cc_source.html#l00067">X86ISA::Cmos::write()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00190">TsunamiCChip::write()</a>, <a class="el" href="i8254_8cc_source.html#l00068">X86ISA::I8254::write()</a>, <a class="el" href="i82094aa_8cc_source.html#l00112">X86ISA::I82094AA::write()</a>, <a class="el" href="i8259_8cc_source.html#l00097">X86ISA::I8259::write()</a>, <a class="el" href="hdlcd_8cc_source.html#l00258">HDLcd::write()</a>, <a class="el" href="backdoor_8cc_source.html#l00201">AlphaBackdoor::write()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00123">PL031::write()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00150">TsunamiIO::write()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00150">EnergyCtrl::write()</a>, <a class="el" href="kmi_8cc_source.html#l00115">Pl050::write()</a>, <a class="el" href="i8042_8cc_source.html#l00145">X86ISA::I8042::write()</a>, <a class="el" href="dispatcher_8cc_source.html#l00157">GpuDispatcher::write()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00893">Gicv3Its::write()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00121">Sp804::write()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00146">A9GlobalTimer::write()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00170">CpuLocalTimer::write()</a>, <a class="el" href="copy__engine_8cc_source.html#l00292">CopyEngine::write()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00209">X86ISA::Interrupts::write()</a>, <a class="el" href="sinic_8cc_source.html#l00297">Sinic::Device::write()</a>, <a class="el" href="host_8cc_source.html#l00160">GenericPciHost::write()</a>, <a class="el" href="generic__timer_8cc_source.html#l00598">GenericTimerMem::write()</a>, <a class="el" href="ns__gige_8cc_source.html#l00409">NSGigE::write()</a>, <a class="el" href="pl111_8cc_source.html#l00230">Pl111::write()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00358">IGbE::write()</a>, <a class="el" href="ufs__device_8cc_source.html#l01067">UFSHostDevice::write()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00259">IdeController::writeConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00288">PciDevice::writeConfig()</a>, <a class="el" href="dev_2virtio_2base_8cc_source.html#l00435">VirtIODeviceBase::writeConfigBlob()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00615">SMMUv3::writeControl()</a>, and <a class="el" href="gic__v2_8cc_source.html#l00389">GicV2::writeDistributor()</a>.</p>

</div>
</div>
<a id="ac361e7820fd71efef377343b25d56b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac361e7820fd71efef377343b25d56b83">&#9670;&nbsp;</a></span>getUintX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Packet::getUintX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>endian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data in the packet byte swapped from the specified endianness and zero-extended to 64 bits. </p>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00337">337</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00736">getSize()</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00258">AbstractMemory::checkLockedAddrList()</a>, <a class="el" href="simple_8cc_source.html#l00071">SimpleUart::write()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, and <a class="el" href="kmi_8cc_source.html#l00115">Pl050::write()</a>.</p>

</div>
</div>
<a id="a389afe9616729132378ab8228a74441d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389afe9616729132378ab8228a74441d">&#9670;&nbsp;</a></span>hasData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::hasData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00548">548</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00220">MemCmd::hasData()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01396">BaseCache::allocateBlock()</a>, <a class="el" href="xbar_8cc_source.html#l00103">BaseXBar::calcPacketTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00263">DRAMCtrl::recvAtomic()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00880">CoherentXBar::recvAtomicSnoop()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="mshr_8cc_source.html#l00139">replaceUpgrade()</a>, and <a class="el" href="packet_8hh_source.html#l01264">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="ae096121f2a49ded72e13e144089dce7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae096121f2a49ded72e13e144089dce7c">&#9670;&nbsp;</a></span>hasRespData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::hasRespData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00549">549</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00220">MemCmd::hasData()</a>, and <a class="el" href="packet_8hh_source.html#l00231">MemCmd::responseCommand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mshr_8cc_source.html#l00139">replaceUpgrade()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>.</p>

</div>
</div>
<a id="a85724e95fcdde23c4f33840cfa04bc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85724e95fcdde23c4f33840cfa04bc98">&#9670;&nbsp;</a></span>hasSharers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::hasSharers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00618">618</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00320">NoncoherentCache::recvTimingResp()</a>, <a class="el" href="fetch__impl_8hh_source.html#l01677">DefaultFetch&lt; Impl &gt;::IcachePort::recvTimingResp()</a>, <a class="el" href="dma__device_8cc_source.html#l00111">DmaPort::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00301">SnoopFilter::updateSnoopForward()</a>, and <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>.</p>

</div>
</div>
<a id="a360150749606cbb2a28ab49e5351fbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360150749606cbb2a28ab49e5351fbab">&#9670;&nbsp;</a></span>isAtomicOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isAtomicOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00765">765</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>.</p>

</div>
</div>
<a id="a3184768b024571a5c3a4e6f36bdf5170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3184768b024571a5c3a4e6f36bdf5170">&#9670;&nbsp;</a></span>isBlockCached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isBlockCached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00692">692</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l01316">Cache::isCachedAbove()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>.</p>

</div>
</div>
<a id="ad1382602367d7ce5546d941e7bb13d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1382602367d7ce5546d941e7bb13d8f">&#9670;&nbsp;</a></span>isClean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isClean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00545">545</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00206">MemCmd::isClean()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01094">CoherentXBar::forwardPacket()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="mshr_8hh_source.html#l00347">MSHR::isCleaning()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>.</p>

</div>
</div>
<a id="a40dd5b3ed1383009029c27edfaf24d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dd5b3ed1383009029c27edfaf24d07">&#9670;&nbsp;</a></span>isCleanEviction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isCleanEviction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this packet a clean eviction, including both actual clean evict packets, but also clean writebacks. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01300">1300</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00095">MemCmd::CleanEvict</a>, and <a class="el" href="packet_8hh_source.html#l00093">MemCmd::WritebackClean</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>.</p>

</div>
</div>
<a id="a58f5ba118cd03b6948424973cfe46154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f5ba118cd03b6948424973cfe46154">&#9670;&nbsp;</a></span>isError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00555">555</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00226">MemCmd::isError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00568">AtomicSimpleCPU::amoMem()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00878">TimingSimpleCPU::completeDataAccess()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00774">TimingSimpleCPU::completeIfetch()</a>, <a class="el" href="memtest_8cc_source.html#l00135">MemTest::completeRequest()</a>, <a class="el" href="packet_8hh_source.html#l00724">copyError()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="execute_8cc_source.html#l00321">Minor::Execute::handleMemResponse()</a>, <a class="el" href="fetch1_8cc_source.html#l00398">Minor::Fetch1::minorTraceResponseLine()</a>, <a class="el" href="stage2__mmu_8cc_source.html#l00064">ArmISA::Stage2MMU::readDataUntimed()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00372">AtomicSimpleCPU::readMem()</a>, <a class="el" href="io__device_8hh_source.html#l00070">PioPort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="fetch1_8cc_source.html#l00417">Minor::Fetch1::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01287">Minor::LSQ::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00326">LSQ&lt; Impl &gt;::recvTimingResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00633">AtomicSimpleCPU::tick()</a>, and <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00454">AtomicSimpleCPU::writeMem()</a>.</p>

</div>
</div>
<a id="aee3d51b535ec42973453f5584dc16cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3d51b535ec42973453f5584dc16cb6">&#9670;&nbsp;</a></span>isEviction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isEviction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00544">544</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00205">MemCmd::isEviction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00091">WriteQueueEntry::allocate()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l01316">Cache::isCachedAbove()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, and <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>.</p>

</div>
</div>
<a id="a4793369116c8c7782ed5033539c7f543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4793369116c8c7782ed5033539c7f543">&#9670;&nbsp;</a></span>isExpressSnoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isExpressSnoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00634">634</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="packet_8cc_source.html#l00376">print()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="packet__queue_8cc_source.html#l00107">PacketQueue::schedSendTiming()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l02326">BaseCache::CpuSidePort::tryTiming()</a>.</p>

</div>
</div>
<a id="aa8ee0394a64976dcca1035076e363131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ee0394a64976dcca1035076e363131">&#9670;&nbsp;</a></span>isFlush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00557">557</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00228">MemCmd::isFlush()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="Sequencer_8cc_source.html#l00620">Sequencer::issueRequest()</a>, <a class="el" href="Sequencer_8cc_source.html#l00517">Sequencer::makeRequest()</a>, and <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>.</p>

</div>
</div>
<a id="ad9975fd49c410e40ac9b6c5ebc872caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9975fd49c410e40ac9b6c5ebc872caa">&#9670;&nbsp;</a></span>isInvalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isInvalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00543">543</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00204">MemCmd::isInvalidate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l00371">LSQUnit&lt; Impl &gt;::checkSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00927">Cache::doTimingSupplyResponse()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="arm_2locked__mem_8hh_source.html#l00065">ArmISA::handleLockedSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00127">BasePrefetcher::observeAccess()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00284">AtomicSimpleCPU::AtomicCPUDPort::recvAtomicSnoop()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00314">AtomicSimpleCPU::AtomicCPUDPort::recvFunctionalSnoop()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00320">NoncoherentCache::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00326">LSQ&lt; Impl &gt;::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00947">TimingSimpleCPU::DcachePort::recvTimingSnoopReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01745">Minor::LSQ::recvTimingSnoopReq()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00364">LSQ&lt; Impl &gt;::recvTimingSnoopReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01765">Minor::LSQ::threadSnoop()</a>, and <a class="el" href="snoop__filter_8cc_source.html#l00338">SnoopFilter::updateResponse()</a>.</p>

</div>
</div>
<a id="a4dd3ec691f080416b43c501f974b176f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd3ec691f080416b43c501f974b176f">&#9670;&nbsp;</a></span>isLLSC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isLLSC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00554">554</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00221">MemCmd::isLLSC()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00258">AbstractMemory::checkLockedAddrList()</a>, <a class="el" href="cache__blk_8hh_source.html#l00395">CacheBlk::checkWrite()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="Sequencer_8cc_source.html#l00517">Sequencer::makeRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="cache__blk_8hh_source.html#l00312">CacheBlk::trackLoadLocked()</a>, and <a class="el" href="abstract__mem_8hh_source.html#l00149">AbstractMemory::writeOK()</a>.</p>

</div>
</div>
<a id="a8d78f7c3553b71471d97e1a5db7f1450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d78f7c3553b71471d97e1a5db7f1450">&#9670;&nbsp;</a></span>isMaskedWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isMaskedWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01306">1306</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="x86_2pagetable_8hh_source.html#l00142">X86ISA::base</a>, and <a class="el" href="packet_8hh_source.html#l00090">MemCmd::WriteReq</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00304">Cache::promoteWholeLineWrites()</a>, and <a class="el" href="packet_8hh_source.html#l01264">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="a60a4bf642d67ecbba475a400c0842066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a4bf642d67ecbba475a400c0842066">&#9670;&nbsp;</a></span>isPrint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isPrint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00556">556</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00227">MemCmd::isPrint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00286">NoncoherentXBar::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00992">CoherentXBar::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01027">CoherentXBar::recvFunctionalSnoop()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00128">WriteQueueEntry::trySatisfyFunctional()</a>, <a class="el" href="mshr_8cc_source.html#l00640">MSHR::trySatisfyFunctional()</a>, and <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="a1c89f5514a473f96561758b00c4a5e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c89f5514a473f96561758b00c4a5e00">&#9670;&nbsp;</a></span>isRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00528">528</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00197">MemCmd::isRead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00340">SimpleCache::accessFunctional()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="memtest_8cc_source.html#l00135">MemTest::completeRequest()</a>, <a class="el" href="mem__delay_8cc_source.html#l00180">SimpleMemDelay::delayReq()</a>, <a class="el" href="mem__delay_8cc_source.html#l00192">SimpleMemDelay::delayResp()</a>, <a class="el" href="cache_8cc_source.html#l00927">Cache::doTimingSupplyResponse()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01094">CoherentXBar::forwardPacket()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="mmapped__ipr_8cc_source.html#l00042">handlePseudoInst()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00259">TimingSimpleCPU::handleReadPacket()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="Sequencer_8cc_source.html#l00517">Sequencer::makeRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00127">BasePrefetcher::observeAccess()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="compute__unit_8cc_source.html#l00976">ComputeUnit::DataPort::processMemRespEvent()</a>, <a class="el" href="mem__sink_8cc_source.html#l00199">QoS::MemSinkCtrl::processNextReqEvent()</a>, <a class="el" href="io__device_8hh_source.html#l00070">PioPort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="smmu__v3__ports_8cc_source.html#l00118">SMMUControlPort::recvAtomic()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00223">NoncoherentCache::recvAtomic()</a>, <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00601">X86ISA::Walker::WalkerState::recvPacket()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l01004">TimingSimpleCPU::DcachePort::recvReqRetry()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00138">NoncoherentCache::recvTimingReq()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00284">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="dramsim2_8cc_source.html#l00178">DRAMSim2::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00586">DRAMCtrl::recvTimingReq()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00320">NoncoherentCache::recvTimingResp()</a>, <a class="el" href="AbstractController_8cc_source.html#l00328">AbstractController::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00413">CommMonitor::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00073">NoncoherentCache::satisfyRequest()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>, and <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="ac9867cdbf0c0157b274dc11fe177a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9867cdbf0c0157b274dc11fe177a449">&#9670;&nbsp;</a></span>isRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00531">531</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00200">MemCmd::isRequest()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00164">Cache::access()</a>, <a class="el" href="physical_8cc_source.html#l00278">PhysicalMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00680">BaseCache::cmpAndSwap()</a>, <a class="el" href="packet_8cc_source.html#l00309">copyResponderFlags()</a>, <a class="el" href="cache_8cc_source.html#l00927">Cache::doTimingSupplyResponse()</a>, <a class="el" href="physical_8cc_source.html#l00287">PhysicalMemory::functionalAccess()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01159">X86ISA::GpuTLB::handleTranslationReturn()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l02341">BaseCache::CpuSidePort::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00417">RubyPort::ruby_hit_callback()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="functional_8cc_source.html#l00050">FunctionalRequestProtocol::send()</a>, <a class="el" href="mem_2protocol_2atomic_8cc_source.html#l00052">AtomicRequestProtocol::send()</a>, <a class="el" href="mem_2protocol_2atomic_8cc_source.html#l00059">AtomicRequestProtocol::sendBackdoor()</a>, <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00050">TimingRequestProtocol::sendReq()</a>, <a class="el" href="functional_8cc_source.html#l00060">FunctionalResponseProtocol::sendSnoop()</a>, <a class="el" href="mem_2protocol_2atomic_8cc_source.html#l00069">AtomicResponseProtocol::sendSnoop()</a>, <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00088">TimingResponseProtocol::sendSnoopReq()</a>, <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00057">TimingRequestProtocol::trySend()</a>, and <a class="el" href="tlb__coalescer_8cc_source.html#l00142">TLBCoalescer::updatePhysAddresses()</a>.</p>

</div>
</div>
<a id="ae116431868d1c7f6b0dd127bbb7faeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae116431868d1c7f6b0dd127bbb7faeab">&#9670;&nbsp;</a></span>isResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00532">532</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00201">MemCmd::isResponse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="dramsim2_8cc_source.html#l00251">DRAMSim2::accessAndRespond()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00887">DRAMCtrl::accessAndRespond()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00266">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::b_transport()</a>, <a class="el" href="GarnetSyntheticTraffic_8cc_source.html#l00129">GarnetSyntheticTraffic::completeRequest()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00921">CoherentXBar::forwardAtomic()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01048">CoherentXBar::forwardFunctional()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="dma__device_8cc_source.html#l00068">DmaPort::handleResp()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="simple__cache_8cc_source.html#l00360">SimpleCache::insert()</a>, <a class="el" href="io__device_8hh_source.html#l00070">PioPort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00345">CommMonitor::recvAtomic()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00880">CoherentXBar::recvAtomicSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00992">CoherentXBar::recvFunctional()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00601">X86ISA::Walker::WalkerState::recvPacket()</a>, <a class="el" href="tport_8cc_source.html#l00063">SimpleTimingPort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00168">RubyPort::MemMasterPort::recvTimingResp()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00320">NoncoherentCache::recvTimingResp()</a>, <a class="el" href="intdev_8hh_source.html#l00122">X86ISA::IntMasterPort&lt; X86ISA::I82094AA &gt;::recvTimingResp()</a>, <a class="el" href="AbstractController_8cc_source.html#l00328">AbstractController::recvTimingResp()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00381">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00413">CommMonitor::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l02312">BaseCache::CpuSidePort::recvTimingSnoopResp()</a>, <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00081">TimingResponseProtocol::sendResp()</a>, <a class="el" href="mem_2protocol_2timing_8cc_source.html#l00065">TimingRequestProtocol::sendSnoopResp()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00338">SnoopFilter::updateResponse()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00301">SnoopFilter::updateSnoopForward()</a>, and <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>.</p>

</div>
</div>
<a id="aca85c7ecfa5461f6804ad4dbaec28b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca85c7ecfa5461f6804ad4dbaec28b29">&#9670;&nbsp;</a></span>isSecure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isSecure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00755">755</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00164">Cache::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00091">WriteQueueEntry::allocate()</a>, <a class="el" href="mshr_8cc_source.html#l00253">MSHR::allocate()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01396">BaseCache::allocateBlock()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01107">BaseCache::allocateWriteBuffer()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00720">BaseCache::getNextQueueEntry()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00122">NoncoherentCache::handleTimingReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="mem_2cache_2tags_2base_8cc_source.html#l00103">BaseTags::insertBlock()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="packet_8cc_source.html#l00411">matchAddr()</a>, <a class="el" href="packet_8cc_source.html#l00397">matchBlockAddr()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00203">BasePrefetcher::probeNotify()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="cache_8cc_source.html#l01303">Cache::recvAtomicSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="cache_8cc_source.html#l01344">Cache::sendMSHRQueuePacket()</a>, <a class="el" href="packet_8hh_source.html#l01264">trySatisfyFunctional()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00338">SnoopFilter::updateResponse()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00301">SnoopFilter::updateSnoopForward()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>, and <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>.</p>

</div>
</div>
<a id="ad64520e61c50912cbe56e3c408a443ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64520e61c50912cbe56e3c408a443ac">&#9670;&nbsp;</a></span>isUpgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isUpgrade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00530">530</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00199">MemCmd::isUpgrade()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, and <a class="el" href="mshr_8cc_source.html#l00078">MSHR::TargetList::updateFlags()</a>.</p>

</div>
</div>
<a id="aea2db9fe64102760c36d61a948dc6414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2db9fe64102760c36d61a948dc6414">&#9670;&nbsp;</a></span>isWholeLineWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isWholeLineWrite </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>blk_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00559">559</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="Address_8cc_source.html#l00048">getOffset()</a>, <a class="el" href="packet_8hh_source.html#l00101">MemCmd::WriteLineReq</a>, and <a class="el" href="packet_8hh_source.html#l00090">MemCmd::WriteReq</a>.</p>

<p class="reference">Referenced by <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, and <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>.</p>

</div>
</div>
<a id="aec89f98657b94e77f4f7a3087dfe690c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec89f98657b94e77f4f7a3087dfe690c">&#9670;&nbsp;</a></span>isWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00529">529</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00198">MemCmd::isWrite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00164">Cache::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00340">SimpleCache::accessFunctional()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00380">DRAMCtrl::addToReadQueue()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00487">DRAMCtrl::addToWriteQueue()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00091">WriteQueueEntry::allocate()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01107">BaseCache::allocateWriteBuffer()</a>, <a class="el" href="cache__blk_8hh_source.html#l00395">CacheBlk::checkWrite()</a>, <a class="el" href="trace__cpu_8cc_source.html#l00739">TraceCPU::ElasticDataGen::completeMemAccess()</a>, <a class="el" href="GarnetSyntheticTraffic_8cc_source.html#l00129">GarnetSyntheticTraffic::completeRequest()</a>, <a class="el" href="memtest_8cc_source.html#l00135">MemTest::completeRequest()</a>, <a class="el" href="mem__delay_8cc_source.html#l00180">SimpleMemDelay::delayReq()</a>, <a class="el" href="mem__delay_8cc_source.html#l00192">SimpleMemDelay::delayResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01094">CoherentXBar::forwardPacket()</a>, <a class="el" href="smmu__v3__transl_8cc_source.html#l00049">SMMUTranslRequest::fromPacket()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="arm_2locked__mem_8hh_source.html#l00065">ArmISA::handleLockedSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, <a class="el" href="DMASequencer_8cc_source.html#l00065">DMASequencer::makeRequest()</a>, <a class="el" href="Sequencer_8cc_source.html#l00517">Sequencer::makeRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00203">BasePrefetcher::probeNotify()</a>, <a class="el" href="compute__unit_8cc_source.html#l00976">ComputeUnit::DataPort::processMemRespEvent()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00223">NoncoherentCache::recvAtomic()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00284">AtomicSimpleCPU::AtomicCPUDPort::recvAtomicSnoop()</a>, <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l01004">TimingSimpleCPU::DcachePort::recvReqRetry()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00138">NoncoherentCache::recvTimingReq()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00140">SMMUv3SlaveInterface::recvTimingReq()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00284">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="dramsim2_8cc_source.html#l00178">DRAMSim2::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00586">DRAMCtrl::recvTimingReq()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00464">BaseTrafficGen::recvTimingResp()</a>, <a class="el" href="AbstractController_8cc_source.html#l00328">AbstractController::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00413">CommMonitor::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00947">TimingSimpleCPU::DcachePort::recvTimingSnoopReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01745">Minor::LSQ::recvTimingSnoopReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00073">NoncoherentCache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01765">Minor::LSQ::threadSnoop()</a>, <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>, and <a class="el" href="mshr_8hh_source.html#l00231">MSHR::TargetList::updateWriteFlags()</a>.</p>

</div>
</div>
<a id="a2875abee78be7cb12a52829cd793213d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2875abee78be7cb12a52829cd793213d">&#9670;&nbsp;</a></span>isWriteback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::isWriteback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00547">547</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00212">MemCmd::isWriteback()</a>.</p>

<p class="reference">Referenced by <a class="el" href="noncoherent__cache_8cc_source.html#l00083">NoncoherentCache::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, and <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>.</p>

</div>
</div>
<a id="a79f71e6885712d4951e70eaba2e364cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f71e6885712d4951e70eaba2e364cb">&#9670;&nbsp;</a></span>makeAtomicResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::makeAtomicResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00949">949</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="smmu__v3__transl_8cc_source.html#l01226">SMMUTranslationProcess::completeTransaction()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00488">IdeController::dispatchAccess()</a>, <a class="el" href="sparc_2tlb_8cc_source.html#l00861">SparcISA::TLB::doMmuRegRead()</a>, <a class="el" href="sparc_2tlb_8cc_source.html#l01046">SparcISA::TLB::doMmuRegWrite()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="simple_8cc_source.html#l00055">SimpleUart::read()</a>, <a class="el" href="i8237_8cc_source.html#l00037">X86ISA::I8237::read()</a>, <a class="el" href="mm__disk_8cc_source.html#l00056">MmDisk::read()</a>, <a class="el" href="dtod_8cc_source.html#l00062">DumbTOD::read()</a>, <a class="el" href="pl011_8cc_source.html#l00067">Pl011::read()</a>, <a class="el" href="amba__fake_8cc_source.html#l00056">AmbaFake::read()</a>, <a class="el" href="a9scu_8cc_source.html#l00054">A9SCU::read()</a>, <a class="el" href="speaker_8cc_source.html#l00041">X86ISA::Speaker::read()</a>, <a class="el" href="isa__fake_8cc_source.html#l00055">IsaFake::read()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00072">TsunamiPChip::read()</a>, <a class="el" href="uart8250_8cc_source.html#l00096">Uart8250::read()</a>, <a class="el" href="cmos_8cc_source.html#l00048">X86ISA::Cmos::read()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00074">TsunamiCChip::read()</a>, <a class="el" href="i8254_8cc_source.html#l00052">X86ISA::I8254::read()</a>, <a class="el" href="i82094aa_8cc_source.html#l00093">X86ISA::I82094AA::read()</a>, <a class="el" href="i8259_8cc_source.html#l00073">X86ISA::I8259::read()</a>, <a class="el" href="hdlcd_8cc_source.html#l00238">HDLcd::read()</a>, <a class="el" href="gic__v2m_8cc_source.html#l00107">Gicv2m::read()</a>, <a class="el" href="backdoor_8cc_source.html#l00103">AlphaBackdoor::read()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00061">PL031::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00087">TsunamiIO::read()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00064">EnergyCtrl::read()</a>, <a class="el" href="kmi_8cc_source.html#l00063">Pl050::read()</a>, <a class="el" href="iob_8cc_source.html#l00077">Iob::read()</a>, <a class="el" href="i8042_8cc_source.html#l00126">X86ISA::I8042::read()</a>, <a class="el" href="dispatcher_8cc_source.html#l00127">GpuDispatcher::read()</a>, <a class="el" href="bus_8cc_source.html#l00071">I2CBus::read()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00819">Gicv3Its::read()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00066">Sp804::read()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00066">A9GlobalTimer::read()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00056">RealViewCtrl::read()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00092">CpuLocalTimer::read()</a>, <a class="el" href="copy__engine_8cc_source.html#l00169">CopyEngine::read()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00192">X86ISA::Interrupts::read()</a>, <a class="el" href="host_8cc_source.html#l00136">GenericPciHost::read()</a>, <a class="el" href="ns__gige_8cc_source.html#l00187">NSGigE::read()</a>, <a class="el" href="pl111_8cc_source.html#l00101">Pl111::read()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00170">IGbE::read()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00177">IdeController::readConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00220">PciDevice::readConfig()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00582">SMMUv3::readControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00291">GicV2::readCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00144">VGic::readCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00140">GicV2::readDistributor()</a>, <a class="el" href="vgic_8cc_source.html#l00097">VGic::readVCpu()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00304">X86ISA::Interrupts::recvMessage()</a>, <a class="el" href="simple_8cc_source.html#l00071">SimpleUart::write()</a>, <a class="el" href="i8237_8cc_source.html#l00072">X86ISA::I8237::write()</a>, <a class="el" href="mm__disk_8cc_source.html#l00114">MmDisk::write()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00170">NoMaliGpu::write()</a>, <a class="el" href="pl011_8cc_source.html#l00172">Pl011::write()</a>, <a class="el" href="amba__fake_8cc_source.html#l00073">AmbaFake::write()</a>, <a class="el" href="speaker_8cc_source.html#l00057">X86ISA::Speaker::write()</a>, <a class="el" href="a9scu_8cc_source.html#l00091">A9SCU::write()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00156">TsunamiPChip::write()</a>, <a class="el" href="isa__fake_8cc_source.html#l00094">IsaFake::write()</a>, <a class="el" href="uart8250_8cc_source.html#l00177">Uart8250::write()</a>, <a class="el" href="cmos_8cc_source.html#l00067">X86ISA::Cmos::write()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00190">TsunamiCChip::write()</a>, <a class="el" href="i8254_8cc_source.html#l00068">X86ISA::I8254::write()</a>, <a class="el" href="i82094aa_8cc_source.html#l00112">X86ISA::I82094AA::write()</a>, <a class="el" href="i8259_8cc_source.html#l00097">X86ISA::I8259::write()</a>, <a class="el" href="hdlcd_8cc_source.html#l00258">HDLcd::write()</a>, <a class="el" href="gic__v2m_8cc_source.html#l00137">Gicv2m::write()</a>, <a class="el" href="backdoor_8cc_source.html#l00201">AlphaBackdoor::write()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00123">PL031::write()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00150">TsunamiIO::write()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00150">EnergyCtrl::write()</a>, <a class="el" href="kmi_8cc_source.html#l00115">Pl050::write()</a>, <a class="el" href="iob_8cc_source.html#l00171">Iob::write()</a>, <a class="el" href="i8042_8cc_source.html#l00145">X86ISA::I8042::write()</a>, <a class="el" href="dispatcher_8cc_source.html#l00157">GpuDispatcher::write()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00893">Gicv3Its::write()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00121">Sp804::write()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00146">A9GlobalTimer::write()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00132">RealViewCtrl::write()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00170">CpuLocalTimer::write()</a>, <a class="el" href="copy__engine_8cc_source.html#l00292">CopyEngine::write()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00209">X86ISA::Interrupts::write()</a>, <a class="el" href="ns__gige_8cc_source.html#l00409">NSGigE::write()</a>, <a class="el" href="pl111_8cc_source.html#l00230">Pl111::write()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00358">IGbE::write()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00259">IdeController::writeConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00288">PciDevice::writeConfig()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00615">SMMUv3::writeControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00558">GicV2::writeCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00287">VGic::writeCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00389">GicV2::writeDistributor()</a>, and <a class="el" href="vgic_8cc_source.html#l00238">VGic::writeVCpu()</a>.</p>

</div>
</div>
<a id="a8069f9318acf9cb9576e0ae200f53b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8069f9318acf9cb9576e0ae200f53b2e">&#9670;&nbsp;</a></span>makeReadCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMemCmd.html">MemCmd</a> Packet::makeReadCmd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the appropriate read <a class="el" href="classMemCmd.html">MemCmd</a> based on the <a class="el" href="classRequest.html">Request</a> flags. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00877">877</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00111">MemCmd::LoadLockedReq</a>, <a class="el" href="packet_8hh_source.html#l00087">MemCmd::ReadReq</a>, <a class="el" href="packet_8hh_source.html#l00097">MemCmd::SoftPFExReq</a>, and <a class="el" href="packet_8hh_source.html#l00096">MemCmd::SoftPFReq</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00372">AtomicSimpleCPU::readMem()</a>.</p>

</div>
</div>
<a id="a51e1ba3f32ebb3c8be10cf9b58ca54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e1ba3f32ebb3c8be10cf9b58ca54e0">&#9670;&nbsp;</a></span>makeResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::makeResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a request packet and modify it in place to be suitable for returning as a response to that request. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00937">937</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00068">Flags&lt; T &gt;::clear()</a>, <a class="el" href="packet_8hh_source.html#l00200">MemCmd::isRequest()</a>, <a class="el" href="packet_8hh_source.html#l00203">MemCmd::needsResponse()</a>, and <a class="el" href="packet_8hh_source.html#l00231">MemCmd::responseCommand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="simple__cache_8cc_source.html#l00272">SimpleCache::handleFunctional()</a>, <a class="el" href="simple__cache_8cc_source.html#l00217">SimpleCache::handleResponse()</a>, <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="external__slave_8cc_source.html#l00119">StubSlavePort::processResponseEvent()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00064">MmioVirtIO::read()</a>, <a class="el" href="pci_8cc_source.html#l00068">PciVirtIO::read()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00149">NoMaliGpu::read()</a>, <a class="el" href="generic__timer_8cc_source.html#l00569">GenericTimerMem::read()</a>, <a class="el" href="ufs__device_8cc_source.html#l00929">UFSHostDevice::read()</a>, <a class="el" href="dev_2virtio_2base_8cc_source.html#l00423">VirtIODeviceBase::readConfigBlob()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00216">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvAtomic()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00241">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="mem__delay_8cc_source.html#l00149">MemDelay::SlavePort::recvFunctional()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00286">NoncoherentXBar::recvFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00382">SerialLink::SerialLinkSlavePort::recvFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00350">Bridge::BridgeSlavePort::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00992">CoherentXBar::recvFunctional()</a>, <a class="el" href="mem__delay_8cc_source.html#l00100">MemDelay::MasterPort::recvFunctionalSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01027">CoherentXBar::recvFunctionalSnoop()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00288">TimingSimpleCPU::sendData()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00325">TimingSimpleCPU::sendSplitData()</a>, <a class="el" href="serial__link_8cc_source.html#l00406">SerialLink::SerialLinkMasterPort::trySatisfyFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00374">Bridge::BridgeMasterPort::trySatisfyFunctional()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00959">Minor::LSQ::tryToSendToTransfers()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00162">MmioVirtIO::write()</a>, <a class="el" href="pci_8cc_source.html#l00149">PciVirtIO::write()</a>, <a class="el" href="generic__timer_8cc_source.html#l00598">GenericTimerMem::write()</a>, <a class="el" href="ufs__device_8cc_source.html#l01067">UFSHostDevice::write()</a>, and <a class="el" href="dev_2virtio_2base_8cc_source.html#l00435">VirtIODeviceBase::writeConfigBlob()</a>.</p>

</div>
</div>
<a id="ad570f51a677a215d45a1d04b00cbb8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad570f51a677a215d45a1d04b00cbb8f6">&#9670;&nbsp;</a></span>makeTimingResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::makeTimingResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00955">955</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="smmu__v3__transl_8cc_source.html#l01226">SMMUTranslationProcess::completeTransaction()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00214">BaseCache::handleTimingReqHit()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01159">X86ISA::GpuTLB::handleTranslationReturn()</a>, <a class="el" href="lds__state_8cc_source.html#l00277">LdsState::process()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, and <a class="el" href="tlb__coalescer_8cc_source.html#l00142">TLBCoalescer::updatePhysAddresses()</a>.</p>

</div>
</div>
<a id="acddc6f454f6aedd83cb1f21c8e2309aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acddc6f454f6aedd83cb1f21c8e2309aa">&#9670;&nbsp;</a></span>makeWriteCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMemCmd.html">MemCmd</a> Packet::makeWriteCmd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the appropriate write <a class="el" href="classMemCmd.html">MemCmd</a> based on the <a class="el" href="classRequest.html">Request</a> flags. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00893">893</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00122">MemCmd::CleanInvalidReq</a>, <a class="el" href="packet_8hh_source.html#l00120">MemCmd::CleanSharedReq</a>, <a class="el" href="packet_8hh_source.html#l00135">MemCmd::InvalidateReq</a>, <a class="el" href="packet_8hh_source.html#l00112">MemCmd::StoreCondReq</a>, <a class="el" href="packet_8hh_source.html#l00115">MemCmd::SwapReq</a>, and <a class="el" href="packet_8hh_source.html#l00090">MemCmd::WriteReq</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00568">AtomicSimpleCPU::amoMem()</a>, and <a class="el" href="cpu_2simple_2atomic_8cc_source.html#l00454">AtomicSimpleCPU::writeMem()</a>.</p>

</div>
</div>
<a id="a41f5b1c9a747b4bf94bc3d1993467f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f5b1c9a747b4bf94bc3d1993467f65">&#9670;&nbsp;</a></span>masterId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="request_8hh.html#ac366b729262fd8e7cbd3283da6f775cf">MasterID</a> Packet::masterId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00712">712</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="dram__ctrl_8cc_source.html#l00380">DRAMCtrl::addToReadQueue()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00487">DRAMCtrl::addToWriteQueue()</a>, <a class="el" href="q__policy_8cc_source.html#l00139">QoS::LrgQueuePolicy::enqueuePacket()</a>, and <a class="el" href="mem__ctrl_8hh_source.html#l00475">QoS::MemCtrl::qosSchedule()</a>.</p>

</div>
</div>
<a id="ab9c0bdd57c5359e7d87426bafd1c2601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c0bdd57c5359e7d87426bafd1c2601">&#9670;&nbsp;</a></span>matchAddr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::matchAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_secure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if packet corresponds to a given address and address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to compare against. </td></tr>
    <tr><td class="paramname">is_secure</td><td>Whether addr belongs to the secure address space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether packet matches description. </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00411">411</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00726">getAddr()</a>, and <a class="el" href="packet_8hh_source.html#l00755">isSecure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet_8cc_source.html#l00417">matchAddr()</a>, and <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>.</p>

</div>
</div>
<a id="ae265ff27bb1d6ada0ccd80161f0c1062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae265ff27bb1d6ada0ccd80161f0c1062">&#9670;&nbsp;</a></span>matchAddr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::matchAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if this packet refers to the same address and address space as another packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The packet to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether packet matches description. </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00417">417</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00726">getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00755">isSecure()</a>, and <a class="el" href="packet_8cc_source.html#l00411">matchAddr()</a>.</p>

</div>
</div>
<a id="a52f406cf48fe096291edf795a3c46b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f406cf48fe096291edf795a3c46b98">&#9670;&nbsp;</a></span>matchBlockAddr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::matchBlockAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_secure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if packet corresponds to a given block-aligned address and address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to compare against. </td></tr>
    <tr><td class="paramname">is_secure</td><td>Whether addr belongs to the secure address space. </td></tr>
    <tr><td class="paramname">blk_size</td><td><a class="el" href="structBlock.html">Block</a> size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether packet matches description. </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00397">397</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00750">getBlockAddr()</a>, and <a class="el" href="packet_8hh_source.html#l00755">isSecure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="write__queue__entry_8cc_source.html#l00091">WriteQueueEntry::allocate()</a>, <a class="el" href="mshr_8cc_source.html#l00253">MSHR::allocate()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00155">WriteQueueEntry::matchBlockAddr()</a>, <a class="el" href="mshr_8cc_source.html#l00702">MSHR::matchBlockAddr()</a>, and <a class="el" href="packet_8cc_source.html#l00404">matchBlockAddr()</a>.</p>

</div>
</div>
<a id="a8fe311e0cf09e4a65aca329626d8851b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe311e0cf09e4a65aca329626d8851b">&#9670;&nbsp;</a></span>matchBlockAddr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::matchBlockAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if this packet refers to the same block-aligned address and address space as another packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The packet to compare against. </td></tr>
    <tr><td class="paramname">blk_size</td><td><a class="el" href="structBlock.html">Block</a> size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether packet matches description. </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00404">404</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00750">getBlockAddr()</a>, <a class="el" href="packet_8hh_source.html#l00755">isSecure()</a>, and <a class="el" href="packet_8cc_source.html#l00397">matchBlockAddr()</a>.</p>

</div>
</div>
<a id="ac554a23c5c950992c7d53f323f03fb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554a23c5c950992c7d53f323f03fb95">&#9670;&nbsp;</a></span>mustCheckAbove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::mustCheckAbove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the request need to check for cached copies of the same block in the memory hierarchy above. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01290">1290</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00098">MemCmd::HardPFReq</a>, and <a class="el" href="packet_8hh_source.html#l00205">MemCmd::isEviction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, and <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>.</p>

</div>
</div>
<a id="abb255770a0a1278960af6ffa1e0ceb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb255770a0a1278960af6ffa1e0ceb64">&#9670;&nbsp;</a></span>needsResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::needsResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00542">542</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00203">MemCmd::needsResponse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="dramsim2_8cc_source.html#l00251">DRAMSim2::accessAndRespond()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00887">DRAMCtrl::accessAndRespond()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8hh_source.html#l00180">BaseTrafficGen::allocateWaitingRespSlot()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00266">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::b_transport()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00150">NoncoherentCache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00927">Cache::doTimingSupplyResponse()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00214">BaseCache::handleTimingReqHit()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="mem__sink_8cc_source.html#l00199">QoS::MemSinkCtrl::processNextReqEvent()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00216">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvAtomic()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00345">CommMonitor::recvAtomic()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00241">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00286">NoncoherentXBar::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00992">CoherentXBar::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01027">CoherentXBar::recvFunctionalSnoop()</a>, <a class="el" href="tport_8cc_source.html#l00063">SimpleTimingPort::recvTimingReq()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="bridge_8cc_source.html#l00146">Bridge::BridgeSlavePort::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>, and <a class="el" href="fetch1_8cc_source.html#l00283">Minor::Fetch1::tryToSendToTransfers()</a>.</p>

</div>
</div>
<a id="a85a63311f59c1582ba8a4419e14dfb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a63311f59c1582ba8a4419e14dfb94">&#9670;&nbsp;</a></span>needsWritable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::needsWritable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00533">533</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00200">MemCmd::isRequest()</a>, and <a class="el" href="packet_8hh_source.html#l00202">MemCmd::needsWritable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="mshr_8cc_source.html#l00326">MSHR::allocateTarget()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00658">Cache::recvAtomic()</a>, <a class="el" href="cache_8cc_source.html#l00406">Cache::recvTimingReq()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>, and <a class="el" href="mshr_8cc_source.html#l00078">MSHR::TargetList::updateFlags()</a>.</p>

</div>
</div>
<a id="ad28d4bd566aee12a370dc9180e064bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28d4bd566aee12a370dc9180e064bea">&#9670;&nbsp;</a></span>popLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::popLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop label for PrintReq (safe to call unconditionally). </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01336">1336</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00227">MemCmd::isPrint()</a>, and <a class="el" href="cast_8hh_source.html#l00061">safe_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="mem__sink_8cc_source.html#l00365">QoS::MemSinkCtrl::MemoryPort::recvFunctional()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l02800">DRAMCtrl::MemoryPort::recvFunctional()</a>, <a class="el" href="simple__mem_8cc_source.html#l00094">SimpleMemory::recvFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00382">SerialLink::SerialLinkSlavePort::recvFunctional()</a>, <a class="el" href="dramsim2_8cc_source.html#l00164">DRAMSim2::recvFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00350">Bridge::BridgeSlavePort::recvFunctional()</a>, <a class="el" href="mem__sink_8cc_source.html#l00100">QoS::MemSinkCtrl::recvFunctional()</a>, <a class="el" href="queue_8hh_source.html#l00184">Queue&lt; WriteQueueEntry &gt;::trySatisfyFunctional()</a>, and <a class="el" href="packet__queue_8cc_source.html#l00087">PacketQueue::trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="af6ab9a18584eefa18e4c2b41f208b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ab9a18584eefa18e4c2b41f208b8e6">&#9670;&nbsp;</a></span>popSenderState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPacket_1_1SenderState.html">Packet::SenderState</a> * Packet::popSenderState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the top of the state stack and return a pointer to it. </p>
<p>This assumes the current sender state is not NULL. This should be preferred over direct manipulation of the senderState member variable.</p>
<dl class="section return"><dt>Returns</dt><dd>The current top of the stack </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00327">327</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00405">Packet::SenderState::predecessor</a>, and <a class="el" href="packet_8hh_source.html#l00480">senderState</a>.</p>

<p class="reference">Referenced by <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00215">SMMUv3SlaveInterface::atsMasterRecvTimingResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00129">SMMUv3::masterRecvTimingResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00175">SMMUv3::masterTableWalkRecvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="RubyPort_8cc_source.html#l00168">RubyPort::MemMasterPort::recvTimingResp()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01134">Gicv3Its::recvTimingResp()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00381">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::recvTimingResp()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00110">X86ISA::Walker::recvTimingResp()</a>, <a class="el" href="fetch1_8cc_source.html#l00417">Minor::Fetch1::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01287">Minor::LSQ::recvTimingResp()</a>, <a class="el" href="RubyPort_8cc_source.html#l00417">RubyPort::ruby_hit_callback()</a>, and <a class="el" href="pagetable__walker_8cc_source.html#l00155">X86ISA::Walker::sendTiming()</a>.</p>

</div>
</div>
<a id="a7a19b40cc01e43c41bc99fb7fadb89ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a19b40cc01e43c41bc99fb7fadb89ea">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classPrintable.html#ad9d76688346bdca51c43d865e01b7aad">Printable</a>.</p>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00376">376</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="cprintf_8hh_source.html#l00131">ccprintf()</a>, <a class="el" href="packet_8hh_source.html#l00523">cmdString()</a>, <a class="el" href="packet_8hh_source.html#l00726">getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00736">getSize()</a>, <a class="el" href="packet_8hh_source.html#l00634">isExpressSnoop()</a>, and <a class="el" href="packet_8hh_source.html#l00327">req</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00164">Cache::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01107">BaseCache::allocateWriteBuffer()</a>, <a class="el" href="cache_8cc_source.html#l00899">Cache::cleanEvictBlk()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00150">NoncoherentCache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00927">Cache::doTimingSupplyResponse()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00692">CoherentXBar::forwardTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00214">BaseCache::handleTimingReqHit()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="simple__cache_8cc_source.html#l00360">SimpleCache::insert()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00658">Cache::recvAtomic()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="noncoherent__cache_8hh_source.html#l00106">NoncoherentCache::recvAtomicSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00880">CoherentXBar::recvAtomicSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00992">CoherentXBar::recvFunctional()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l01027">CoherentXBar::recvFunctionalSnoop()</a>, <a class="el" href="simple__cache_8cc_source.html#l00134">SimpleCache::CPUSidePort::recvRespRetry()</a>, <a class="el" href="cache_8cc_source.html#l00406">Cache::recvTimingReq()</a>, <a class="el" href="simple__cache_8cc_source.html#l00111">SimpleCache::CPUSidePort::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00464">BaseTrafficGen::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="noncoherent__cache_8hh_source.html#l00093">NoncoherentCache::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="noncoherent__cache_8hh_source.html#l00097">NoncoherentCache::recvTimingSnoopResp()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="cache_8cc_source.html#l01344">Cache::sendMSHRQueuePacket()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="simple__cache_8cc_source.html#l00072">SimpleCache::CPUSidePort::sendPacket()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01785">BaseCache::sendWriteQueuePacket()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00338">SnoopFilter::updateResponse()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00301">SnoopFilter::updateSnoopForward()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01511">BaseCache::writebackBlk()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01559">BaseCache::writecleanBlk()</a>.</p>

</div>
</div>
<a id="ad81320dcb565590895648b0d2a427763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81320dcb565590895648b0d2a427763">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Packet::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A no-args wrapper of print(std::ostream...) meant to be invoked from DPRINTFs avoiding string overheads in fast mode. </p>
<dl class="section return"><dt>Returns</dt><dd>string with the request's type and start&lt;-&gt;end addresses </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00390">390</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

</div>
</div>
<a id="abf1a177ee6ddce59da49869cfeecc7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1a177ee6ddce59da49869cfeecc7bc">&#9670;&nbsp;</a></span>pushLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::pushLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lbl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push label for PrintReq (safe to call unconditionally). </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01326">1326</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00227">MemCmd::isPrint()</a>, and <a class="el" href="cast_8hh_source.html#l00061">safe_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="mem__sink_8cc_source.html#l00365">QoS::MemSinkCtrl::MemoryPort::recvFunctional()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l02800">DRAMCtrl::MemoryPort::recvFunctional()</a>, <a class="el" href="simple__mem_8cc_source.html#l00094">SimpleMemory::recvFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00382">SerialLink::SerialLinkSlavePort::recvFunctional()</a>, <a class="el" href="dramsim2_8cc_source.html#l00164">DRAMSim2::recvFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00350">Bridge::BridgeSlavePort::recvFunctional()</a>, <a class="el" href="mem__sink_8cc_source.html#l00100">QoS::MemSinkCtrl::recvFunctional()</a>, <a class="el" href="queue_8hh_source.html#l00184">Queue&lt; WriteQueueEntry &gt;::trySatisfyFunctional()</a>, and <a class="el" href="packet__queue_8cc_source.html#l00087">PacketQueue::trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="a8036e59fcb2cf3391e8bb9d0ffc37b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8036e59fcb2cf3391e8bb9d0ffc37b9e">&#9670;&nbsp;</a></span>pushSenderState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::pushSenderState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPacket_1_1SenderState.html">Packet::SenderState</a> *&#160;</td>
          <td class="paramname"><em>sender_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a new sender state to the packet and make the current sender state the predecessor of the new one. </p>
<p>This should be prefered over direct manipulation of the senderState member variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender_state</td><td><a class="el" href="structPacket_1_1SenderState.html" title="A virtual base opaque structure used to hold state associated with the packet (e.g., an MSHR), specific to a SimObject that sees the packet. ">SenderState</a> to push at the top of the stack </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00319">319</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00405">Packet::SenderState::predecessor</a>, and <a class="el" href="packet_8hh_source.html#l00480">senderState</a>.</p>

<p class="reference">Referenced by <a class="el" href="tlm__to__gem5_8cc_source.html#l00142">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::handleBeginReq()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01679">Minor::makePacketForRequest()</a>, <a class="el" href="RubyPort_8cc_source.html#l00304">RubyPort::MemSlavePort::recvAtomic()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00372">CommMonitor::recvTimingReq()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00282">SMMUv3::runProcessTiming()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01160">Gicv3Its::runProcessTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, and <a class="el" href="pagetable__walker_8cc_source.html#l00155">X86ISA::Walker::sendTiming()</a>.</p>

</div>
</div>
<a id="a873cf94ccd31edf1acc095f1b9015554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873cf94ccd31edf1acc095f1b9015554">&#9670;&nbsp;</a></span>qosValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Packet::qosValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceQoS.html">QoS</a> Value getter Returns 0 if <a class="el" href="namespaceQoS.html">QoS</a> value was never set (constructor default). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceQoS.html">QoS</a> priority value of the packet </dd></dl>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00701">701</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="dram__ctrl_8cc_source.html#l00380">DRAMCtrl::addToReadQueue()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00487">DRAMCtrl::addToWriteQueue()</a>, <a class="el" href="mem__sink_8cc_source.html#l00199">QoS::MemSinkCtrl::processNextReqEvent()</a>, <a class="el" href="mem__ctrl_8hh_source.html#l00475">QoS::MemCtrl::qosSchedule()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, and <a class="el" href="mem__ctrl_8cc_source.html#l00228">QoS::MemCtrl::schedule()</a>.</p>

</div>
</div>
<a id="a449abea7fb67b1b6e1a56ea498406eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449abea7fb67b1b6e1a56ea498406eab">&#9670;&nbsp;</a></span>qosValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::qosValue </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>qos_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceQoS.html">QoS</a> Value setter Interface for setting <a class="el" href="namespaceQoS.html">QoS</a> priority value of the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qos_value</td><td><a class="el" href="namespaceQoS.html">QoS</a> priority value </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00709">709</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<a id="a828c8eada6caef43d3b13ca739ebb961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828c8eada6caef43d3b13ca739ebb961">&#9670;&nbsp;</a></span>responderHadWritable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::responderHadWritable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00651">651</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00658">Cache::recvAtomic()</a>, <a class="el" href="cache_8cc_source.html#l00406">Cache::recvTimingReq()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l01070">CoherentXBar::sinkPacket()</a>.</p>

</div>
</div>
<a id="a0db65d99eef3f53f20af61190883d741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db65d99eef3f53f20af61190883d741">&#9670;&nbsp;</a></span>satisfied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::satisfied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00687">687</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>.</p>

</div>
</div>
<a id="ad4e3f9cb71ae74898bd12c0f92c61023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e3f9cb71ae74898bd12c0f92c61023">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the value in the data pointer to v using the specified endianness. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00116">116</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="base_2types_8hh_source.html#l00265">BigEndianByteOrder</a>, <a class="el" href="base_2types_8hh_source.html#l00266">LittleEndianByteOrder</a>, <a class="el" href="logging_8hh_source.html#l00167">panic</a>, and <a class="el" href="miscregs__types_8hh_source.html#l00054">ArmISA::v</a>.</p>

<p class="reference">Referenced by <a class="el" href="mmapped__ipr_8cc_source.html#l00042">handlePseudoInst()</a>, and <a class="el" href="o3_2lsq_8hh_source.html#l00785">LSQ&lt; Impl &gt;::SplitDataRequest::SplitDataRequest()</a>.</p>

</div>
</div>
<a id="acc778666940292e86cad8b4e0aa23835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc778666940292e86cad8b4e0aa23835">&#9670;&nbsp;</a></span>setAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the address of this packet mid-transaction. </p>
<p>This is used by the address mapper to change an already set address to a new one based on the system configuration. It is intended to remap an existing address, so it asserts that the current address is valid. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00734">734</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="smmu__v3__transl_8cc_source.html#l01226">SMMUTranslationProcess::completeTransaction()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00087">AddrMapper::recvAtomic()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00097">AddrMapper::recvAtomicSnoop()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00069">AddrMapper::recvFunctional()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00078">AddrMapper::recvFunctionalSnoop()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00107">AddrMapper::recvTimingReq()</a>, and <a class="el" href="addr__mapper_8cc_source.html#l00135">AddrMapper::recvTimingResp()</a>.</p>

</div>
</div>
<a id="a0099781d30971c8dc263332474851a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0099781d30971c8dc263332474851a7c">&#9670;&nbsp;</a></span>setBadAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setBadAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00718">718</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00129">MemCmd::BadAddressError</a>, and <a class="el" href="packet_8hh_source.html#l00201">MemCmd::isResponse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="isa__fake_8cc_source.html#l00055">IsaFake::read()</a>, <a class="el" href="backdoor_8cc_source.html#l00103">AlphaBackdoor::read()</a>, and <a class="el" href="isa__fake_8cc_source.html#l00094">IsaFake::write()</a>.</p>

</div>
</div>
<a id="a439f3979ae4a456c05b69809a0025e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439f3979ae4a456c05b69809a0025e46">&#9670;&nbsp;</a></span>setBE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setBE </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the value in the data pointer to v as big endian. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00102">102</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="byteswap_8hh_source.html#l00146">htobe()</a>, and <a class="el" href="packet__access_8hh_source.html#l00062">setRaw()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sparc_2tlb_8cc_source.html#l00861">SparcISA::TLB::doMmuRegRead()</a>, <a class="el" href="dtod_8cc_source.html#l00062">DumbTOD::read()</a>, <a class="el" href="iob_8cc_source.html#l00092">Iob::readIob()</a>, and <a class="el" href="iob_8cc_source.html#l00121">Iob::readJBus()</a>.</p>

</div>
</div>
<a id="a4ed3d512e1660940c23561a0605f2ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed3d512e1660940c23561a0605f2ab3">&#9670;&nbsp;</a></span>setBlockCached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setBlockCached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00691">691</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00193">Cache::doWritebacks()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, and <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>.</p>

</div>
</div>
<a id="a115cf2fb1e5b871e02e6286d8b569d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115cf2fb1e5b871e02e6286d8b569d17">&#9670;&nbsp;</a></span>setCacheResponding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setCacheResponding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Snoop flags. </p>
<p><a class="el" href="classSet.html">Set</a> the cacheResponding flag. This is used by the caches to signal another cache that they are responding to a request. A cache will only respond to snoops if it has the line in either Modified or Owned state. Note that on snoop hits we always pass the line as Modified and never Owned. In the case of an Owned line we proceed to invalidate all other copies.</p>
<p>On a cache fill (see <a class="el" href="classBaseCache.html#a22f96dd31e7b45875dadc09783afe325" title="Handle a fill operation caused by a received packet. ">Cache::handleFill</a>), we check hasSharers first, ignoring the cacheResponding flag if hasSharers is set. A line is consequently allocated as:</p>
<p>hasSharers cacheResponding state true false Shared true true Shared false false Exclusive false true Modified </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00585">585</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00200">MemCmd::isRequest()</a>, <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>.</p>

</div>
</div>
<a id="a758810a25a789ae0be9a461fd0bcf7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758810a25a789ae0be9a461fd0bcf7e5">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data into the packet from the provided pointer. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01158">1158</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l01052">GPUCoalescer::atomicCallback()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00680">BaseCache::cmpAndSwap()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="x86_2mmapped__ipr_8hh_source.html#l00058">X86ISA::handleIprRead()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00594">GPUCoalescer::hitCallback()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00192">X86ISA::Interrupts::read()</a>, <a class="el" href="dev_2virtio_2base_8cc_source.html#l00423">VirtIODeviceBase::readConfigBlob()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, and <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>.</p>

</div>
</div>
<a id="a4d5a80b775ab033127c54d2fdedf531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5a80b775ab033127c54d2fdedf531d">&#9670;&nbsp;</a></span>setDataFromBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setDataFromBlock </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>blk_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data into the packet from the provided block pointer, which is aligned to the given block size. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01177">1177</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="Address_8cc_source.html#l00048">getOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple__cache_8cc_source.html#l00340">SimpleCache::accessFunctional()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01511">BaseCache::writebackBlk()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01559">BaseCache::writecleanBlk()</a>.</p>

</div>
</div>
<a id="a72bab6f4a0b9552b6555e57d0cf86b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bab6f4a0b9552b6555e57d0cf86b99">&#9670;&nbsp;</a></span>setExpressSnoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setExpressSnoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The express snoop flag is used for two purposes. </p>
<p>Firstly, it is used to bypass flow control for normal (non-snoop) requests going downstream in the memory system. In cases where a cache is responding to a snoop from another cache (it had a dirty line), but the line is not writable (and there are possibly other copies), the express snoop flag is set by the downstream cache to invalidate all other copies in zero time. Secondly, the express snoop flag is also set to be able to distinguish snoop packets that came from a downstream cache, rather than snoop packets from neighbouring caches. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00633">633</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l01316">Cache::isCachedAbove()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>.</p>

</div>
</div>
<a id="a4d2a4a47715e7fa38b83a42ce217e672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2a4a47715e7fa38b83a42ce217e672">&#9670;&nbsp;</a></span>setFunctionalResponseStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setFunctionalResponseStatus </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00961">961</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00130">MemCmd::FunctionalReadError</a>, <a class="el" href="packet_8hh_source.html#l00131">MemCmd::FunctionalWriteError</a>, and <a class="el" href="packet_8hh_source.html#l00198">MemCmd::isWrite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>.</p>

</div>
</div>
<a id="afbe12093acc96f02e3f806a4c0003c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe12093acc96f02e3f806a4c0003c83">&#9670;&nbsp;</a></span>setHasSharers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setHasSharers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On fills, the hasSharers flag is used by the caches in combination with the cacheResponding flag, as clarified above. </p>
<p>If the hasSharers flag is not set, the packet is passing writable. Thus, a response from a memory passes the line as writable by default.</p>
<p>The hasSharers flag is also used by upstream caches to inform a downstream cache that they have the block (by calling setHasSharers on snoop request packets that hit in upstream cachs tags or MSHRs). If the snoop packet has sharers, a downstream cache is prevented from passing a dirty line upwards if it was not explicitly asked for a writable copy. See Cache::satisfyCpuSideRequest.</p>
<p>The hasSharers flag is also used on writebacks, in combination with the WritbackClean or WritebackDirty commands, to allocate the block downstream either as:</p>
<p>command hasSharers state WritebackDirty false Modified WritebackDirty true Owned WritebackClean false Exclusive WritebackClean true Shared </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00617">617</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01511">BaseCache::writebackBlk()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01559">BaseCache::writecleanBlk()</a>.</p>

</div>
</div>
<a id="a25668a7254542eab91f95ae46c2f1fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25668a7254542eab91f95ae46c2f1fea">&#9670;&nbsp;</a></span>setLE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setLE </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the value in the data pointer to v as little endian. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00109">109</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="byteswap_8hh_source.html#l00144">htole()</a>, and <a class="el" href="packet__access_8hh_source.html#l00062">setRaw()</a>.</p>

<p class="reference">Referenced by <a class="el" href="copy__engine_8cc_source.html#l00242">CopyEngine::CopyEngineChannel::channelRead()</a>, <a class="el" href="vio__mmio_8cc_source.html#l00064">MmioVirtIO::read()</a>, <a class="el" href="pci_8cc_source.html#l00068">PciVirtIO::read()</a>, <a class="el" href="gpu__nomali_8cc_source.html#l00149">NoMaliGpu::read()</a>, <a class="el" href="pl011_8cc_source.html#l00067">Pl011::read()</a>, <a class="el" href="amba__fake_8cc_source.html#l00056">AmbaFake::read()</a>, <a class="el" href="a9scu_8cc_source.html#l00054">A9SCU::read()</a>, <a class="el" href="speaker_8cc_source.html#l00041">X86ISA::Speaker::read()</a>, <a class="el" href="isa__fake_8cc_source.html#l00055">IsaFake::read()</a>, <a class="el" href="tsunami__pchip_8cc_source.html#l00072">TsunamiPChip::read()</a>, <a class="el" href="cmos_8cc_source.html#l00048">X86ISA::Cmos::read()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00074">TsunamiCChip::read()</a>, <a class="el" href="i8254_8cc_source.html#l00052">X86ISA::I8254::read()</a>, <a class="el" href="i82094aa_8cc_source.html#l00093">X86ISA::I82094AA::read()</a>, <a class="el" href="i8259_8cc_source.html#l00073">X86ISA::I8259::read()</a>, <a class="el" href="hdlcd_8cc_source.html#l00238">HDLcd::read()</a>, <a class="el" href="gic__v2m_8cc_source.html#l00107">Gicv2m::read()</a>, <a class="el" href="backdoor_8cc_source.html#l00103">AlphaBackdoor::read()</a>, <a class="el" href="rtc__pl031_8cc_source.html#l00061">PL031::read()</a>, <a class="el" href="timer__sp804_8cc_source.html#l00085">Sp804::Timer::read()</a>, <a class="el" href="tsunami__io_8cc_source.html#l00087">TsunamiIO::read()</a>, <a class="el" href="energy__ctrl_8cc_source.html#l00064">EnergyCtrl::read()</a>, <a class="el" href="timer__a9global_8cc_source.html#l00088">A9GlobalTimer::Timer::read()</a>, <a class="el" href="i8042_8cc_source.html#l00126">X86ISA::I8042::read()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00112">CpuLocalTimer::Timer::read()</a>, <a class="el" href="dispatcher_8cc_source.html#l00127">GpuDispatcher::read()</a>, <a class="el" href="rv__ctrl_8cc_source.html#l00056">RealViewCtrl::read()</a>, <a class="el" href="copy__engine_8cc_source.html#l00169">CopyEngine::read()</a>, <a class="el" href="sinic_8cc_source.html#l00212">Sinic::Device::read()</a>, <a class="el" href="generic__timer_8cc_source.html#l00569">GenericTimerMem::read()</a>, <a class="el" href="ns__gige_8cc_source.html#l00187">NSGigE::read()</a>, <a class="el" href="pl111_8cc_source.html#l00101">Pl111::read()</a>, <a class="el" href="i8254xGBe_8cc_source.html#l00170">IGbE::read()</a>, <a class="el" href="ufs__device_8cc_source.html#l00929">UFSHostDevice::read()</a>, <a class="el" href="ide__ctrl_8cc_source.html#l00177">IdeController::readConfig()</a>, <a class="el" href="dev_2pci_2device_8cc_source.html#l00220">PciDevice::readConfig()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00582">SMMUv3::readControl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00291">GicV2::readCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00144">VGic::readCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00140">GicV2::readDistributor()</a>, <a class="el" href="amba__device_8cc_source.html#l00074">AmbaDevice::readId()</a>, <a class="el" href="vgic_8cc_source.html#l00097">VGic::readVCpu()</a>, and <a class="el" href="pagetable__walker_8cc_source.html#l00282">X86ISA::Walker::WalkerState::stepWalk()</a>.</p>

</div>
</div>
<a id="adda4d98dcf9f9948996fa2e98f1ab1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda4d98dcf9f9948996fa2e98f1ab1c3">&#9670;&nbsp;</a></span>setRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setRaw </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the value in the data pointer to v without byte swapping. </p>

<p class="definition">Definition at line <a class="el" href="packet__access_8hh_source.html#l00062">62</a> of file <a class="el" href="packet__access_8hh_source.html">packet_access.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00337">data</a>, <a class="el" href="packet_8hh_source.html#l00305">DYNAMIC_DATA</a>, <a class="el" href="packet_8hh_source.html#l00316">flags</a>, <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, <a class="el" href="packet_8hh_source.html#l00347">size</a>, and <a class="el" href="packet_8hh_source.html#l00301">STATIC_DATA</a>.</p>

<p class="reference">Referenced by <a class="el" href="intdev_8hh_source.html#l00087">X86ISA::buildIntPacket()</a>, <a class="el" href="mm__disk_8cc_source.html#l00056">MmDisk::read()</a>, <a class="el" href="uart8250_8cc_source.html#l00096">Uart8250::read()</a>, <a class="el" href="bus_8cc_source.html#l00071">I2CBus::read()</a>, <a class="el" href="packet__access_8hh_source.html#l00102">setBE()</a>, and <a class="el" href="packet__access_8hh_source.html#l00109">setLE()</a>.</p>

</div>
</div>
<a id="a0d124a428a7bca01c40c679050aaef5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d124a428a7bca01c40c679050aaef5c">&#9670;&nbsp;</a></span>setResponderHadWritable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setResponderHadWritable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On responding to a snoop request (which only happens for Modified or Owned lines), make sure that we can transform an Owned response to a Modified one. </p>
<p>If this flag is not set, the responding cache had the line in the Owned state, and there are possibly other Shared copies in the memory system. A downstream cache helps in orchestrating the invalidation of these copies by sending out the appropriate express snoops. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00645">645</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, and <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>.</p>

</div>
</div>
<a id="adfa0fbd34b0d03fbee86a1df3c81c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa0fbd34b0d03fbee86a1df3c81c5c1">&#9670;&nbsp;</a></span>setSatisfied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setSatisfied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> when a request hits in a cache and the cache is not going to respond. </p>
<p>This is used by the crossbar to coordinate responses for cache maintenance operations. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00681">681</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00206">MemCmd::isClean()</a>, <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>.</p>

</div>
</div>
<a id="a754476a15d1fff71aa3c0884416368aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754476a15d1fff71aa3c0884416368aa">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00973">973</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>, and <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a id="aafe71cc940de59979daccabb38434546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe71cc940de59979daccabb38434546">&#9670;&nbsp;</a></span>setSuppressFuncError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setSuppressFuncError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00689">689</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="shader_8cc_source.html#l00229">Shader::doFunctionalAccess()</a>.</p>

</div>
</div>
<a id="ad1a07335955fc19b3aae759c0c1cbe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a07335955fc19b3aae759c0c1cbe20">&#9670;&nbsp;</a></span>setUintX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setUintX </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSet.html">Set</a> the value in the word w after truncating it to the length of the packet and then byteswapping it to the desired endianness. </p>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00354">354</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00736">getSize()</a>, and <a class="el" href="logging_8hh_source.html#l00167">panic</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple_8cc_source.html#l00055">SimpleUart::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="kmi_8cc_source.html#l00063">Pl050::read()</a>, and <a class="el" href="gic__v3__its_8cc_source.html#l00819">Gicv3Its::read()</a>.</p>

</div>
</div>
<a id="a836e225e423e0c4abf5811682b5a3cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836e225e423e0c4abf5811682b5a3cdb">&#9670;&nbsp;</a></span>setWriteThrough()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::setWriteThrough </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A writeback/writeclean cmd gets propagated further downstream by the receiver when the flag is set. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00667">667</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00205">MemCmd::isEviction()</a>, <a class="el" href="packet_8hh_source.html#l00198">MemCmd::isWrite()</a>, <a class="el" href="flags_8hh_source.html#l00070">Flags&lt; T &gt;::set()</a>, and <a class="el" href="packet_8hh_source.html#l00094">MemCmd::WriteClean</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01559">BaseCache::writecleanBlk()</a>.</p>

</div>
</div>
<a id="abe90926af9d31f320e5800b04cb76bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe90926af9d31f320e5800b04cb76bed">&#9670;&nbsp;</a></span>suppressFuncError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::suppressFuncError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00690">690</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RubyPort_8cc_source.html#l00361">RubyPort::MemSlavePort::recvFunctional()</a>.</p>

</div>
</div>
<a id="a18aaefcd9a94849f7b4956802e051046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aaefcd9a94849f7b4956802e051046">&#9670;&nbsp;</a></span>trySatisfyFunctional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::trySatisfyFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="packet_8hh.html#a470982fd720cbb1a92fc936965738abc">PacketPtr</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> a functional request against a memory value stored in another packet (i.e. </p>
<p>an in-transit request or response). Returns true if the current packet is a read, and the other packet provides the data, which is then copied to the current packet. If the current packet is a write, and the other packet intersects this one, then we update the data accordingly. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01264">1264</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00726">getAddr()</a>, <a class="el" href="packet_8hh_source.html#l01090">getPtr()</a>, <a class="el" href="packet_8hh_source.html#l00736">getSize()</a>, <a class="el" href="packet_8hh_source.html#l00548">hasData()</a>, <a class="el" href="packet_8hh_source.html#l01306">isMaskedWrite()</a>, <a class="el" href="packet_8hh_source.html#l00755">isSecure()</a>, and <a class="el" href="logging_8hh_source.html#l00212">warn</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l00623">BaseCache::functionalAccess()</a>, <a class="el" href="simple__mem_8cc_source.html#l00094">SimpleMemory::recvFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00382">SerialLink::SerialLinkSlavePort::recvFunctional()</a>, <a class="el" href="dramsim2_8cc_source.html#l00164">DRAMSim2::recvFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00350">Bridge::BridgeSlavePort::recvFunctional()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00069">WriteQueueEntry::TargetList::trySatisfyFunctional()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00128">WriteQueueEntry::trySatisfyFunctional()</a>, <a class="el" href="packet__queue_8cc_source.html#l00087">PacketQueue::trySatisfyFunctional()</a>, <a class="el" href="serial__link_8cc_source.html#l00406">SerialLink::SerialLinkMasterPort::trySatisfyFunctional()</a>, <a class="el" href="mshr_8cc_source.html#l00213">MSHR::TargetList::trySatisfyFunctional()</a>, <a class="el" href="bridge_8cc_source.html#l00374">Bridge::BridgeMasterPort::trySatisfyFunctional()</a>, and <a class="el" href="mshr_8cc_source.html#l00640">MSHR::trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="a99350ab3793239acca64a0ed4162b6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99350ab3793239acca64a0ed4162b6da">&#9670;&nbsp;</a></span>trySatisfyFunctional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::trySatisfyFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrintable.html">Printable</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_secure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> a functional request against a memory value represented by a base/size pair and an associated data array. </p>
<p>If the current packet is a read, it may be satisfied by the memory value. If the current packet is a write, it may update the memory value. </p>

<p class="definition">Definition at line <a class="el" href="packet_8cc_source.html#l00234">234</a> of file <a class="el" href="packet_8cc_source.html">packet.cc</a>.</p>

<p class="reference">References <a class="el" href="packet_8hh_source.html#l00344">_isSecure</a>, <a class="el" href="packet_8hh_source.html#l00341">addr</a>, <a class="el" href="packet_8hh_source.html#l00352">bytesValid</a>, <a class="el" href="packet_8hh_source.html#l00523">cmdString()</a>, <a class="el" href="packet_8hh_source.html#l00726">getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00736">getSize()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="packet_8hh_source.html#l00556">isPrint()</a>, <a class="el" href="packet_8hh_source.html#l00528">isRead()</a>, <a class="el" href="packet_8hh_source.html#l00529">isWrite()</a>, <a class="el" href="logging_8hh_source.html#l00167">panic</a>, <a class="el" href="cast_8hh_source.html#l00061">safe_cast()</a>, and <a class="el" href="packet_8hh_source.html#l00480">senderState</a>.</p>

</div>
</div>
<a id="ac508f4cb732d0f2f3c26d29fd1ad524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac508f4cb732d0f2f3c26d29fd1ad524f">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::writeData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from the packet to the memory at the provided pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to which data will be copied. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01187">1187</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="x86_2pagetable_8hh_source.html#l00142">X86ISA::base</a>, and <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>.</p>

<p class="reference">Referenced by <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00680">BaseCache::cmpAndSwap()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="x86_2mmapped__ipr_8hh_source.html#l00075">X86ISA::handleIprWrite()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00209">X86ISA::Interrupts::write()</a>, and <a class="el" href="dev_2virtio_2base_8cc_source.html#l00435">VirtIODeviceBase::writeConfigBlob()</a>.</p>

</div>
</div>
<a id="ae57a04ffe0cad417cf8892797a92428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57a04ffe0cad417cf8892797a92428c">&#9670;&nbsp;</a></span>writeDataToBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::writeDataToBlock </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>blk_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from the packet to the provided block pointer, which is aligned to the given block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blk_data</td><td>Pointer to block to which data will be copied. </td></tr>
    <tr><td class="paramname">blkSize</td><td><a class="el" href="structBlock.html">Block</a> size in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l01211">1211</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="Address_8cc_source.html#l00048">getOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00340">SimpleCache::accessFunctional()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="simple__cache_8cc_source.html#l00360">SimpleCache::insert()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>.</p>

</div>
</div>
<a id="a5bb2c132f904d455ffac6057faf5a584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb2c132f904d455ffac6057faf5a584">&#9670;&nbsp;</a></span>writeThrough()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::writeThrough </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00674">674</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">References <a class="el" href="flags_8hh_source.html#l00062">Flags&lt; T &gt;::isSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afe46fedc9eb3e8d05ad1412de86c090a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe46fedc9eb3e8d05ad1412de86c090a">&#9670;&nbsp;</a></span>_isSecure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::_isSecure</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the request targets the secure memory space. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00344">344</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="afc16b8e019de22818d4f14efe57dac96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc16b8e019de22818d4f14efe57dac96">&#9670;&nbsp;</a></span>_qosValue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Packet::_qosValue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00355">355</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

</div>
</div>
<a id="ae60308db1a818c0ed3c923fae7c6989e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60308db1a818c0ed3c923fae7c6989e">&#9670;&nbsp;</a></span>addr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> Packet::addr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The address of the request. </p>
<p>This address could be virtual or physical, depending on the system configuration. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00341">341</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="a9464a7a269e143840e6e39d6b7c10d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9464a7a269e143840e6e39d6b7c10d44">&#9670;&nbsp;</a></span>bytesValid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;bool&gt; Packet::bytesValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Track the bytes found that satisfy a functional read. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00352">352</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>.</p>

</div>
</div>
<a id="ade61bff6cd470a7ce6376f3c85bdd3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade61bff6cd470a7ce6376f3c85bdd3ae">&#9670;&nbsp;</a></span>cmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMemCmd.html">MemCmd</a> Packet::cmd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The command field of the packet. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00322">322</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="noncoherent__cache_8cc_source.html#l00083">NoncoherentCache::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00091">WriteQueueEntry::allocate()</a>, <a class="el" href="mshr_8cc_source.html#l00253">MSHR::allocate()</a>, <a class="el" href="mshr_8cc_source.html#l00326">MSHR::allocateTarget()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01107">BaseCache::allocateWriteBuffer()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00387">TimingSimpleCPU::buildSplitPacket()</a>, <a class="el" href="packet_8hh_source.html#l00724">copyError()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00193">Cache::doWritebacks()</a>, <a class="el" href="cache_8cc_source.html#l00235">Cache::doWritebacksAtomic()</a>, <a class="el" href="mshr_8cc_source.html#l00496">MSHR::extractServiceableTargets()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00921">CoherentXBar::forwardAtomic()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00174">NoncoherentCache::handleAtomicReqMiss()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="cache_8cc_source.html#l01316">Cache::isCachedAbove()</a>, <a class="el" href="bop_8cc_source.html#l00251">BOPPrefetcher::notifyFill()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00127">BasePrefetcher::observeAccess()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00203">BasePrefetcher::probeNotify()</a>, <a class="el" href="compute__unit_8cc_source.html#l00976">ComputeUnit::DataPort::processMemRespEvent()</a>, <a class="el" href="cache_8cc_source.html#l00304">Cache::promoteWholeLineWrites()</a>, <a class="el" href="intdev_8hh_source.html#l00075">X86ISA::IntSlavePort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="RubyPort_8cc_source.html#l00304">RubyPort::MemSlavePort::recvAtomic()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00880">CoherentXBar::recvAtomicSnoop()</a>, <a class="el" href="x86_2interrupts_8cc_source.html#l00304">X86ISA::Interrupts::recvMessage()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00320">NoncoherentCache::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01069">ComputeUnit::DTLBPort::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01315">ComputeUnit::ITLBPort::recvTimingResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01287">Minor::LSQ::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="mshr_8cc_source.html#l00139">replaceUpgrade()</a>, <a class="el" href="cache_8cc_source.html#l00081">Cache::satisfyRequest()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00897">BaseCache::satisfyRequest()</a>, <a class="el" href="cache_8cc_source.html#l01344">Cache::sendMSHRQueuePacket()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00282">X86ISA::Walker::WalkerState::stepWalk()</a>, and <a class="el" href="mshr_8cc_source.html#l00078">MSHR::TargetList::updateFlags()</a>.</p>

</div>
</div>
<a id="aff4816ce10747b969a88c4a7f9e9fb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4816ce10747b969a88c4a7f9e9fb4a">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="packet_8hh.html#ae85a9de970f801a77a1ad88ee2b39ea2">PacketDataPtr</a> Packet::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the data being transferred. </p>
<p>It can be different sizes at each level of the hierarchy so it belongs to the packet, not request. This may or may not be populated when a responder receives the packet. If not populated memory should be allocated. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00337">337</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet__access_8hh_source.html#l00053">getRaw()</a>, <a class="el" href="packet_8hh_source.html#l00840">Packet()</a>, and <a class="el" href="packet__access_8hh_source.html#l00062">setRaw()</a>.</p>

</div>
</div>
<a id="a1d59d7505cbc8790860b6200eb4c4a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d59d7505cbc8790860b6200eb4c4a73">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPacket.html#a5901a7043b7770017d3d2e85fa0fca36">Flags</a> Packet::flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00316">316</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet_8cc_source.html#l00309">copyResponderFlags()</a>, <a class="el" href="packet__access_8hh_source.html#l00053">getRaw()</a>, <a class="el" href="packet_8hh_source.html#l00840">Packet()</a>, and <a class="el" href="packet__access_8hh_source.html#l00062">setRaw()</a>.</p>

</div>
</div>
<a id="ae035c719eee7a7713ab831a11e9e7406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae035c719eee7a7713ab831a11e9e7406">&#9670;&nbsp;</a></span>headerDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::headerDelay</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The extra delay from seeing the packet until the header is transmitted. </p>
<p>This delay is used to communicate the crossbar forwarding latency to the neighbouring object (e.g. a cache) that actually makes the packet wait. As the delay is relative, a 32-bit unsigned should be sufficient. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00366">366</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="dramsim2_8cc_source.html#l00251">DRAMSim2::accessAndRespond()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00887">DRAMCtrl::accessAndRespond()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00215">SMMUv3SlaveInterface::atsMasterRecvTimingResp()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00190">SMMUv3SlaveInterface::atsSlaveRecvTimingReq()</a>, <a class="el" href="xbar_8cc_source.html#l00103">BaseXBar::calcPacketTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00214">BaseCache::handleTimingReqHit()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00393">BaseCache::handleUncacheableWriteResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00129">SMMUv3::masterRecvTimingResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00175">SMMUv3::masterTableWalkRecvTimingResp()</a>, <a class="el" href="external__slave_8cc_source.html#l00119">StubSlavePort::processResponseEvent()</a>, <a class="el" href="host_8cc_source.html#l00136">GenericPciHost::read()</a>, <a class="el" href="io__device_8hh_source.html#l00070">PioPort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="intdev_8hh_source.html#l00075">X86ISA::IntSlavePort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="smmu__v3__ports_8cc_source.html#l00118">SMMUControlPort::recvAtomic()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00601">X86ISA::Walker::WalkerState::recvPacket()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00140">SMMUv3SlaveInterface::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00284">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="bridge_8cc_source.html#l00146">Bridge::BridgeSlavePort::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00337">BaseCache::recvTimingReq()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01134">Gicv3Its::recvTimingResp()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00381">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::recvTimingResp()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="serial__link_8cc_source.html#l00132">SerialLink::SerialLinkMasterPort::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="bridge_8cc_source.html#l00124">Bridge::BridgeMasterPort::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00282">SMMUv3::runProcessTiming()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, and <a class="el" href="host_8cc_source.html#l00160">GenericPciHost::write()</a>.</p>

</div>
</div>
<a id="af720e740227e1083a16fc188cc7f22b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af720e740227e1083a16fc188cc7f22b4">&#9670;&nbsp;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="packet_8hh.html#ad38dfafec51e964d93d60cdec3bfb489">PacketId</a> Packet::id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00324">324</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>.</p>

</div>
</div>
<a id="a672f63108880c72376276d9ed01b3fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672f63108880c72376276d9ed01b3fc3">&#9670;&nbsp;</a></span>payloadDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::payloadDelay</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The extra pipelining delay from seeing the packet until the end of payload is transmitted by the component that provided it (if any). </p>
<p>This includes the header delay. Similar to the header delay, this is used to make up for the fact that the crossbar does not make the packet wait. As the delay is relative, a 32-bit unsigned should be sufficient. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00384">384</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="dramsim2_8cc_source.html#l00251">DRAMSim2::accessAndRespond()</a>, <a class="el" href="dram__ctrl_8cc_source.html#l00887">DRAMCtrl::accessAndRespond()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01107">BaseCache::allocateWriteBuffer()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00215">SMMUv3SlaveInterface::atsMasterRecvTimingResp()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00190">SMMUv3SlaveInterface::atsSlaveRecvTimingReq()</a>, <a class="el" href="xbar_8cc_source.html#l00103">BaseXBar::calcPacketTiming()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01299">BaseCache::handleFill()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00214">BaseCache::handleTimingReqHit()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00393">BaseCache::handleUncacheableWriteResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00129">SMMUv3::masterRecvTimingResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00175">SMMUv3::masterTableWalkRecvTimingResp()</a>, <a class="el" href="external__slave_8cc_source.html#l00119">StubSlavePort::processResponseEvent()</a>, <a class="el" href="host_8cc_source.html#l00136">GenericPciHost::read()</a>, <a class="el" href="io__device_8hh_source.html#l00070">PioPort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="intdev_8hh_source.html#l00075">X86ISA::IntSlavePort&lt; X86ISA::Interrupts &gt;::recvAtomic()</a>, <a class="el" href="smmu__v3__ports_8cc_source.html#l00118">SMMUControlPort::recvAtomic()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00246">NoncoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00729">CoherentXBar::recvAtomicBackdoor()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00880">CoherentXBar::recvAtomicSnoop()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00601">X86ISA::Walker::WalkerState::recvPacket()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="smmu__v3__slaveifc_8cc_source.html#l00140">SMMUv3SlaveInterface::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00284">sc_gem5::Gem5ToTlmBridge&lt; BITWIDTH &gt;::recvTimingReq()</a>, <a class="el" href="serial__link_8cc_source.html#l00165">SerialLink::SerialLinkSlavePort::recvTimingReq()</a>, <a class="el" href="simple__mem_8cc_source.html#l00112">SimpleMemory::recvTimingReq()</a>, <a class="el" href="bridge_8cc_source.html#l00146">Bridge::BridgeSlavePort::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00337">BaseCache::recvTimingReq()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l01134">Gicv3Its::recvTimingResp()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00381">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::recvTimingResp()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="serial__link_8cc_source.html#l00132">SerialLink::SerialLinkMasterPort::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="bridge_8cc_source.html#l00124">Bridge::BridgeMasterPort::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="smmu__v3_8cc_source.html#l00282">SMMUv3::runProcessTiming()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="host_8cc_source.html#l00160">GenericPciHost::write()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01511">BaseCache::writebackBlk()</a>, and <a class="el" href="mem_2cache_2base_8cc_source.html#l01559">BaseCache::writecleanBlk()</a>.</p>

</div>
</div>
<a id="ae348c208f0ffb3cf22f1f65a19c13c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae348c208f0ffb3cf22f1f65a19c13c4f">&#9670;&nbsp;</a></span>req</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="request_8hh.html#a7b4f6e20c8b9ccdc4518bb61c20fc81c">RequestPtr</a> Packet::req</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pointer to the original request. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00327">327</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache_8cc_source.html#l00164">Cache::access()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00348">AbstractMemory::access()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01023">BaseCache::access()</a>, <a class="el" href="simple__cache_8cc_source.html#l00282">SimpleCache::accessTiming()</a>, <a class="el" href="pipe__data_8cc_source.html#l00185">Minor::ForwardLineData::adoptPacketData()</a>, <a class="el" href="write__queue__entry_8cc_source.html#l00091">WriteQueueEntry::allocate()</a>, <a class="el" href="mshr_8cc_source.html#l00253">MSHR::allocate()</a>, <a class="el" href="mshr_8cc_source.html#l00326">MSHR::allocateTarget()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8hh_source.html#l00180">BaseTrafficGen::allocateWaitingRespSlot()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00097">TLBCoalescer::canCoalesce()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00763">Minor::LSQ::StoreBuffer::canForwardDataToLoad()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00258">AbstractMemory::checkLockedAddrList()</a>, <a class="el" href="cache__blk_8hh_source.html#l00395">CacheBlk::checkWrite()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00680">BaseCache::cmpAndSwap()</a>, <a class="el" href="dyn__inst__impl_8hh_source.html#l00165">BaseO3DynInst&lt; Impl &gt;::completeAcc()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00878">TimingSimpleCPU::completeDataAccess()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00774">TimingSimpleCPU::completeIfetch()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00997">GPUCoalescer::completeIssue()</a>, <a class="el" href="trace__cpu_8cc_source.html#l00739">TraceCPU::ElasticDataGen::completeMemAccess()</a>, <a class="el" href="GarnetSyntheticTraffic_8cc_source.html#l00129">GarnetSyntheticTraffic::completeRequest()</a>, <a class="el" href="memtest_8cc_source.html#l00135">MemTest::completeRequest()</a>, <a class="el" href="smmu__v3__transl_8cc_source.html#l01226">SMMUTranslationProcess::completeTransaction()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00150">NoncoherentCache::createMissPacket()</a>, <a class="el" href="cache_8cc_source.html#l00480">Cache::createMissPacket()</a>, <a class="el" href="queued_8cc_source.html#l00053">QueuedPrefetcher::DeferredPacket::createPkt()</a>, <a class="el" href="queued_8cc_source.html#l00341">QueuedPrefetcher::createPrefetchRequest()</a>, <a class="el" href="shader_8cc_source.html#l00229">Shader::doFunctionalAccess()</a>, <a class="el" href="sparc_2tlb_8cc_source.html#l00861">SparcISA::TLB::doMmuRegRead()</a>, <a class="el" href="sparc_2tlb_8cc_source.html#l01046">SparcISA::TLB::doMmuRegWrite()</a>, <a class="el" href="cpu_2base_8cc_source.html#l00741">AddressMonitor::doMonitor()</a>, <a class="el" href="cache_8cc_source.html#l00927">Cache::doTimingSupplyResponse()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00208">FetchUnit::fetch()</a>, <a class="el" href="smmu__v3__transl_8cc_source.html#l00049">SMMUTranslRequest::fromPacket()</a>, <a class="el" href="tlm__to__gem5_8cc_source.html#l00329">sc_gem5::TlmToGem5Bridge&lt; BITWIDTH &gt;::get_direct_mem_ptr()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00720">BaseCache::getNextQueueEntry()</a>, <a class="el" href="cache_8cc_source.html#l00566">Cache::handleAtomicReqMiss()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01410">X86ISA::GpuTLB::handleFuncTranslationReturn()</a>, <a class="el" href="Sequencer_8cc_source.html#l00190">Sequencer::handleLlsc()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00412">GPUCoalescer::handleLlsc()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00259">TimingSimpleCPU::handleReadPacket()</a>, <a class="el" href="dma__device_8cc_source.html#l00068">DmaPort::handleResp()</a>, <a class="el" href="simple__memobj_8cc_source.html#l00185">SimpleMemobj::handleResponse()</a>, <a class="el" href="cache_8cc_source.html#l00972">Cache::handleSnoop()</a>, <a class="el" href="mshr_8cc_source.html#l00371">MSHR::handleSnoop()</a>, <a class="el" href="cache_8cc_source.html#l00316">Cache::handleTimingReqHit()</a>, <a class="el" href="cache_8cc_source.html#l00327">Cache::handleTimingReqMiss()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00242">BaseCache::handleTimingReqMiss()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01159">X86ISA::GpuTLB::handleTranslationReturn()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00475">TimingSimpleCPU::handleWritePacket()</a>, <a class="el" href="RubyPort_8cc_source.html#l00500">RubyPort::MemSlavePort::hitCallback()</a>, <a class="el" href="Sequencer_8cc_source.html#l00439">Sequencer::hitCallback()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01223">BaseCache::incHitCount()</a>, <a class="el" href="mem_2cache_2base_8hh_source.html#l01212">BaseCache::incMissCount()</a>, <a class="el" href="queued_8cc_source.html#l00352">QueuedPrefetcher::insert()</a>, <a class="el" href="mem_2cache_2tags_2base_8cc_source.html#l00103">BaseTags::insertBlock()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00312">GPUCoalescer::insertRequest()</a>, <a class="el" href="coherent__xbar_8hh_source.html#l00415">CoherentXBar::isDestination()</a>, <a class="el" href="generic_2mmapped__ipr_8hh_source.html#l00103">GenericISA::isGenericIprAccess()</a>, <a class="el" href="Sequencer_8cc_source.html#l00620">Sequencer::issueRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00872">GPUCoalescer::issueRequest()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01033">X86ISA::GpuTLB::issueTLBLookup()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00066">SnoopFilter::lookupRequest()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00184">SnoopFilter::lookupSnoop()</a>, <a class="el" href="gic__v3__its_8cc_source.html#l00235">ItsTranslation::main()</a>, <a class="el" href="VIPERCoalescer_8cc_source.html#l00091">VIPERCoalescer::makeRequest()</a>, <a class="el" href="Sequencer_8cc_source.html#l00517">Sequencer::makeRequest()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00694">GPUCoalescer::makeRequest()</a>, <a class="el" href="cpu_2base_8cc_source.html#l00226">BaseCPU::mwait()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00127">BasePrefetcher::observeAccess()</a>, <a class="el" href="amba_8hh_source.html#l00051">AMBA::orderId()</a>, <a class="el" href="gem5__to__tlm_8cc_source.html#l00086">sc_gem5::packet2payload()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01125">X86ISA::GpuTLB::pagingProtectionChecks()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00059">BasePrefetcher::PrefetchInfo::PrefetchInfo()</a>, <a class="el" href="packet_8cc_source.html#l00376">print()</a>, <a class="el" href="mem_2cache_2prefetch_2base_8cc_source.html#l00203">BasePrefetcher::probeNotify()</a>, <a class="el" href="fetch__impl_8hh_source.html#l00389">DefaultFetch&lt; Impl &gt;::processCacheCompletion()</a>, <a class="el" href="fetch__stage_8cc_source.html#l00077">FetchStage::processFetchReturn()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00256">FetchUnit::processFetchReturn()</a>, <a class="el" href="compute__unit_8cc_source.html#l01254">ComputeUnit::DataPort::processMemReqEvent()</a>, <a class="el" href="compute__unit_8cc_source.html#l00976">ComputeUnit::DataPort::processMemRespEvent()</a>, <a class="el" href="mem__sink_8cc_source.html#l00199">QoS::MemSinkCtrl::processNextReqEvent()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00407">TLBCoalescer::processProbeTLBEvent()</a>, <a class="el" href="mshr_8cc_source.html#l00613">MSHR::promoteWritable()</a>, <a class="el" href="tsunami__cchip_8cc_source.html#l00074">TsunamiCChip::read()</a>, <a class="el" href="gic__v3_8cc_source.html#l00102">Gicv3::read()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00092">CpuLocalTimer::read()</a>, <a class="el" href="sinic_8cc_source.html#l00212">Sinic::Device::read()</a>, <a class="el" href="gic__v2_8cc_source.html#l00291">GicV2::readCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00144">VGic::readCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00140">GicV2::readDistributor()</a>, <a class="el" href="iob_8cc_source.html#l00121">Iob::readJBus()</a>, <a class="el" href="vgic_8cc_source.html#l00097">VGic::readVCpu()</a>, <a class="el" href="cache_8cc_source.html#l00658">Cache::recvAtomic()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00543">BaseCache::recvAtomic()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00335">TLBCoalescer::CpuSidePort::recvFunctional()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01480">X86ISA::GpuTLB::CpuSidePort::recvFunctional()</a>, <a class="el" href="fetch__impl_8hh_source.html#l01420">DefaultFetch&lt; Impl &gt;::recvReqRetry()</a>, <a class="el" href="compute__unit_8cc_source.html#l00685">ComputeUnit::DataPort::recvReqRetry()</a>, <a class="el" href="compute__unit_8cc_source.html#l00720">ComputeUnit::SQCPort::recvReqRetry()</a>, <a class="el" href="compute__unit_8cc_source.html#l01284">ComputeUnit::DTLBPort::recvReqRetry()</a>, <a class="el" href="compute__unit_8cc_source.html#l01368">ComputeUnit::ITLBPort::recvReqRetry()</a>, <a class="el" href="RubyPort_8cc_source.html#l00234">RubyPort::MemSlavePort::recvTimingReq()</a>, <a class="el" href="hmc__controller_8cc_source.html#l00042">HMCController::recvTimingReq()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00102">NoncoherentXBar::recvTimingReq()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00135">MemCheckerMonitor::recvTimingReq()</a>, <a class="el" href="mem__sink_8cc_source.html#l00120">QoS::MemSinkCtrl::recvTimingReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00464">BaseTrafficGen::recvTimingResp()</a>, <a class="el" href="fetch__impl_8hh_source.html#l01677">DefaultFetch&lt; Impl &gt;::IcachePort::recvTimingResp()</a>, <a class="el" href="dma__device_8cc_source.html#l00111">DmaPort::recvTimingResp()</a>, <a class="el" href="noncoherent__xbar_8cc_source.html#l00180">NoncoherentXBar::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01615">X86ISA::GpuTLB::MemSidePort::recvTimingResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00444">CoherentXBar::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l00621">ComputeUnit::DataPort::recvTimingResp()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l00405">BaseCache::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01069">ComputeUnit::DTLBPort::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01315">ComputeUnit::ITLBPort::recvTimingResp()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>, <a class="el" href="cache_8cc_source.html#l00270">Cache::recvTimingSnoopResp()</a>, <a class="el" href="coherent__xbar_8cc_source.html#l00566">CoherentXBar::recvTimingSnoopResp()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l00624">Minor::LSQ::SplitDataRequest::retireResponse()</a>, <a class="el" href="policy_8cc_source.html#l00051">QoS::Policy::schedule()</a>, <a class="el" href="mem__ctrl_8cc_source.html#l00228">QoS::MemCtrl::schedule()</a>, <a class="el" href="dma__device_8cc_source.html#l00249">DmaPort::sendDma()</a>, <a class="el" href="mem_2cache_2base_8cc_source.html#l01682">BaseCache::sendMSHRQueuePacket()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="compute__unit_8cc_source.html#l00923">ComputeUnit::sendSyncRequest()</a>, <a class="el" href="compute__unit_8cc_source.html#l01839">ComputeUnit::LDSPort::sendTimingReq()</a>, <a class="el" href="noncoherent__cache_8cc_source.html#l00245">NoncoherentCache::serviceMSHRTargets()</a>, <a class="el" href="cache_8cc_source.html#l00689">Cache::serviceMSHRTargets()</a>, <a class="el" href="pagetable__walker_8cc_source.html#l00282">X86ISA::Walker::WalkerState::stepWalk()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00227">AbstractMemory::trackLoadLocked()</a>, <a class="el" href="cache__blk_8hh_source.html#l00312">CacheBlk::trackLoadLocked()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01244">X86ISA::GpuTLB::translationReturn()</a>, <a class="el" href="minor_2lsq_8cc_source.html#l01164">Minor::LSQ::tryToSend()</a>, <a class="el" href="cpu_2testers_2traffic__gen_2base_8cc_source.html#l00170">BaseTrafficGen::update()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00142">TLBCoalescer::updatePhysAddresses()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00338">SnoopFilter::updateResponse()</a>, <a class="el" href="snoop__filter_8cc_source.html#l00244">SnoopFilter::updateSnoopResponse()</a>, <a class="el" href="mshr_8hh_source.html#l00231">MSHR::TargetList::updateWriteFlags()</a>, <a class="el" href="gic__v3_8cc_source.html#l00139">Gicv3::write()</a>, <a class="el" href="dispatcher_8cc_source.html#l00157">GpuDispatcher::write()</a>, <a class="el" href="timer__cpulocal_8cc_source.html#l00170">CpuLocalTimer::write()</a>, <a class="el" href="sinic_8cc_source.html#l00297">Sinic::Device::write()</a>, <a class="el" href="gic__v2_8cc_source.html#l00558">GicV2::writeCpu()</a>, <a class="el" href="vgic_8cc_source.html#l00287">VGic::writeCtrl()</a>, <a class="el" href="gic__v2_8cc_source.html#l00389">GicV2::writeDistributor()</a>, <a class="el" href="iob_8cc_source.html#l00237">Iob::writeJBus()</a>, <a class="el" href="abstract__mem_8hh_source.html#l00149">AbstractMemory::writeOK()</a>, and <a class="el" href="vgic_8cc_source.html#l00238">VGic::writeVCpu()</a>.</p>

</div>
</div>
<a id="ad1dd4fa4370e508806fe4a8253a0ad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dd4fa4370e508806fe4a8253a0ad12">&#9670;&nbsp;</a></span>senderState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPacket_1_1SenderState.html">SenderState</a>* Packet::senderState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This packet's sender state. </p>
<p>Devices should use dynamic_cast&lt;&gt; to cast to the state appropriate to the sender. The intent of this variable is to allow a device to attach extra information to a request. A response packet must return the sender state that was attached to the original request (even if a new packet is created). </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00480">480</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUCoalescer_8cc_source.html#l01052">GPUCoalescer::atomicCallback()</a>, <a class="el" href="lsq__impl_8hh_source.html#l01044">LSQ&lt; Impl &gt;::SplitDataRequest::buildPackets()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00387">TimingSimpleCPU::buildSplitPacket()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00097">TLBCoalescer::canCoalesce()</a>, <a class="el" href="cpu_2simple_2timing_8hh_source.html#l00101">TimingSimpleCPU::SplitFragmentSenderState::clearFromParent()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l00113">LSQUnit&lt; Impl &gt;::completeDataAccess()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00878">TimingSimpleCPU::completeDataAccess()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00317">LSQ&lt; Impl &gt;::completeDataAccess()</a>, <a class="el" href="lds__state_8cc_source.html#l00097">LdsState::countBankConflicts()</a>, <a class="el" href="dma__device_8cc_source.html#l00153">DmaPort::dmaAction()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00208">FetchUnit::fetch()</a>, <a class="el" href="abstract__mem_8cc_source.html#l00450">AbstractMemory::functionalAccess()</a>, <a class="el" href="shader_8cc_source.html#l00384">Shader::functionalTLBAccess()</a>, <a class="el" href="lds__state_8cc_source.html#l00186">LdsState::getDynInstr()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01410">X86ISA::GpuTLB::handleFuncTranslationReturn()</a>, <a class="el" href="dma__device_8cc_source.html#l00068">DmaPort::handleResp()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01159">X86ISA::GpuTLB::handleTranslationReturn()</a>, <a class="el" href="GPUCoalescer_8cc_source.html#l00594">GPUCoalescer::hitCallback()</a>, <a class="el" href="Check_8cc_source.html#l00167">Check::initiateAction()</a>, <a class="el" href="Check_8cc_source.html#l00227">Check::initiateCheck()</a>, <a class="el" href="Check_8cc_source.html#l00138">Check::initiateFlush()</a>, <a class="el" href="Check_8cc_source.html#l00082">Check::initiatePrefetch()</a>, <a class="el" href="cache_8cc_source.html#l01316">Cache::isCachedAbove()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01033">X86ISA::GpuTLB::issueTLBLookup()</a>, <a class="el" href="packet_8cc_source.html#l00327">popSenderState()</a>, <a class="el" href="lds__state_8cc_source.html#l00277">LdsState::process()</a>, <a class="el" href="fetch__stage_8cc_source.html#l00077">FetchStage::processFetchReturn()</a>, <a class="el" href="fetch__unit_8cc_source.html#l00256">FetchUnit::processFetchReturn()</a>, <a class="el" href="compute__unit_8cc_source.html#l01254">ComputeUnit::DataPort::processMemReqEvent()</a>, <a class="el" href="compute__unit_8cc_source.html#l00976">ComputeUnit::DataPort::processMemRespEvent()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00407">TLBCoalescer::processProbeTLBEvent()</a>, <a class="el" href="packet_8cc_source.html#l00319">pushSenderState()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00335">TLBCoalescer::CpuSidePort::recvFunctional()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01480">X86ISA::GpuTLB::CpuSidePort::recvFunctional()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l01004">TimingSimpleCPU::DcachePort::recvReqRetry()</a>, <a class="el" href="tlb__coalescer_8cc_source.html#l00230">TLBCoalescer::CpuSidePort::recvTimingReq()</a>, <a class="el" href="RubyTester_8cc_source.html#l00177">RubyTester::CpuPort::recvTimingResp()</a>, <a class="el" href="AbstractController_8cc_source.html#l00328">AbstractController::recvTimingResp()</a>, <a class="el" href="mem__checker__monitor_8cc_source.html#l00227">MemCheckerMonitor::recvTimingResp()</a>, <a class="el" href="addr__mapper_8cc_source.html#l00135">AddrMapper::recvTimingResp()</a>, <a class="el" href="comm__monitor_8cc_source.html#l00413">CommMonitor::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l00621">ComputeUnit::DataPort::recvTimingResp()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l00095">LSQUnit&lt; Impl &gt;::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01069">ComputeUnit::DTLBPort::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01315">ComputeUnit::ITLBPort::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l01817">ComputeUnit::LDSPort::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00986">LSQ&lt; Impl &gt;::SingleDataRequest::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00999">LSQ&lt; Impl &gt;::SplitDataRequest::recvTimingResp()</a>, <a class="el" href="lsq__impl_8hh_source.html#l00326">LSQ&lt; Impl &gt;::recvTimingResp()</a>, <a class="el" href="compute__unit_8cc_source.html#l00743">ComputeUnit::sendRequest()</a>, <a class="el" href="cpu_2simple_2timing_8cc_source.html#l00325">TimingSimpleCPU::sendSplitData()</a>, <a class="el" href="compute__unit_8cc_source.html#l00923">ComputeUnit::sendSyncRequest()</a>, <a class="el" href="compute__unit_8cc_source.html#l01839">ComputeUnit::LDSPort::sendTimingReq()</a>, <a class="el" href="compute__unit_8cc_source.html#l01797">ComputeUnit::sendToLds()</a>, <a class="el" href="gpu__tlb_8cc_source.html#l01244">X86ISA::GpuTLB::translationReturn()</a>, <a class="el" href="packet_8cc_source.html#l00234">trySatisfyFunctional()</a>, <a class="el" href="lsq__unit__impl_8hh_source.html#l01058">LSQUnit&lt; Impl &gt;::trySendPacket()</a>, and <a class="el" href="tlb__coalescer_8cc_source.html#l00142">TLBCoalescer::updatePhysAddresses()</a>.</p>

</div>
</div>
<a id="a2ec256dae61980f980ada9d6071c25ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec256dae61980f980ada9d6071c25ab">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Packet::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the request or transfer. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00347">347</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="packet__access_8hh_source.html#l00053">getRaw()</a>, and <a class="el" href="packet__access_8hh_source.html#l00062">setRaw()</a>.</p>

</div>
</div>
<a id="a5e4a9b04aa6384293ff44918805cdc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4a9b04aa6384293ff44918805cdc02">&#9670;&nbsp;</a></span>snoopDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::snoopDelay</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep track of the extra delay incurred by snooping upwards before sending a request down the memory system. </p>
<p>This is used by the coherent crossbar to account for the additional request delay. </p>

<p class="definition">Definition at line <a class="el" href="packet_8hh_source.html#l00374">374</a> of file <a class="el" href="packet_8hh_source.html">packet.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="coherent__xbar_8cc_source.html#l00147">CoherentXBar::recvTimingReq()</a>, <a class="el" href="cache_8cc_source.html#l01185">Cache::recvTimingSnoopReq()</a>, and <a class="el" href="coherent__xbar_8cc_source.html#l00506">CoherentXBar::recvTimingSnoopReq()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="packet_8hh_source.html">packet.hh</a></li>
<li>mem/<a class="el" href="packet_8cc_source.html">packet.cc</a></li>
<li>mem/<a class="el" href="packet__access_8hh_source.html">packet_access.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:19 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
