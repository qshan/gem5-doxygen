<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: StackDistCalc Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classStackDistCalc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StackDistCalc Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The stack distance calculator is a passive object that merely observes the addresses pass to it.  
 <a href="classStackDistCalc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structStackDistCalc_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structStackDistCalc_1_1Node.html" title="Node which takes form of Leaf, INode or Root. ">Node</a> which takes form of Leaf, INode or <a class="el" href="classRoot.html">Root</a>.  <a href="structStackDistCalc_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c6ac6b44a06e8512e72318b1c78e3b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a5c6ac6b44a06e8512e72318b1c78e3b3">StackDistCalc</a> (bool verify_stack=false)</td></tr>
<tr class="separator:a5c6ac6b44a06e8512e72318b1c78e3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa810a4f272c640650c0e8071516abc23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#aa810a4f272c640650c0e8071516abc23">~StackDistCalc</a> ()</td></tr>
<tr class="separator:aa810a4f272c640650c0e8071516abc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c5dede3675561fbfd1a1dae378fb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1pair.html">std::pair</a>&lt; uint64_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a03c5dede3675561fbfd1a1dae378fb38">calcStackDist</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> r_address, bool mark=false)</td></tr>
<tr class="memdesc:a03c5dede3675561fbfd1a1dae378fb38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classProcess.html">Process</a> the given address.  <a href="#a03c5dede3675561fbfd1a1dae378fb38">More...</a><br /></td></tr>
<tr class="separator:a03c5dede3675561fbfd1a1dae378fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9af6c58352152e370b1d8b5ed68d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1pair.html">std::pair</a>&lt; uint64_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a2d9af6c58352152e370b1d8b5ed68d55">calcStackDistAndUpdate</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> r_address, bool addNewNode=true)</td></tr>
<tr class="memdesc:a2d9af6c58352152e370b1d8b5ed68d55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classProcess.html">Process</a> the given address:  <a href="#a2d9af6c58352152e370b1d8b5ed68d55">More...</a><br /></td></tr>
<tr class="separator:a2d9af6c58352152e370b1d8b5ed68d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8485b34414e745d951c129ef618b1527"><td class="memItemLeft" align="right" valign="top">static constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a8485b34414e745d951c129ef618b1527">Infinity</a> = std::numeric_limits&lt;uint64_t&gt;::max()</td></tr>
<tr class="memdesc:a8485b34414e745d951c129ef618b1527"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient way of refering to infinity.  <a href="#a8485b34414e745d951c129ef618b1527">More...</a><br /></td></tr>
<tr class="separator:a8485b34414e745d951c129ef618b1527"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad47506e845597097a987767d8f55b5f4"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; uint64_t, <a class="el" href="structStackDistCalc_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ad47506e845597097a987767d8f55b5f4">IndexNodeMap</a></td></tr>
<tr class="separator:ad47506e845597097a987767d8f55b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08afb1163ab78f17b15f6e1dea7bc14"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ab08afb1163ab78f17b15f6e1dea7bc14">AddressIndexMap</a></td></tr>
<tr class="separator:ab08afb1163ab78f17b15f6e1dea7bc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d68ca622b155eee6f3d0e0baf4f7b12"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classStackDistCalc.html#ad47506e845597097a987767d8f55b5f4">IndexNodeMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a1d68ca622b155eee6f3d0e0baf4f7b12">TreeType</a></td></tr>
<tr class="separator:a1d68ca622b155eee6f3d0e0baf4f7b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a171b4d1c5c65d8e2ee6e444f6bb4af82"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a171b4d1c5c65d8e2ee6e444f6bb4af82">getSum</a> (<a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *node, bool from_left, uint64_t sum_from_below, uint64_t stack_dist, uint64_t level) const</td></tr>
<tr class="memdesc:a171b4d1c5c65d8e2ee6e444f6bb4af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets sum from the node upwards recursively till the root.  <a href="#a171b4d1c5c65d8e2ee6e444f6bb4af82">More...</a><br /></td></tr>
<tr class="separator:a171b4d1c5c65d8e2ee6e444f6bb4af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a280c36cb57858e9ed65e79925c8ab"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ac4a280c36cb57858e9ed65e79925c8ab">getSumsLeavesToRoot</a> (<a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *node) const</td></tr>
<tr class="memdesc:ac4a280c36cb57858e9ed65e79925c8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sum from the leaf node specified.  <a href="#ac4a280c36cb57858e9ed65e79925c8ab">More...</a><br /></td></tr>
<tr class="separator:ac4a280c36cb57858e9ed65e79925c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bf554cb07ad44b71ec929d4ea1ac02"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a04bf554cb07ad44b71ec929d4ea1ac02">updateSum</a> (<a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *node, bool from_left, uint64_t sum_from_below, uint64_t level, uint64_t stack_dist, bool discard_node)</td></tr>
<tr class="memdesc:a04bf554cb07ad44b71ec929d4ea1ac02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the nodes upwards recursively till the root.  <a href="#a04bf554cb07ad44b71ec929d4ea1ac02">More...</a><br /></td></tr>
<tr class="separator:a04bf554cb07ad44b71ec929d4ea1ac02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10d49737ef12d3a373e4a9fe2a19846"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ab10d49737ef12d3a373e4a9fe2a19846">updateSumsLeavesToRoot</a> (<a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *node, bool is_new_leaf)</td></tr>
<tr class="memdesc:ab10d49737ef12d3a373e4a9fe2a19846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the leaf nodes and nodes above.  <a href="#ab10d49737ef12d3a373e4a9fe2a19846">More...</a><br /></td></tr>
<tr class="separator:ab10d49737ef12d3a373e4a9fe2a19846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d090d753c1f657073fa8ea96286551f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a5d090d753c1f657073fa8ea96286551f">updateTree</a> ()</td></tr>
<tr class="memdesc:a5d090d753c1f657073fa8ea96286551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateTree is a tree balancing operation, which maintains the binary tree structure.  <a href="#a5d090d753c1f657073fa8ea96286551f">More...</a><br /></td></tr>
<tr class="separator:a5d090d753c1f657073fa8ea96286551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbda9da43106a4c51e5841268f98d472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#acbda9da43106a4c51e5841268f98d472">sanityCheckTree</a> (const <a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *node, uint64_t level=0) const</td></tr>
<tr class="memdesc:acbda9da43106a4c51e5841268f98d472"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used for verification purposes It recursively traverses upwards from the given node till the root to check if the ultimate parent node (root-node) points to null.  <a href="#acbda9da43106a4c51e5841268f98d472">More...</a><br /></td></tr>
<tr class="separator:acbda9da43106a4c51e5841268f98d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802de4da1bc36d12c0e2ce581e4bf4af"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a802de4da1bc36d12c0e2ce581e4bf4af">getIndex</a> () const</td></tr>
<tr class="memdesc:a802de4da1bc36d12c0e2ce581e4bf4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the counter for address accesses (unique and non-unique).  <a href="#a802de4da1bc36d12c0e2ce581e4bf4af">More...</a><br /></td></tr>
<tr class="separator:a802de4da1bc36d12c0e2ce581e4bf4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0623fbe98194ec550a89e8f18bf999c2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a0623fbe98194ec550a89e8f18bf999c2">getTreeDepth</a> () const</td></tr>
<tr class="memdesc:a0623fbe98194ec550a89e8f18bf999c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query depth of the tree (tree[0] represents leaf layer while tree[treeDepth] represents the root layer, all layers in between contain intermediate nodes)  <a href="#a0623fbe98194ec550a89e8f18bf999c2">More...</a><br /></td></tr>
<tr class="separator:a0623fbe98194ec550a89e8f18bf999c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d5940eef3621d67055750b181c9447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#aa1d5940eef3621d67055750b181c9447">printStack</a> (int n=5) const</td></tr>
<tr class="memdesc:aa1d5940eef3621d67055750b181c9447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the last n items on the stack.  <a href="#aa1d5940eef3621d67055750b181c9447">More...</a><br /></td></tr>
<tr class="separator:aa1d5940eef3621d67055750b181c9447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e89fd7a691ff769a1c4a7f38a2d66c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ac3e89fd7a691ff769a1c4a7f38a2d66c">verifyStackDist</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> r_address, bool update_stack=false)</td></tr>
<tr class="memdesc:ac3e89fd7a691ff769a1c4a7f38a2d66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alternative implementation of the stack-distance in a naive way.  <a href="#ac3e89fd7a691ff769a1c4a7f38a2d66c">More...</a><br /></td></tr>
<tr class="separator:ac3e89fd7a691ff769a1c4a7f38a2d66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6514a8a601ac96f9c490b627ed52c291"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a6514a8a601ac96f9c490b627ed52c291">index</a></td></tr>
<tr class="memdesc:a6514a8a601ac96f9c490b627ed52c291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal counter for address accesses (unique and non-unique) This counter increments everytime the <a class="el" href="classStackDistCalc.html#a03c5dede3675561fbfd1a1dae378fb38" title="Process the given address. ">calcStackDist()</a> method is called.  <a href="#a6514a8a601ac96f9c490b627ed52c291">More...</a><br /></td></tr>
<tr class="separator:a6514a8a601ac96f9c490b627ed52c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7409da890a7e9a6c72d86653dbd9d3d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStackDistCalc.html#a1d68ca622b155eee6f3d0e0baf4f7b12">TreeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a7409da890a7e9a6c72d86653dbd9d3d9">tree</a></td></tr>
<tr class="separator:a7409da890a7e9a6c72d86653dbd9d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bad1b6fa6d07601f6ab8d4600f8173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStackDistCalc.html#ab08afb1163ab78f17b15f6e1dea7bc14">AddressIndexMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ac2bad1b6fa6d07601f6ab8d4600f8173">aiMap</a></td></tr>
<tr class="separator:ac2bad1b6fa6d07601f6ab8d4600f8173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6170f2f3a46478104849e251310089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#abf6170f2f3a46478104849e251310089">nextIndex</a></td></tr>
<tr class="separator:abf6170f2f3a46478104849e251310089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae960c13d489191524dcc0cff6ea65f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#ae960c13d489191524dcc0cff6ea65f82">stack</a></td></tr>
<tr class="separator:ae960c13d489191524dcc0cff6ea65f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5130ae770f280bfea13b5cebaaf5d388"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackDistCalc.html#a5130ae770f280bfea13b5cebaaf5d388">verifyStack</a></td></tr>
<tr class="separator:a5130ae770f280bfea13b5cebaaf5d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The stack distance calculator is a passive object that merely observes the addresses pass to it. </p>
<p>It calculates stack distances of incoming addresses based on the partial sum hierarchy tree algorithm described by Alamasi et al. <a href="http://doi.acm.org/10.1145/773039.773043">http://doi.acm.org/10.1145/773039.773043</a>.</p>
<p>A tree structure is maintained and updated at each transaction (unique or non-unique). The tree is implemented as an STL vector with layers of the form &lt;map&gt; Each layer in this tree is an ordered map &lt;uint64_t, Node*&gt;. Nodes are structs which take form of leaf, intermediate and root nodes. For example, in a tree with 3 layers, tree[0][5] gives a leaf node pointer for key=5 tree[1][1] gives an intermediate node pointer for key=1 tree[2][0] gives the root node in the tree.</p>
<p>At every transaction a hash-map (aiMap) is looked up to check if the address was already encountered before. Based on this lookup a transaction can be termed as unique or non-unique.</p>
<p>In addition to the normal stack distance calculation, a feature to mark an old node in the tree is added. This is useful if it is required to see the reuse pattern. For example, BackInvalidates from a lower level (e.g. membus to L2), can be marked (isMarked flag of <a class="el" href="structStackDistCalc_1_1Node.html" title="Node which takes form of Leaf, INode or Root. ">Node</a> set to True). Then later if this same address is accessed (by L1), the value of the isMarked flag would be True. This would give some insight on how the BackInvalidates policy of the lower level affect the read/write accesses in an application.</p>
<p>There are two functions provided to interface with the calculator:</p><ol type="1">
<li>pair&lt;uint64_t, bool&gt; calcStackDistAndUpdate(Addr r_address, bool addNewNode) At every unique transaction a new leaf node is added at tree[0](leaf layer) and linked to the layer above (if addNewNode is True). The sums of all the intermediate nodes is updated till the root. The stack-distance is returned as a Constant representing INFINITY.</li>
</ol>
<p>At every non-unique transaction the tree is traversed from the leaf at the returned index to the root, the old node is deleted from the tree, and the sums (to the right are collected) and decremented. The collected sum represets the stack distance of the found node. If this node was marked then a bool flag set to True is returned with the stack_distance. During this operation a node is discarded at the leaf layer always. Moreover during the traversal upwards using the <a class="el" href="classStackDistCalc.html#a04bf554cb07ad44b71ec929d4ea1ac02" title="Updates the nodes upwards recursively till the root. ">updateSum()</a> method, if an intermediate node is found with no children connected to it, then that is discarded too.</p>
<p>The return value of this function is a pair representing the stack_distance and the value of the marked flag.</p>
<ol type="1">
<li>pair&lt;uint64_t , bool&gt; <a class="el" href="classStackDistCalc.html#a03c5dede3675561fbfd1a1dae378fb38" title="Process the given address. ">calcStackDist(Addr r_address, bool mark)</a> This is a stripped down version of the above function which is used to just inspect the tree, and mark a leaf node (if mark flag is set). The functionality to add a new node is removed.</li>
</ol>
<p>At every unique transaction the stack-distance is returned as a constant representing INFINITY.</p>
<p>At every non-unique transaction the tree is traversed from the leaf at the returned index to the root, and the sums (to the right) are collected. The collected sum represets the stack distance of the found node.</p>
<p>This function does NOT Modify the stack. (No node is added or deleted). It is just used to mark a node already created and get its stack distance.</p>
<p>The return value of this function is a pair representing the stack distance and the value of the marked flag.</p>
<p>The table below depicts the usage of the Algorithm using the functions: pair&lt;uint64_t Stack_dist, bool isMarked&gt; calcStackDistAndUpdate (Addr r_address, bool addNewNode) pair&lt;uint64_t Stack_dist, bool isMarked&gt; calcStackDist (Addr r_address, bool mark)</p>
<p>| Function | <a class="el" href="classArguments.html">Arguments</a> |Return Val |Use For| |calcStackDistAndUpdate|r_address, True|I/SD,False |A,GD,GM| |calcStackDistAndUpdate|r_address,False|SD,prevMark|D,GD,GM| |calcStackDist |r_address,False|SD,prevMark| GD,GM| |calcStackDist |r_address, True|SD,prevMark| GD,GM|</p>
<p>(*A: Allocate an address in stack, if old entry present then it is deleted, *U: Delete old-address from stack, no new entry is added *GD: Get-Stack distance of an address, *GM: Get value of Mark flag, indicates if that address has been touched before, *I: stack-distance = infinity, *SD: Stack Distance *r_address: address to be added, *prevMark: value of isMarked flag of the <a class="el" href="structStackDistCalc_1_1Node.html" title="Node which takes form of Leaf, INode or Root. ">Node</a>)</p>
<p>Invalidates refer to a type of packet that removes something from a cache, either autonoumously (due-to cache's own replacement policy), or snoops from other caches which invalidate something inside our cache.</p>
<p>Usage | Function to use |Typical Use | Add new entry |calcStackDistAndUpdate|Read/Write Allocate | Delete Old Entry |calcStackDistAndUpdate|Writebacks/Cleanevicts| Dist.of Old entry|calcStackDist |Cleanevicts/Invalidate|</p>
<p><a class="el" href="structStackDistCalc_1_1Node.html" title="Node which takes form of Leaf, INode or Root. ">Node</a> Balancing: The tree structure is maintained by an <a class="el" href="classStackDistCalc.html#a5d090d753c1f657073fa8ea96286551f" title="updateTree is a tree balancing operation, which maintains the binary tree structure. ">updateTree()</a> operation called when an intermediate node is required. The update operation is roughly categorized as a root update or intermediate layer update. When number of leaf nodes grow over a power of 2 then a new layer is added at the top of the tree and a new root node is initialized. The old node at the lower layer is connected to this. In an intermediate node update operation a new intermediate node is added to the required layer.</p>
<p>Debugging: Debugging can be enabled by setting the verifyStack flag true. Debugging is implemented using a dummy stack that behaves in a naive way, using STL vectors (i.e each unique address is pushed on the top of an STL vector stack, and SD is returned as Infinity. If a non unique address is encountered then the previous entry in the STL vector is removed, all the entities above it are pushed down, and the address is pushed at the top of the stack).</p>
<p>A printStack(int numOfEntitiesToPrint) is provided to print top n entities in both (tree and STL based dummy stack). </p>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00174">174</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab08afb1163ab78f17b15f6e1dea7bc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08afb1163ab78f17b15f6e1dea7bc14">&#9670;&nbsp;</a></span>AddressIndexMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>, uint64_t&gt; <a class="el" href="classStackDistCalc.html#ab08afb1163ab78f17b15f6e1dea7bc14">StackDistCalc::AddressIndexMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00182">182</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

</div>
</div>
<a id="ad47506e845597097a987767d8f55b5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47506e845597097a987767d8f55b5f4">&#9670;&nbsp;</a></span>IndexNodeMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;uint64_t, <a class="el" href="structStackDistCalc_1_1Node.html">Node</a>*&gt; <a class="el" href="classStackDistCalc.html#ad47506e845597097a987767d8f55b5f4">StackDistCalc::IndexNodeMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00179">179</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

</div>
</div>
<a id="a1d68ca622b155eee6f3d0e0baf4f7b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d68ca622b155eee6f3d0e0baf4f7b12">&#9670;&nbsp;</a></span>TreeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classStackDistCalc.html#ad47506e845597097a987767d8f55b5f4">IndexNodeMap</a>&gt; <a class="el" href="classStackDistCalc.html#a1d68ca622b155eee6f3d0e0baf4f7b12">StackDistCalc::TreeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00183">183</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5c6ac6b44a06e8512e72318b1c78e3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6ac6b44a06e8512e72318b1c78e3b3">&#9670;&nbsp;</a></span>StackDistCalc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StackDistCalc::StackDistCalc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify_stack</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00047">47</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00407">nextIndex</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00365">StackDistCalc::Node::nodeIndex</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>.</p>

</div>
</div>
<a id="aa810a4f272c640650c0e8071516abc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa810a4f272c640650c0e8071516abc23">&#9670;&nbsp;</a></span>~StackDistCalc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StackDistCalc::~StackDistCalc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00074">74</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00403">aiMap</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00407">nextIndex</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00410">stack</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a03c5dede3675561fbfd1a1dae378fb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c5dede3675561fbfd1a1dae378fb38">&#9670;&nbsp;</a></span>calcStackDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1pair.html">std::pair</a>&lt; uint64_t, bool &gt; StackDistCalc::calcStackDist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>r_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mark</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classProcess.html">Process</a> the given address. </p>
<p>If Mark is true then set the mark flag of the leaf node. This function returns the stack distance of the incoming address and the previous status of the mark flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_address</td><td>The current address to process </td></tr>
    <tr><td class="paramname">mark</td><td>set the mark flag for the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address and the mark flag. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00461">461</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00403">aiMap</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00236">getSumsLeavesToRoot()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00315">Infinity</a>, <a class="el" href="logging_8hh_source.html#l00185">panic_if</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00413">verifyStack</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00534">verifyStackDist()</a>.</p>

</div>
</div>
<a id="a2d9af6c58352152e370b1d8b5ed68d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9af6c58352152e370b1d8b5ed68d55">&#9670;&nbsp;</a></span>calcStackDistAndUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1pair.html">std::pair</a>&lt; uint64_t, bool &gt; StackDistCalc::calcStackDistAndUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>r_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNewNode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classProcess.html">Process</a> the given address: </p>
<ul>
<li>Lookup the tree for the given address</li>
<li>delete old node if found in tree</li>
<li>add a new node (if addNewNode flag is set) This function returns the stack distance of the incoming address and the status of the mark flag.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_address</td><td>The current address to process </td></tr>
    <tr><td class="paramname">addNewNode</td><td>If true, a new node is added to the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address and the mark flag. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00359">359</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00403">aiMap</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00397">index</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00315">Infinity</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00371">StackDistCalc::Node::isLeftNode</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00377">StackDistCalc::Node::isMarked</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00407">nextIndex</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00365">StackDistCalc::Node::nodeIndex</a>, <a class="el" href="logging_8hh_source.html#l00185">panic_if</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00514">sanityCheckTree()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00188">updateSumsLeavesToRoot()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00250">updateTree()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00413">verifyStack</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00534">verifyStackDist()</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist_8cc_source.html#l00099">StackDistProbe::handleRequest()</a>.</p>

</div>
</div>
<a id="a802de4da1bc36d12c0e2ce581e4bf4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802de4da1bc36d12c0e2ce581e4bf4af">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::getIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the counter for address accesses (unique and non-unique). </p>
<p>This is further used to dump stats at regular intervals.</p>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00273">273</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00397">index</a>.</p>

</div>
</div>
<a id="a171b4d1c5c65d8e2ee6e444f6bb4af82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171b4d1c5c65d8e2ee6e444f6bb4af82">&#9670;&nbsp;</a></span>getSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::getSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sum_from_below</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stack_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets sum from the node upwards recursively till the root. </p>
<p>This function is called first by getSumsLeavesToRoot, and then recursively calls itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node which is updated </td></tr>
    <tr><td class="paramname">from_left</td><td>variable which says that the request arrived from the left </td></tr>
    <tr><td class="paramname">sum_from_below</td><td>Sum of left and right children below </td></tr>
    <tr><td class="paramname">level</td><td>level in the tree the calling node is located </td></tr>
    <tr><td class="paramname">stack_dist</td><td>stack distance of the node below </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00213">213</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00371">StackDistCalc::Node::isLeftNode</a>, <a class="el" href="intmessage_8hh_source.html#l00049">X86ISA::level</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00353">StackDistCalc::Node::sumLeft</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00356">StackDistCalc::Node::sumRight</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00236">getSumsLeavesToRoot()</a>.</p>

</div>
</div>
<a id="ac4a280c36cb57858e9ed65e79925c8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a280c36cb57858e9ed65e79925c8ab">&#9670;&nbsp;</a></span>getSumsLeavesToRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::getSumsLeavesToRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sum from the leaf node specified. </p>
<p>This function is called by calcStackDist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node which is updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00236">236</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8cc_source.html#l00213">getSum()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00371">StackDistCalc::Node::isLeftNode</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>.</p>

</div>
</div>
<a id="a0623fbe98194ec550a89e8f18bf999c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0623fbe98194ec550a89e8f18bf999c2">&#9670;&nbsp;</a></span>getTreeDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::getTreeDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query depth of the tree (tree[0] represents leaf layer while tree[treeDepth] represents the root layer, all layers in between contain intermediate nodes) </p>
<dl class="section return"><dt>Returns</dt><dd>Tree depth </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00282">282</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00429">ArmISA::n</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00047">StackDistCalc()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00534">verifyStackDist()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00074">~StackDistCalc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00514">sanityCheckTree()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00250">updateTree()</a>.</p>

</div>
</div>
<a id="aa1d5940eef3621d67055750b181c9447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d5940eef3621d67055750b181c9447">&#9670;&nbsp;</a></span>printStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StackDistCalc::printStack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>5</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the last n items on the stack. </p>
<p>This method prints top n entries in the tree based implementation as well as dummy stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of entries to print </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00565">565</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00065">ArmISA::a</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00403">aiMap</a>, <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00705">X86ISA::count</a>, <a class="el" href="base_2trace_8hh_source.html#l00215">DPRINTF</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00429">ArmISA::n</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00365">StackDistCalc::Node::nodeIndex</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00410">stack</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00413">verifyStack</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>.</p>

</div>
</div>
<a id="acbda9da43106a4c51e5841268f98d472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbda9da43106a4c51e5841268f98d472">&#9670;&nbsp;</a></span>sanityCheckTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StackDistCalc::sanityCheckTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used for verification purposes It recursively traverses upwards from the given node till the root to check if the ultimate parent node (root-node) points to null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node whose sanity is being checked </td></tr>
    <tr><td class="paramname">level</td><td>the level at which this node is located in the tree </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00514">514</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="intmessage_8hh_source.html#l00049">X86ISA::level</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00365">StackDistCalc::Node::nodeIndex</a>, <a class="el" href="logging_8hh_source.html#l00185">panic_if</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>.</p>

</div>
</div>
<a id="a04bf554cb07ad44b71ec929d4ea1ac02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bf554cb07ad44b71ec929d4ea1ac02">&#9670;&nbsp;</a></span>updateSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::updateSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sum_from_below</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stack_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discard_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the nodes upwards recursively till the root. </p>
<p>This function is first called by updateSumsLeavesToRoot, and then it recursively calls itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node which is updated </td></tr>
    <tr><td class="paramname">from_left</td><td>variable which says that the request arrived from the left </td></tr>
    <tr><td class="paramname">sum_from_below</td><td>Sum of left and right children below </td></tr>
    <tr><td class="paramname">level</td><td>level in the tree the calling node is located </td></tr>
    <tr><td class="paramname">stack_dist</td><td>stack distance of the node below </td></tr>
    <tr><td class="paramname">discard_node</td><td>whether the calling node was discarded or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00099">99</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00359">StackDistCalc::Node::discardLeft</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00362">StackDistCalc::Node::discardRight</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00371">StackDistCalc::Node::isLeftNode</a>, <a class="el" href="intmessage_8hh_source.html#l00049">X86ISA::level</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00365">StackDistCalc::Node::nodeIndex</a>, <a class="el" href="logging_8hh_source.html#l00185">panic_if</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00353">StackDistCalc::Node::sumLeft</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00356">StackDistCalc::Node::sumRight</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00413">verifyStack</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00188">updateSumsLeavesToRoot()</a>.</p>

</div>
</div>
<a id="ab10d49737ef12d3a373e4a9fe2a19846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10d49737ef12d3a373e4a9fe2a19846">&#9670;&nbsp;</a></span>updateSumsLeavesToRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::updateSumsLeavesToRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStackDistCalc_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_new_leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the leaf nodes and nodes above. </p>
<p>This function is called by the calcStackDistAndUpdate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node which is updated </td></tr>
    <tr><td class="paramname">is_new_leaf</td><td>is true if this is a newly added node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack distance of the current address. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00188">188</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00315">Infinity</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00371">StackDistCalc::Node::isLeftNode</a>, <a class="el" href="intmessage_8hh_source.html#l00049">X86ISA::level</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00353">StackDistCalc::Node::sumLeft</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00099">updateSum()</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>.</p>

</div>
</div>
<a id="a5d090d753c1f657073fa8ea96286551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d090d753c1f657073fa8ea96286551f">&#9670;&nbsp;</a></span>updateTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StackDistCalc::updateTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updateTree is a tree balancing operation, which maintains the binary tree structure. </p>
<p>This method is called whenever index%2 == 0 (i.e. every alternate cycle) The two main operation are : OP1. Moving the root node one layer up if index counter crosses power of 2 OP2. Addition of intermediate nodes as and when required and linking them to their parents in the layer above. </p>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00250">250</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="stack__dist__calc_8hh_source.html#l00359">StackDistCalc::Node::discardLeft</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>, <a class="el" href="miscregs__types_8hh_source.html#l00066">ArmISA::i</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00397">index</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00371">StackDistCalc::Node::isLeftNode</a>, <a class="el" href="intmath_8hh_source.html#l00146">isPowerOf2()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00407">nextIndex</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00365">StackDistCalc::Node::nodeIndex</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00368">StackDistCalc::Node::parent</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00353">StackDistCalc::Node::sumLeft</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00400">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>.</p>

</div>
</div>
<a id="ac3e89fd7a691ff769a1c4a7f38a2d66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e89fd7a691ff769a1c4a7f38a2d66c">&#9670;&nbsp;</a></span>verifyStackDist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::verifyStackDist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&#160;</td>
          <td class="paramname"><em>r_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_stack</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an alternative implementation of the stack-distance in a naive way. </p>
<p>It uses simple STL vector to represent the stack. It can be used in parallel for debugging purposes. It is 10x slower than the tree based implemenation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_address</td><td>The current address to process </td></tr>
    <tr><td class="paramname">update_stack</td><td>Flag to indicate if stack should be updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stack distance which is calculated by this alternative implementation </dd></dl>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8cc_source.html#l00534">534</a> of file <a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a>.</p>

<p class="reference">References <a class="el" href="miscregs__types_8hh_source.html#l00065">ArmISA::a</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00315">Infinity</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00410">stack</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, and <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac2bad1b6fa6d07601f6ab8d4600f8173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bad1b6fa6d07601f6ab8d4600f8173">&#9670;&nbsp;</a></span>aiMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStackDistCalc.html#ab08afb1163ab78f17b15f6e1dea7bc14">AddressIndexMap</a> StackDistCalc::aiMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00403">403</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00074">~StackDistCalc()</a>.</p>

</div>
</div>
<a id="a6514a8a601ac96f9c490b627ed52c291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6514a8a601ac96f9c490b627ed52c291">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t StackDistCalc::index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal counter for address accesses (unique and non-unique) This counter increments everytime the <a class="el" href="classStackDistCalc.html#a03c5dede3675561fbfd1a1dae378fb38" title="Process the given address. ">calcStackDist()</a> method is called. </p>
<p>This counter is used as a key for the hash- map at the leaf layer. Practically at every call to the calculator this counter is incremented and a new leaf node is added in the tree at the leaf layer using this counter value as the key. </p>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00397">397</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00273">getIndex()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00250">updateTree()</a>.</p>

</div>
</div>
<a id="a8485b34414e745d951c129ef618b1527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8485b34414e745d951c129ef618b1527">&#9670;&nbsp;</a></span>Infinity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t StackDistCalc::Infinity = std::numeric_limits&lt;uint64_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenient way of refering to infinity. </p>

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00315">315</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, <a class="el" href="stack__dist_8cc_source.html#l00099">StackDistProbe::handleRequest()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00188">updateSumsLeavesToRoot()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00534">verifyStackDist()</a>.</p>

</div>
</div>
<a id="abf6170f2f3a46478104849e251310089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6170f2f3a46478104849e251310089">&#9670;&nbsp;</a></span>nextIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;uint64_t&gt; StackDistCalc::nextIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00407">407</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00047">StackDistCalc()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00250">updateTree()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00074">~StackDistCalc()</a>.</p>

</div>
</div>
<a id="ae960c13d489191524dcc0cff6ea65f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae960c13d489191524dcc0cff6ea65f82">&#9670;&nbsp;</a></span>stack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;uint64_t&gt; StackDistCalc::stack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00410">410</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00534">verifyStackDist()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00074">~StackDistCalc()</a>.</p>

</div>
</div>
<a id="a7409da890a7e9a6c72d86653dbd9d3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7409da890a7e9a6c72d86653dbd9d3d9">&#9670;&nbsp;</a></span>tree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStackDistCalc.html#a1d68ca622b155eee6f3d0e0baf4f7b12">TreeType</a> StackDistCalc::tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00400">400</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, <a class="el" href="stack__dist__calc_8hh_source.html#l00282">getTreeDepth()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00047">StackDistCalc()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00099">updateSum()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00250">updateTree()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00074">~StackDistCalc()</a>.</p>

</div>
</div>
<a id="a5130ae770f280bfea13b5cebaaf5d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5130ae770f280bfea13b5cebaaf5d388">&#9670;&nbsp;</a></span>verifyStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool StackDistCalc::verifyStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stack__dist__calc_8hh_source.html#l00413">413</a> of file <a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="stack__dist__calc_8cc_source.html#l00461">calcStackDist()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00359">calcStackDistAndUpdate()</a>, <a class="el" href="stack__dist__calc_8cc_source.html#l00565">printStack()</a>, and <a class="el" href="stack__dist__calc_8cc_source.html#l00099">updateSum()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="stack__dist__calc_8hh_source.html">stack_dist_calc.hh</a></li>
<li>mem/<a class="el" href="stack__dist__calc_8cc_source.html">stack_dist_calc.cc</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:21 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
