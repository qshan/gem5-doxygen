<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gem5: BaseXBar::Layer&lt; SrcType, DstType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gem5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classBaseXBar.html">BaseXBar</a></li><li class="navelem"><a class="el" href="classBaseXBar_1_1Layer.html">Layer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBaseXBar_1_1Layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BaseXBar::Layer&lt; SrcType, DstType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A layer is an internal crossbar arbitration point with its own flow control.  
 <a href="classBaseXBar_1_1Layer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="xbar_8hh_source.html">xbar.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BaseXBar::Layer&lt; SrcType, DstType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBaseXBar_1_1Layer.png" usemap="#BaseXBar::Layer_3C_20SrcType_2C_20DstType_20_3E_map" alt=""/>
  <map id="BaseXBar::Layer_3C_20SrcType_2C_20DstType_20_3E_map" name="BaseXBar::Layer_3C_20SrcType_2C_20DstType_20_3E_map">
<area href="classDrainable.html" title="Interface for objects that might require draining before checkpointing. " alt="Drainable" shape="rect" coords="0,0,235,24"/>
<area href="classStats_1_1Group.html" title="Statistics container. " alt="Stats::Group" shape="rect" coords="245,0,480,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a428be70018298eaa415485040d397f11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a428be70018298eaa415485040d397f11">Layer</a> (DstType &amp;_port, <a class="el" href="classBaseXBar.html">BaseXBar</a> &amp;_xbar, const std::string &amp;<a class="el" href="classBaseXBar_1_1Layer.html#a9a8b8f3c32cb2bfe3c4cd109a021382b">_name</a>)</td></tr>
<tr class="memdesc:a428be70018298eaa415485040d397f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a layer and give it a name.  <a href="#a428be70018298eaa415485040d397f11">More...</a><br /></td></tr>
<tr class="separator:a428be70018298eaa415485040d397f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09b7ce0958137a3c59071cd2a181495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="drain_8hh.html#ac9ed0d5c83a29cf8938316f174264043">DrainState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aa09b7ce0958137a3c59071cd2a181495">drain</a> () override</td></tr>
<tr class="memdesc:aa09b7ce0958137a3c59071cd2a181495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drain according to the normal semantics, so that the crossbar can tell the layer to drain, and pass an event to signal back when drained.  <a href="#aa09b7ce0958137a3c59071cd2a181495">More...</a><br /></td></tr>
<tr class="separator:aa09b7ce0958137a3c59071cd2a181495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7fb7a49af884d3e490a6e7a93b9778"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a4c7fb7a49af884d3e490a6e7a93b9778">name</a> () const</td></tr>
<tr class="separator:a4c7fb7a49af884d3e490a6e7a93b9778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b4d82d1ea6bf19fefcc526eb886e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a4d5b4d82d1ea6bf19fefcc526eb886e3">tryTiming</a> (SrcType *src_port)</td></tr>
<tr class="memdesc:a4d5b4d82d1ea6bf19fefcc526eb886e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the layer accepts a packet from a specific port.  <a href="#a4d5b4d82d1ea6bf19fefcc526eb886e3">More...</a><br /></td></tr>
<tr class="separator:a4d5b4d82d1ea6bf19fefcc526eb886e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f80cb4abd4bf038af15c05081d02d7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a9f80cb4abd4bf038af15c05081d02d7d">succeededTiming</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> busy_time)</td></tr>
<tr class="memdesc:a9f80cb4abd4bf038af15c05081d02d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deal with a destination port accepting a packet by potentially removing the source port from the retry list (if retrying) and occupying the layer accordingly.  <a href="#a9f80cb4abd4bf038af15c05081d02d7d">More...</a><br /></td></tr>
<tr class="separator:a9f80cb4abd4bf038af15c05081d02d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a826f1e373e29eb3bfeae7ef3a8fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a93a826f1e373e29eb3bfeae7ef3a8fa9">failedTiming</a> (SrcType *src_port, <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> busy_time)</td></tr>
<tr class="memdesc:a93a826f1e373e29eb3bfeae7ef3a8fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deal with a destination port not accepting a packet by potentially adding the source port to the retry list (if not already at the front) and occupying the layer accordingly.  <a href="#a93a826f1e373e29eb3bfeae7ef3a8fa9">More...</a><br /></td></tr>
<tr class="separator:a93a826f1e373e29eb3bfeae7ef3a8fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b3f67580238f9ca8b9d54e62036a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a93b3f67580238f9ca8b9d54e62036a46">occupyLayer</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> until)</td></tr>
<tr class="separator:a93b3f67580238f9ca8b9d54e62036a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851f58de95a95afc51f864b32d9ff880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a851f58de95a95afc51f864b32d9ff880">retryWaiting</a> ()</td></tr>
<tr class="memdesc:a851f58de95a95afc51f864b32d9ff880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a retry to the port at the head of waitingForLayer.  <a href="#a851f58de95a95afc51f864b32d9ff880">More...</a><br /></td></tr>
<tr class="separator:a851f58de95a95afc51f864b32d9ff880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aa1d99311685b1bcc9e2c9784730c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a40aa1d99311685b1bcc9e2c9784730c3">recvRetry</a> ()</td></tr>
<tr class="memdesc:a40aa1d99311685b1bcc9e2c9784730c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a retry from a neighbouring module.  <a href="#a40aa1d99311685b1bcc9e2c9784730c3">More...</a><br /></td></tr>
<tr class="separator:a40aa1d99311685b1bcc9e2c9784730c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDrainable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDrainable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDrainable.html">Drainable</a></td></tr>
<tr class="memitem:a06aa9ed2bfe0ae1c9987c144a287f9fa inherit pub_methods_classDrainable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="drain_8hh.html#ac9ed0d5c83a29cf8938316f174264043">DrainState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a06aa9ed2bfe0ae1c9987c144a287f9fa">drainState</a> () const</td></tr>
<tr class="memdesc:a06aa9ed2bfe0ae1c9987c144a287f9fa inherit pub_methods_classDrainable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current drain state of an object.  <a href="classDrainable.html#a06aa9ed2bfe0ae1c9987c144a287f9fa">More...</a><br /></td></tr>
<tr class="separator:a06aa9ed2bfe0ae1c9987c144a287f9fa inherit pub_methods_classDrainable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddf1b5caa08845c11d12f1611b6be85 inherit pub_methods_classDrainable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a5ddf1b5caa08845c11d12f1611b6be85">notifyFork</a> ()</td></tr>
<tr class="memdesc:a5ddf1b5caa08845c11d12f1611b6be85 inherit pub_methods_classDrainable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a child process of a fork.  <a href="classDrainable.html#a5ddf1b5caa08845c11d12f1611b6be85">More...</a><br /></td></tr>
<tr class="separator:a5ddf1b5caa08845c11d12f1611b6be85 inherit pub_methods_classDrainable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classStats_1_1Group"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classStats_1_1Group')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classStats_1_1Group.html">Stats::Group</a></td></tr>
<tr class="memitem:a2b9f54ce812fcea38c81066446d435b3 inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a2b9f54ce812fcea38c81066446d435b3">Group</a> ()=delete</td></tr>
<tr class="separator:a2b9f54ce812fcea38c81066446d435b3 inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e85b9c272f2a4416c9add6642cd777 inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a03e85b9c272f2a4416c9add6642cd777">Group</a> (const <a class="el" href="classStats_1_1Group.html">Group</a> &amp;)=delete</td></tr>
<tr class="separator:a03e85b9c272f2a4416c9add6642cd777 inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fef46fa5f8b486ef710d3d764d5eea8 inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Group.html">Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a7fef46fa5f8b486ef710d3d764d5eea8">operator=</a> (const <a class="el" href="classStats_1_1Group.html">Group</a> &amp;)=delete</td></tr>
<tr class="separator:a7fef46fa5f8b486ef710d3d764d5eea8 inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90523b67da2ace5a5bbf5de7e74a73a4 inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a90523b67da2ace5a5bbf5de7e74a73a4">Group</a> (<a class="el" href="classStats_1_1Group.html">Group</a> *parent, const char *<a class="el" href="base_2trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>=nullptr)</td></tr>
<tr class="memdesc:a90523b67da2ace5a5bbf5de7e74a73a4 inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new statistics group.  <a href="classStats_1_1Group.html#a90523b67da2ace5a5bbf5de7e74a73a4">More...</a><br /></td></tr>
<tr class="separator:a90523b67da2ace5a5bbf5de7e74a73a4 inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506178b083653804dfdec28781485880 inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a506178b083653804dfdec28781485880">~Group</a> ()</td></tr>
<tr class="separator:a506178b083653804dfdec28781485880 inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51571a9ce454b2b4cb6d1e2d91e03ce inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#ae51571a9ce454b2b4cb6d1e2d91e03ce">regStats</a> ()</td></tr>
<tr class="memdesc:ae51571a9ce454b2b4cb6d1e2d91e03ce inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="Generic callback class. ">Callback</a> to set stat parameters.  <a href="classStats_1_1Group.html#ae51571a9ce454b2b4cb6d1e2d91e03ce">More...</a><br /></td></tr>
<tr class="separator:ae51571a9ce454b2b4cb6d1e2d91e03ce inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3b012622ff13ffe46cd0ae7af21f1b inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a4d3b012622ff13ffe46cd0ae7af21f1b">resetStats</a> ()</td></tr>
<tr class="memdesc:a4d3b012622ff13ffe46cd0ae7af21f1b inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="Generic callback class. ">Callback</a> to reset stats.  <a href="classStats_1_1Group.html#a4d3b012622ff13ffe46cd0ae7af21f1b">More...</a><br /></td></tr>
<tr class="separator:a4d3b012622ff13ffe46cd0ae7af21f1b inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e0ae31f6be822137bac2c61a157e2c inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a34e0ae31f6be822137bac2c61a157e2c">preDumpStats</a> ()</td></tr>
<tr class="memdesc:a34e0ae31f6be822137bac2c61a157e2c inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="Generic callback class. ">Callback</a> before stats are dumped.  <a href="classStats_1_1Group.html#a34e0ae31f6be822137bac2c61a157e2c">More...</a><br /></td></tr>
<tr class="separator:a34e0ae31f6be822137bac2c61a157e2c inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d672701dcee770be4f70f9e826dc0b inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#a94d672701dcee770be4f70f9e826dc0b">addStat</a> (<a class="el" href="classStats_1_1Info.html">Stats::Info</a> *info)</td></tr>
<tr class="memdesc:a94d672701dcee770be4f70f9e826dc0b inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a stat with this group.  <a href="classStats_1_1Group.html#a94d672701dcee770be4f70f9e826dc0b">More...</a><br /></td></tr>
<tr class="separator:a94d672701dcee770be4f70f9e826dc0b inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b905ff28b3ba36c88e3df7c4e626df inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="classStats_1_1Group.html">Group</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#ad5b905ff28b3ba36c88e3df7c4e626df">getStatGroups</a> () const</td></tr>
<tr class="memdesc:ad5b905ff28b3ba36c88e3df7c4e626df inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all child groups associated with this object.  <a href="classStats_1_1Group.html#ad5b905ff28b3ba36c88e3df7c4e626df">More...</a><br /></td></tr>
<tr class="separator:ad5b905ff28b3ba36c88e3df7c4e626df inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecb43888a3d5697e4ec99c23c217712 inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classStats_1_1Info.html">Info</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#abecb43888a3d5697e4ec99c23c217712">getStats</a> () const</td></tr>
<tr class="memdesc:abecb43888a3d5697e4ec99c23c217712 inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all stats associated with this object.  <a href="classStats_1_1Group.html#abecb43888a3d5697e4ec99c23c217712">More...</a><br /></td></tr>
<tr class="separator:abecb43888a3d5697e4ec99c23c217712 inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83eca43363ffe9e08e38aa2ceb8bf4d inherit pub_methods_classStats_1_1Group"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStats_1_1Group.html#ad83eca43363ffe9e08e38aa2ceb8bf4d">addStatGroup</a> (const char *<a class="el" href="base_2trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>, <a class="el" href="classStats_1_1Group.html">Group</a> *block)</td></tr>
<tr class="memdesc:ad83eca43363ffe9e08e38aa2ceb8bf4d inherit pub_methods_classStats_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a stat block as a child of this block.  <a href="classStats_1_1Group.html#ad83eca43363ffe9e08e38aa2ceb8bf4d">More...</a><br /></td></tr>
<tr class="separator:ad83eca43363ffe9e08e38aa2ceb8bf4d inherit pub_methods_classStats_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a170527789700e5ba3b60c57274c1e834"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a170527789700e5ba3b60c57274c1e834">sendRetry</a> (SrcType *retry_port)=0</td></tr>
<tr class="memdesc:a170527789700e5ba3b60c57274c1e834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sending the actual retry, in a manner specific to the individual layers.  <a href="#a170527789700e5ba3b60c57274c1e834">More...</a><br /></td></tr>
<tr class="separator:a170527789700e5ba3b60c57274c1e834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDrainable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDrainable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDrainable.html">Drainable</a></td></tr>
<tr class="memitem:ac2b5f739cc6ae6bdb563763a1f3c40f9 inherit pro_methods_classDrainable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#ac2b5f739cc6ae6bdb563763a1f3c40f9">Drainable</a> ()</td></tr>
<tr class="separator:ac2b5f739cc6ae6bdb563763a1f3c40f9 inherit pro_methods_classDrainable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41cf77f0309d150245b592d5f7c3c01 inherit pro_methods_classDrainable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#ac41cf77f0309d150245b592d5f7c3c01">~Drainable</a> ()</td></tr>
<tr class="separator:ac41cf77f0309d150245b592d5f7c3c01 inherit pro_methods_classDrainable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0068fbb207004376833aa889266a4aea inherit pro_methods_classDrainable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a0068fbb207004376833aa889266a4aea">drainResume</a> ()</td></tr>
<tr class="memdesc:a0068fbb207004376833aa889266a4aea inherit pro_methods_classDrainable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume execution after a successful drain.  <a href="classDrainable.html#a0068fbb207004376833aa889266a4aea">More...</a><br /></td></tr>
<tr class="separator:a0068fbb207004376833aa889266a4aea inherit pro_methods_classDrainable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e3b2acc20ebd149239adab1024c2a1 inherit pro_methods_classDrainable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#af0e3b2acc20ebd149239adab1024c2a1">signalDrainDone</a> () const</td></tr>
<tr class="memdesc:af0e3b2acc20ebd149239adab1024c2a1 inherit pro_methods_classDrainable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that an object is drained.  <a href="classDrainable.html#af0e3b2acc20ebd149239adab1024c2a1">More...</a><br /></td></tr>
<tr class="separator:af0e3b2acc20ebd149239adab1024c2a1 inherit pro_methods_classDrainable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad8d693fc2d8f687b84ae40257f6ad853"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">State</a> { <a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853a477d4815cfed34a8bdead62bead99bf3">IDLE</a>, 
<a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853a57716336066224386ba0ccd513c1082c">BUSY</a>, 
<a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853a511ea8beebae31279c7c7d82e2b16144">RETRY</a>
 }<tr class="memdesc:ad8d693fc2d8f687b84ae40257f6ad853"><td class="mdescLeft">&#160;</td><td class="mdescRight">We declare an enum to track the state of the layer.  <a href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad8d693fc2d8f687b84ae40257f6ad853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a83153991c1984dd752e6c1d5b935c1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a83153991c1984dd752e6c1d5b935c1f8">releaseLayer</a> ()</td></tr>
<tr class="memdesc:a83153991c1984dd752e6c1d5b935c1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the layer after being occupied and return to an idle state where we proceed to send a retry to any potential waiting port, or drain if asked to do so.  <a href="#a83153991c1984dd752e6c1d5b935c1f8">More...</a><br /></td></tr>
<tr class="separator:a83153991c1984dd752e6c1d5b935c1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4e62a15e2b97470f15934f764869fe4d"><td class="memItemLeft" align="right" valign="top">DstType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a4e62a15e2b97470f15934f764869fe4d">port</a></td></tr>
<tr class="memdesc:a4e62a15e2b97470f15934f764869fe4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destination port this layer converges at.  <a href="#a4e62a15e2b97470f15934f764869fe4d">More...</a><br /></td></tr>
<tr class="separator:a4e62a15e2b97470f15934f764869fe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf39e091d7dd8430c5c18838c96bf89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseXBar.html">BaseXBar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aeaf39e091d7dd8430c5c18838c96bf89">xbar</a></td></tr>
<tr class="memdesc:aeaf39e091d7dd8430c5c18838c96bf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">The crossbar this layer is a part of.  <a href="#aeaf39e091d7dd8430c5c18838c96bf89">More...</a><br /></td></tr>
<tr class="separator:aeaf39e091d7dd8430c5c18838c96bf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8b8f3c32cb2bfe3c4cd109a021382b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a9a8b8f3c32cb2bfe3c4cd109a021382b">_name</a></td></tr>
<tr class="separator:a9a8b8f3c32cb2bfe3c4cd109a021382b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c7640848b98813aa4f0eff6d71c542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#ac2c7640848b98813aa4f0eff6d71c542">state</a></td></tr>
<tr class="separator:ac2c7640848b98813aa4f0eff6d71c542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18099d5e0514428ef7d4fe59b80ec0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; SrcType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#ac18099d5e0514428ef7d4fe59b80ec0b">waitingForLayer</a></td></tr>
<tr class="memdesc:ac18099d5e0514428ef7d4fe59b80ec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deque of ports that retry should be called on because the original send was delayed due to a busy layer.  <a href="#ac18099d5e0514428ef7d4fe59b80ec0b">More...</a><br /></td></tr>
<tr class="separator:ac18099d5e0514428ef7d4fe59b80ec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee92c98b7237b3f836b2b908cccedfc"><td class="memItemLeft" align="right" valign="top">SrcType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#afee92c98b7237b3f836b2b908cccedfc">waitingForPeer</a></td></tr>
<tr class="memdesc:afee92c98b7237b3f836b2b908cccedfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track who is waiting for the retry when receiving it from a peer.  <a href="#afee92c98b7237b3f836b2b908cccedfc">More...</a><br /></td></tr>
<tr class="separator:afee92c98b7237b3f836b2b908cccedfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c78769ba3e37ef52a1ea01bec524566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventFunctionWrapper.html">EventFunctionWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a2c78769ba3e37ef52a1ea01bec524566">releaseEvent</a></td></tr>
<tr class="separator:a2c78769ba3e37ef52a1ea01bec524566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6ae1b92ca750758b4fa8165b6102b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aab6ae1b92ca750758b4fa8165b6102b9">occupancy</a></td></tr>
<tr class="memdesc:aab6ae1b92ca750758b4fa8165b6102b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceStats.html">Stats</a> for occupancy and utilization.  <a href="#aab6ae1b92ca750758b4fa8165b6102b9">More...</a><br /></td></tr>
<tr class="separator:aab6ae1b92ca750758b4fa8165b6102b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0909c1252acbfed0b398bb60e803d434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Formula.html">Stats::Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a0909c1252acbfed0b398bb60e803d434">utilization</a></td></tr>
<tr class="separator:a0909c1252acbfed0b398bb60e803d434"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SrcType, typename DstType&gt;<br />
class BaseXBar::Layer&lt; SrcType, DstType &gt;</h3>

<p>A layer is an internal crossbar arbitration point with its own flow control. </p>
<p>Each layer is a converging multiplexer tree. By instantiating one layer per destination port (and per packet type, i.e. request, response, snoop request and snoop response), we model full crossbar structures like AXI, ACE, PCIe, etc.</p>
<p>The template parameter, PortClass, indicates the destination port type for the layer. The retry list holds either master ports or slave ports, depending on the direction of the layer. Thus, a request layer has a retry list containing slave ports, whereas a response layer holds master ports. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00093">93</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad8d693fc2d8f687b84ae40257f6ad853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d693fc2d8f687b84ae40257f6ad853">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">BaseXBar::Layer::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We declare an enum to track the state of the layer. </p>
<p>The starting point is an idle state where the layer is waiting for a packet to arrive. Upon arrival, the layer transitions to the busy state, where it remains either until the packet transfer is done, or the header time is spent. Once the layer leaves the busy state, it can either go back to idle, if no packets have arrived while it was busy, or the layer goes on to retry the first port in waitingForLayer. A similar transition takes place from idle to retry if the layer receives a retry from one of its connected ports. The retry state lasts until the port in questions calls sendTiming and returns control to the layer, or goes to a busy state if the port does not immediately react to the retry by calling sendTiming. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad8d693fc2d8f687b84ae40257f6ad853a477d4815cfed34a8bdead62bead99bf3"></a>IDLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8d693fc2d8f687b84ae40257f6ad853a57716336066224386ba0ccd513c1082c"></a>BUSY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8d693fc2d8f687b84ae40257f6ad853a511ea8beebae31279c7c7d82e2b16144"></a>RETRY&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00205">205</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a428be70018298eaa415485040d397f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428be70018298eaa415485040d397f11">&#9670;&nbsp;</a></span>Layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html">Layer</a> </td>
          <td>(</td>
          <td class="paramtype">DstType &amp;&#160;</td>
          <td class="paramname"><em>_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBaseXBar.html">BaseXBar</a> &amp;&#160;</td>
          <td class="paramname"><em>_xbar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a layer and give it a name. </p>
<p>The layer uses the crossbar an event manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_port</td><td>destination port the layer converges at </td></tr>
    <tr><td class="paramname">_xbar</td><td>the crossbar this layer belongs to </td></tr>
    <tr><td class="paramname">_name</td><td>the layer's name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00141">141</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa09b7ce0958137a3c59071cd2a181495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09b7ce0958137a3c59071cd2a181495">&#9670;&nbsp;</a></span>drain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="drain_8hh.html#ac9ed0d5c83a29cf8938316f174264043">DrainState</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::drain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drain according to the normal semantics, so that the crossbar can tell the layer to drain, and pass an event to signal back when drained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">de</td><td>drain event to call once drained</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if busy or waiting to retry, or 0 if idle </dd></dl>

<p>Implements <a class="el" href="classDrainable.html#ad800a050442ba749dbca02aa14468096">Drainable</a>.</p>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00583">583</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

</div>
</div>
<a id="a93a826f1e373e29eb3bfeae7ef3a8fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a826f1e373e29eb3bfeae7ef3a8fa9">&#9670;&nbsp;</a></span>failedTiming()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::failedTiming </td>
          <td>(</td>
          <td class="paramtype">SrcType *&#160;</td>
          <td class="paramname"><em>src_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td>
          <td class="paramname"><em>busy_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deal with a destination port not accepting a packet by potentially adding the source port to the retry list (if not already at the front) and occupying the layer accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_port</td><td>Source port </td></tr>
    <tr><td class="paramname">busy_time</td><td><a class="el" href="classTime.html">Time</a> to spend as a result of a failed send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00224">224</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="a4c7fb7a49af884d3e490a6e7a93b9778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7fb7a49af884d3e490a6e7a93b9778">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00119">119</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="a93b3f67580238f9ca8b9d54e62036a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b3f67580238f9ca8b9d54e62036a46">&#9670;&nbsp;</a></span>occupyLayer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::occupyLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td>
          <td class="paramname"><em>until</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00160">160</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="a40aa1d99311685b1bcc9e2c9784730c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aa1d99311685b1bcc9e2c9784730c3">&#9670;&nbsp;</a></span>recvRetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::recvRetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle a retry from a neighbouring module. </p>
<p>This wraps retryWaiting by verifying that there are ports waiting before calling retryWaiting. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00305">305</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="a83153991c1984dd752e6c1d5b935c1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83153991c1984dd752e6c1d5b935c1f8">&#9670;&nbsp;</a></span>releaseLayer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::releaseLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the layer after being occupied and return to an idle state where we proceed to send a retry to any potential waiting port, or drain if asked to do so. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00246">246</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

</div>
</div>
<a id="a851f58de95a95afc51f864b32d9ff880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851f58de95a95afc51f864b32d9ff880">&#9670;&nbsp;</a></span>retryWaiting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::retryWaiting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a retry to the port at the head of waitingForLayer. </p>
<p>The caller must ensure that the list is not empty. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00270">270</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="a170527789700e5ba3b60c57274c1e834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170527789700e5ba3b60c57274c1e834">&#9670;&nbsp;</a></span>sendRetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::sendRetry </td>
          <td>(</td>
          <td class="paramtype">SrcType *&#160;</td>
          <td class="paramname"><em>retry_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sending the actual retry, in a manner specific to the individual layers. </p>
<p>Note that for a <a class="el" href="classMasterPort.html" title="A MasterPort is a specialisation of a BaseMasterPort, which implements the default protocol for the t...">MasterPort</a>, there is both a RequestLayer and a SnoopResponseLayer using the same port, but using different functions for the flow control. </p>

<p>Implemented in <a class="el" href="classBaseXBar_1_1SnoopRespLayer.html#aacd8bc29caec4da06954d3be114a4d22">BaseXBar::SnoopRespLayer</a>, <a class="el" href="classBaseXBar_1_1RespLayer.html#a60a3003d815b45dea17c54df8aac7a82">BaseXBar::RespLayer</a>, and <a class="el" href="classBaseXBar_1_1ReqLayer.html#ac823c116fbec3959a657563ccdf852d5">BaseXBar::ReqLayer</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="a9f80cb4abd4bf038af15c05081d02d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f80cb4abd4bf038af15c05081d02d7d">&#9670;&nbsp;</a></span>succeededTiming()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::succeededTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&#160;</td>
          <td class="paramname"><em>busy_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deal with a destination port accepting a packet by potentially removing the source port from the retry list (if retrying) and occupying the layer accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busy_time</td><td><a class="el" href="classTime.html">Time</a> to spend as a result of a successful send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00212">212</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="a4d5b4d82d1ea6bf19fefcc526eb886e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b4d82d1ea6bf19fefcc526eb886e3">&#9670;&nbsp;</a></span>tryTiming()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::tryTiming </td>
          <td>(</td>
          <td class="paramtype">SrcType *&#160;</td>
          <td class="paramname"><em>src_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the layer accepts a packet from a specific port. </p>
<p>If not, the port in question is also added to the retry list. In either case the state of the layer is updated accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Source port presenting the packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the layer accepts the packet </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbar_8cc_source.html#l00181">181</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9a8b8f3c32cb2bfe3c4cd109a021382b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8b8f3c32cb2bfe3c4cd109a021382b">&#9670;&nbsp;</a></span>_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00187">187</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="xbar_8hh_source.html#l00119">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>.</p>

</div>
</div>
<a id="aab6ae1b92ca750758b4fa8165b6102b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6ae1b92ca750758b4fa8165b6102b9">&#9670;&nbsp;</a></span>occupancy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::occupancy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceStats.html">Stats</a> for occupancy and utilization. </p>
<p>These stats capture the time the layer spends in the busy state and are thus only relevant when the memory system is in timing mode. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00234">234</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="a4e62a15e2b97470f15934f764869fe4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e62a15e2b97470f15934f764869fe4d">&#9670;&nbsp;</a></span>port</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DstType&amp; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::port</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destination port this layer converges at. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00182">182</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="a2c78769ba3e37ef52a1ea01bec524566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c78769ba3e37ef52a1ea01bec524566">&#9670;&nbsp;</a></span>releaseEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventFunctionWrapper.html">EventFunctionWrapper</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::releaseEvent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00227">227</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="ac2c7640848b98813aa4f0eff6d71c542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c7640848b98813aa4f0eff6d71c542">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">State</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00207">207</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="a0909c1252acbfed0b398bb60e803d434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0909c1252acbfed0b398bb60e803d434">&#9670;&nbsp;</a></span>utilization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Formula.html">Stats::Formula</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::utilization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00235">235</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="ac18099d5e0514428ef7d4fe59b80ec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18099d5e0514428ef7d4fe59b80ec0b">&#9670;&nbsp;</a></span>waitingForLayer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;SrcType*&gt; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::waitingForLayer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deque of ports that retry should be called on because the original send was delayed due to a busy layer. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00213">213</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="afee92c98b7237b3f836b2b908cccedfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee92c98b7237b3f836b2b908cccedfc">&#9670;&nbsp;</a></span>waitingForPeer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcType* <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::waitingForPeer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Track who is waiting for the retry when receiving it from a peer. </p>
<p>If no port is waiting NULL is stored. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00219">219</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a id="aeaf39e091d7dd8430c5c18838c96bf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf39e091d7dd8430c5c18838c96bf89">&#9670;&nbsp;</a></span>xbar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseXBar.html">BaseXBar</a>&amp; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::xbar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The crossbar this layer is a part of. </p>

<p class="definition">Definition at line <a class="el" href="xbar_8hh_source.html#l00185">185</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="xbar_8hh_source.html">xbar.hh</a></li>
<li>mem/<a class="el" href="xbar_8cc_source.html">xbar.cc</a></li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Mon Nov 25 2019 12:52:15 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.8.13</small></address>
</body>
</html>
